    /*
 * SQLGetHandler.java
 *
 * Created on August 25, 2005, 10:33 AM
 *
 */
package net.terakeet.soapware.handlers;

import net.terakeet.soapware.*;
import net.terakeet.soapware.handlers.auper.*;
import net.terakeet.soapware.handlers.report.ProductMap;
import net.terakeet.soapware.security.*;
import net.terakeet.usbn.WebPermission;
import net.terakeet.util.MidwareLogger;
import java.text.SimpleDateFormat;
import net.terakeet.util.TemplatedMessage;
import net.terakeet.util.MailException;
import net.terakeet.soapware.handlers.report.*;
import org.apache.log4j.Logger;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import org.dom4j.Element;
import java.sql.CallableStatement;
import java.text.ParseException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.CallableStatement;
import java.lang.String;
import java.util.Iterator;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Properties;
import java.text.*;
import java.util.*;
//import javax.mail.*;
//import javax.mail.internet.MimeMessage;
//import javax.mail.internet.InternetAddress;
public class SQLGetHandler implements Handler {

    private static SimpleDateFormat newDateFormat =
            new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    private static SimpleDateFormat dateFormat
                                            = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");    
    private MidwareLogger logger;
    private RegisteredConnection transconn;
    static final String transConnName = "auper";
    private SecureSession ss;    
    private DecimalFormat cf;
    private DecimalFormat pf;
        

    /**
     * Creates a new instance of SQLGetHandler
     */
    public SQLGetHandler() throws HandlerException {
        HandlerUtils.initializeClientKeyManager();
        logger = new MidwareLogger(SQLGetHandler.class.getName());
        cf  = (DecimalFormat) NumberFormat.getInstance(Locale.US);
        pf  = (DecimalFormat) NumberFormat.getInstance(Locale.US);
        transconn = null;
    }

    public void handle(Element toHandle, Element toAppend) throws HandlerException {

        String function = toHandle.getName();
        String responseNamespace = (String) SOAPMessage.getURIMap().get("tkmsg");

        String clientKey = HandlerUtils.getOptionalString(toHandle, "clientKey");
        ss = ClientKeyManager.getSession(clientKey);

        logger = new MidwareLogger(SQLGetHandler.class.getName(), function);
        logger.debug("SQLGetHandler processing method: " + function);
        logger.xml("request: " + toHandle.asXML());

        transconn = DatabaseConnectionManager.getNewConnection(transConnName,
                function + " (SQLGetHandler)");
        cf.applyPattern("###,##0.00");
        pf.applyPattern("#.##");
        try {
            // All methods require an admin client key
            if (ss.getLocation() == 0 && ss.getClientId() == 1 && ss.getSecurityLevel().canAdmin()) {
                if ("getLocations".equals(function)) {
                    getLocations(toHandle, responseFor(function, toAppend));
                } else if ("getInventory".equals(function)) {
                    getInventory(toHandle, responseFor(function, toAppend));
                } else if ("getReportInventory".equals(function)) {
                    getReportInventory(toHandle, responseFor(function, toAppend));
                } else if ("getProducts".equals(function)) {
                    getProducts(toHandle, responseFor(function, toAppend));
                } else if ("getBeverages".equals(function)) {
                    getBeverages(toHandle, responseFor(function, toAppend));
                } else if ("getLastReading".equals(function)) {
                    getLastReading(toHandle, responseFor(function, toAppend));
                } else if ("getGatewayInfo".equals(function)) {
                    getGatewayInfo(toHandle, responseFor(function, toAppend));
                } else if ("getBeverageSizes".equals(function)) {
                    getBeverageSizes(toHandle, responseFor(function, toAppend));
                } else if ("getCurrentLines".equals(function)) {
                    getCurrentLines(toHandle, responseFor(function, toAppend));
                } else if ("getCustomers".equals(function)) {
                    getCustomers(toHandle, responseFor(function, toAppend));
                } else if ("getCategory".equals(function)) {
                    getCategory(toHandle, responseFor(function, toAppend));
                } else if ("getUserLocation".equals(function)) {
                    getUserLocation(toHandle, responseFor(function, toAppend));
                } else if ("getUserRegion".equals(function)) {
                    getUserRegion(toHandle, responseFor(function, toAppend));
                } else if ("getReportList".equals(function)) {
                    getReportList(toHandle, responseFor(function, toAppend));
                } else if ("getProductSetProduct".equals(function)) {
                    getProductSetProduct(toHandle, responseFor(function, toAppend));
                } else if ("getRegionProductSet".equals(function)) {
                    getRegionProductSet(toHandle, responseFor(function, toAppend));
                } else if ("getGroupProductSet".equals(function)) {
                    getGroupProductSet(toHandle, responseFor(function, toAppend));
                } else if ("getGroupRegion".equals(function)) {
                    getGroupRegion(toHandle, responseFor(function, toAppend));
                } else if ("getGroupExclusions".equals(function)) {
                    getGroupExclusions(toHandle, responseFor(function, toAppend));
                } else if ("getGroupType".equals(function)) {
                    getGroupType(toHandle, responseFor(function, toAppend));
                } else if ("getProductSetType".equals(function)) {
                    getProductSetType(toHandle, responseFor(function, toAppend));
                } else if ("getProductSet".equals(function)) {
                    getProductSet(toHandle, responseFor(function, toAppend));
                } else if ("getState".equals(function)) {
                    getState(toHandle, responseFor(function, toAppend));
                } else if ("getGroups".equals(function)) {
                    getGroups(toHandle, responseFor(function, toAppend));
                } else if ("getManualExclusions".equals(function)) {
                    getManualExclusions(toHandle, responseFor(function, toAppend));
                } else if ("getExclusions".equals(function)) {
                    getExclusions(toHandle, responseFor(function, toAppend));
                } else if ("getSegment".equals(function)) {
                    getSegment(toHandle, responseFor(function, toAppend));
                } else if ("getBrix".equals(function)) {
                    getBrix(toHandle, responseFor(function, toAppend));
                } else if ("getLine".equals(function)) {
                    getLine(toHandle, responseFor(function, toAppend));
                } else if ("getDataCorrectionInfo".equals(function)) {
                    getDataCorrectionInfo(toHandle, responseFor(function, toAppend));
                } else if ("getSystems".equals(function)) {
                    getSystems(toHandle, responseFor(function, toAppend));
                } else if ("getCountyPoints".equals(function)) {
                    getCountyPoints(toHandle, responseFor(function, toAppend));
                } else if ("getCounties".equals(function)) {
                    getCounties(toHandle, responseFor(function, toAppend));
                } else if ("getRegions".equals(function)) {
                    getRegions(toHandle, responseFor(function, toAppend));
                } else if ("getRegionMaster".equals(function)) {
                    getRegionMaster(toHandle, responseFor(function, toAppend));
                }  else if ("getTapCount".equals(function)) {
                    getTapCount(toHandle, responseFor(function, toAppend));
                } else if ("sendSystemAlerts".equals(function)) {
                    sendSystemAlerts(toHandle, responseFor(function, toAppend));
                } else if ("sendUserAlerts".equals(function)) {
                    sendUserAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getEmailReports".equals(function)) {
                    getEmailReports(toHandle, responseFor(function, toAppend));
                } else if ("getSuperUserAlerts".equals(function)) {
                    getSuperUserAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getUserAlerts".equals(function)) {
                    getUserAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getUserAlertType".equals(function)) {
                    getUserAlertType(toHandle, responseFor(function, toAppend));
                } else if ("getTextAlerts".equals(function)) {
                    getTextAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getActiveTextAlerts".equals(function)) {
                    getActiveTextAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getLocationCount".equals(function)) {
                    getLocationCount(toHandle, responseFor(function, toAppend));
                } else if ("checkEventTime".equals(function)) {
                    checkEventTime(toHandle, responseFor(function, toAppend));
                } else if ("getLocationHours".equals(function)) {
                    getLocationHours(toHandle, responseFor(function, toAppend));
                } else if ("authBevSyncUser".equals(function)) {
                    authBevSyncUser(toHandle, responseFor(function, toAppend));
                } else if ("authSupplierUser".equals(function)) {
                    authSupplierUser(toHandle, responseFor(function, toAppend));
                } else if ("authUser".equals(function)) {
                    authUser(toHandle, responseFor(function, toAppend));
                } else if ("getUserDashboard".equals(function)) {
                    getUserDashboard(toHandle, responseFor(function, toAppend));
                } else if ("getUserPreferences".equals(function)) {
                    getUserPreferences(toHandle, responseFor(function, toAppend));
                } else if ("adminChangeCustomer".equals(function)) {
                    adminChangeCustomer(toHandle, responseFor(function, toAppend));
                } else if ("getProductDetail".equals(function)) {
                    getProductDetail(toHandle, responseFor(function, toAppend));
                } else if ("getVarianceEmailAlerts".equals(function)) {
                    getVarianceEmailAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getSupplierUserDetail".equals(function)) {
                    getSupplierUserDetail(toHandle, responseFor(function, toAppend));
                } else if ("getBeverageDetail".equals(function)) {
                    getBeverageDetail(toHandle, responseFor(function, toAppend));
                } else if ("getRecentlyOrderedProducts".equals(function)) {
                    getRecentlyOrderedProducts(toHandle, responseFor(function, toAppend));
                } else if ("getProductRequests".equals(function)) {
                    getProductRequests(toHandle, responseFor(function, toAppend));
                } else if ("getProductRequestNotifications".equals(function)) {
                    getProductRequestNotifications(toHandle, responseFor(function, toAppend));
                } else if ("getLocationStatusNotifications".equals(function)) {
                    getLocationStatusNotifications(toHandle, responseFor(function, toAppend));
                } else if ("getPurchaseDetail".equals(function)) {
                    getPurchaseDetail(toHandle, responseFor(function, toAppend));
                } else if ("getPurchases".equals(function)) {
                    getPurchases(toHandle, responseFor(function, toAppend));
                } else if ("getSupplierRequests".equals(function)) {
                    getSupplierRequests(toHandle, responseFor(function, toAppend));
                } else if ("getSuppliers".equals(function)) {
                    getSuppliers(toHandle, responseFor(function, toAppend));
                } else if ("getLocationSuppliers".equals(function)) {
                    getLocationSuppliers(toHandle, responseFor(function, toAppend));
                } else if ("getSetupInfo".equals(function)) {
                    getSetupInfo(toHandle, responseFor(function, toAppend));
                } else if ("getNormalUsers".equals(function)) {
                    getNormalUsers(toHandle, responseFor(function, toAppend));
                } else if ("getAdminUsers".equals(function)) {
                    getAdminUsers(toHandle, responseFor(function, toAppend));
                } else if ("getDailySupplierReports".equals(function)) {
                    getDailySupplierReports(toHandle, responseFor(function, toAppend));
                } else if ("getWeeklySupplierReports".equals(function)) {
                    getWeeklySupplierReports(toHandle, responseFor(function, toAppend));
                } else if ("getUserDetail".equals(function)) {
                    getUserDetail(toHandle, responseFor(function, toAppend));
                } else if ("getUserEmailInfo".equals(function)) {
                    getUserEmailInfo(toHandle, responseFor(function, toAppend));
                } else if ("emailPurchase".equals(function)) {
                    emailPurchase(toHandle, responseFor(function, toAppend));
                } else if ("getBars".equals(function)) {
                    getBars(toHandle, responseFor(function, toAppend));
                } else if ("getLowStock".equals(function)) {
                    getLowStock(toHandle, responseFor(function, toAppend));
                } else if ("getLowStockAlerts".equals(function)) {
                    getLowStockAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getLineCleaningHistory".equals(function)) {
                    getLineCleaningHistory(toHandle, responseFor(function, toAppend));
                } else if ("getClientKey".equals(function)) {
                    getClientKey(toHandle, responseFor(function, toAppend), ss);
                } else if ("getDbHealth".equals(function)) {
                    getDbHealth(toHandle, responseFor(function, toAppend));
                } else if ("getUsers".equals(function)) {
                    throw new HandlerException("the getUsers method is no longer supported");
                    // deprecated
                    //getUsers(toHandle, responseFor(function, toAppend));
                } else if ("lookupQuicksell".equals(function)) {
                    throw new HandlerException("the lookupQuicksell method is no longer supported");
                    // deprecated
                    //lookupQuicksell(toHandle, responseFor(function, toAppend));
                } else if ("getMiscProducts".equals(function)) {
                    getMiscProducts(toHandle, responseFor(function, toAppend));
                } else if ("getPurchaseSummary".equals(function)) {
                    getPurchaseSummary(toHandle, responseFor(function, toAppend));
                } else if ("getSystemTemperature".equals(function)) {
                    getSystemTemperature(toHandle, responseFor(function, toAppend));
                } else if ("getLocationsMasterData".equals(function)) {
                    getLocationsMasterData(toHandle, responseFor(function, toAppend));
                } else if ("getCostCenters".equals(function)) {
                    getCostCenters(toHandle, responseFor(function, toAppend));
                } else if ("getProductTypes".equals(function)) {
                    getProductTypes(toHandle, responseFor(function, toAppend));
                } else if ("getProductSetsForProduct".equals(function)) {
                    getProductSetsForProduct(toHandle, responseFor(function, toAppend));
                } else if ("getLineAssignments".equals(function)) {
                    getLineAssignments(toHandle, responseFor(function, toAppend));
                } else if ("getLocationDetails".equals(function)) {
                    getLocationDetails(toHandle, responseFor(function, toAppend));
                } else if ("getBevBox".equals(function)) {
                    getBevBox(toHandle, responseFor(function, toAppend));
                } else if ("getSuspensions".equals(function)) {
                    getSuspensions(toHandle, responseFor(function, toAppend));
                } else if ("getLocationRights".equals(function)) {
                    getLocationRights(toHandle, responseFor(function, toAppend));
                } else if ("getLineCleaning".equals(function)) {
                    getLineCleaning(toHandle, responseFor(function, toAppend));
                } else if ("getCustomerPeriods".equals(function)) {
                    getCustomerPeriods(toHandle, responseFor(function, toAppend));
                } else if ("getProductCategory".equals(function)) {
                    getProductCategory(toHandle, responseFor(function, toAppend));
                } else if ("getUserEmailDetails".equals(function)) {
                    getUserEmailDetails(toHandle, responseFor(function, toAppend));
                } else if ("addUpdateLocationLogo".equals(function)) {
                    addUpdateLocationLogo(toHandle, responseFor(function, toAppend));
                } else if ("getLocationLogo".equals(function)) {
                    getLocationLogo(toHandle, responseFor(function, toAppend));
                } else if ("getBBTVFonts".equals(function)) {
                    getBBTVFonts(toHandle, responseFor(function, toAppend));
                } else if ("getBBTVDesign".equals(function)) {
                    getBBTVDesign(toHandle, responseFor(function, toAppend));
                } else if ("getBeerBoardSettings".equals(function)) {
                    getBeerBoardSettings(toHandle, responseFor(function, toAppend));
                } else if ("getGenericResult".equals(function)) {
                    getGenericResult(toHandle, responseFor(function, toAppend));
                } else if ("authTestUser".equals(function)) {
                    authTestUser(toHandle, responseFor(function, toAppend));
                } else if ("getProducts1".equals(function)) {
                    getProducts1(toHandle, responseFor(function, toAppend));
                } else if ("getDraftInventory".equals(function)) {
                    getDraftInventory(toHandle, responseFor(function, toAppend));
                } else if ("getTestInventory".equals(function)) {
                    getTestInventory(toHandle, responseFor(function, toAppend));
                } else if ("getTestInventory1".equals(function)) {
                    getTestInventory1(toHandle, responseFor(function, toAppend));
                } else if ("getGenericResult1".equals(function)) {
                    getGenericResult1(toHandle, responseFor(function, toAppend));
                }  else if ("getLocationErrorDetail".equals(function)) {
                    getLocationErrorDetail(toHandle, responseFor(function, toAppend));
                } else if ("getGenericResult2".equals(function)) {
                    getGenericResult2(toHandle, responseFor(function, toAppend));
                } else if ("emailUser".equals(function)) {
                    emailUser(toHandle, responseFor(function, toAppend));
                } else if ("getGenericResult3".equals(function)) {
                    getGenericResult3(toHandle, responseFor(function, toAppend));
                } else if ("getTestPurchaseDetail".equals(function)) {
                    getTestPurchaseDetail(toHandle, responseFor(function, toAppend));
                } else if ("getGenericResult4".equals(function)) {
                    getGenericResult4(toHandle, responseFor(function, toAppend));
                } else if ("getGenericResult5".equals(function)) {
                    getGenericResult5(toHandle, responseFor(function, toAppend));
                } else if ("getVarianceTextAlerts".equals(function)) {
                    getVarianceTextAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getLowStockTextAlerts".equals(function)) {
                    getLowStockTextAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getConcessionVarianceTextAlerts".equals(function)) {
                    getConcessionVarianceTextAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getConcessionLowStockTextAlerts".equals(function)) {
                    getConcessionLowStockTextAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getReports".equals(function)) {
                    getReports(toHandle, responseFor(function, toAppend));
                } else if ("getZones".equals(function)) {
                    getZones(toHandle, responseFor(function, toAppend));
                } else if ("getStations".equals(function)) {
                    getStations(toHandle, responseFor(function, toAppend));
                } else if ("getCoolers".equals(function)) {
                    getCoolers(toHandle, responseFor(function, toAppend));
                } else if ("getKegLines".equals(function)) {
                    getKegLines(toHandle, responseFor(function, toAppend));
                } else if ("getUnits".equals(function)) {
                    getUnits(toHandle, responseFor(function, toAppend));
                } else if ("getLocationReports".equals(function)) {
                    getLocationReports(toHandle, responseFor(function, toAppend));
                } else if ("getLocationSMSAlerts".equals(function)) {
                    getLocationSMSAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getLocationTextAlerts".equals(function)) {
                    getLocationTextAlerts(toHandle, responseFor(function, toAppend));
                } else if ("checkRewards".equals(function)) {
                    checkRewards(toHandle, responseFor(function, toAppend));
                } else if ("getBeverages1".equals(function)) {
                    getBeverages1(toHandle, responseFor(function, toAppend));
                } else if ("getComplexPlu".equals(function)) {
                    getComplexPlu(toHandle, responseFor(function, toAppend));
                } else if ("getTestNormalUsers".equals(function)) {
                    getTestNormalUsers(toHandle, responseFor(function, toAppend));
                } else if ("getLocationVariance".equals(function)) {
                    getLocationVariance(toHandle, responseFor(function, toAppend));
                } else if ("getRecentlyReceivedProducts".equals(function)) {
                    getRecentlyReceivedProducts(toHandle, responseFor(function, toAppend));
                } else if ("getLocationData".equals(function)) {
                    getLocationData(toHandle, responseFor(function, toAppend));
                } else if ("sendAlerts".equals(function)) {
                    sendAlerts(toHandle, responseFor(function, toAppend));
                } else if ("sendLocationStatusAlerts".equals(function)) {
                    sendLocationStatusAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getBeverageSizes1".equals(function)) {
                    getBeverageSizes1(toHandle, responseFor(function, toAppend));
                } else if ("getBottleSize".equals(function)) {
                    getBottleSize(toHandle, responseFor(function, toAppend));
                } else if ("getKegSize".equals(function)) {
                    getKegSize(toHandle, responseFor(function, toAppend));
                } else if ("getShifts".equals(function)) {
                    getShifts(toHandle, responseFor(function, toAppend));
                } else if ("getLocationId".equals(function)) {
                    getLocationId(toHandle, responseFor(function, toAppend));
                } else if ("getReportRequest".equals(function)) {
                    getReportRequest(toHandle, responseFor(function, toAppend));
                } else if ("requestReports".equals(function)) {
                    requestReports(toHandle, responseFor(function, toAppend));
                } else if ("authReportRequest".equals(function)) {
                    authReportRequest(toHandle, responseFor(function, toAppend));
                } else if ("getTestAdminUsers".equals(function)) {
                    getTestAdminUsers(toHandle, responseFor(function, toAppend));
                } else if ("getBottleInv".equals(function)) {
                    getBottleInv(toHandle, responseFor(function, toAppend));
                } else if ("getInventoryDates".equals(function)) {
                    getInventoryDates(toHandle, responseFor(function, toAppend));
                } else if ("getEventDates".equals(function)) {
                    getEventDates(toHandle, responseFor(function, toAppend));
                } else if ("getSpecialCateredEvent".equals(function)) {
                    getSpecialCateredEvent(toHandle, responseFor(function, toAppend));
                } else if ("getStandUnitCount".equals(function)) {
                    getStandUnitCount(toHandle, responseFor(function, toAppend));
                } else if ("getUnitCount".equals(function)) {
                    getUnitCount(toHandle, responseFor(function, toAppend));
                } else if ("getBottleInventoryData".equals(function)) {
                    getBottleInventoryData(toHandle, responseFor(function, toAppend));
                } else if ("getYesterdayVariance".equals(function)) {
                    getYesterdayVariance(toHandle, responseFor(function, toAppend));
                } else if ("getLocationLogs".equals(function)) {
                    getLocationLogs(toHandle, responseFor(function, toAppend));
                } else if ("datedLocationLogs".equals(function)) {
                    datedLocationLogs(toHandle, responseFor(function, toAppend));
                } else if ("getLogCategory".equals(function)) {
                    getLogCategory(toHandle, responseFor(function, toAppend));
                } else if ("getCustomerPoints".equals(function)) {
                    getCustomerPoints(toHandle, responseFor(function, toAppend));
                } else if ("getCustomerVariance".equals(function)) {
                    getCustomerVariance(toHandle, responseFor(function, toAppend));
                } else if ("getUserLocations".equals(function)) {
                    getUserLocations(toHandle, responseFor(function, toAppend));
                } else if ("getUserInfo".equals(function)) {
                    getUserInfo(toHandle, responseFor(function, toAppend));
                } else if ("getConcessionProductMap".equals(function)) {
                    getConcessionProductMap(toHandle, responseFor(function, toAppend));
                } else if ("getEmailReportMaster".equals(function)) {
                    getEmailReportMaster(toHandle, responseFor(function, toAppend));
                } else if ("getEmailReportComponents".equals(function)) {
                    getEmailReportComponents(toHandle, responseFor(function, toAppend));
                } else if ("getEmailReportComponentsMap".equals(function)) {
                    getEmailReportComponentsMap(toHandle, responseFor(function, toAppend));
                } else if ("getEmailTimeTable".equals(function)) {
                    getEmailTimeTable(toHandle, responseFor(function, toAppend));
                } else if ("getEmailReportDurations".equals(function)) {
                    getEmailReportDurations(toHandle, responseFor(function, toAppend));
                } else if ("getEmailReportLogtype".equals(function)) {
                    getEmailReportLogtype(toHandle, responseFor(function, toAppend));
                } else if ("getGrouping".equals(function)) {
                    getGrouping(toHandle, responseFor(function, toAppend));
                } else if ("getProductGrouping".equals(function)) {
                    getProductGrouping(toHandle, responseFor(function, toAppend));
                } else if ("getGroupingForGroup".equals(function)) {
                    getGroupingForGroup(toHandle, responseFor(function, toAppend));
                } else if ("getEmailReportLogs".equals(function)) {
                    getEmailReportLogs(toHandle, responseFor(function, toAppend));
                } else if ("copyTestBeverage".equals(function)) {
                    copyTestBeverage(toHandle, responseFor(function, toAppend));
                } else if ("sendOpenTicket".equals(function)) {
                    sendOpenTicket(toHandle, responseFor(function, toAppend));
                } else if ("checkProductVersion".equals(function)) {
                    checkProductVersion(toHandle, responseFor(function, toAppend));
                } else if ("getUnApprovedProducts".equals(function)) {
                    getUnApprovedProducts(toHandle, responseFor(function, toAppend));
                } else if ("getInventoryPrices".equals(function)) {
                    getInventoryPrices(toHandle, responseFor(function, toAppend));
                } else if ("sendNotificationToUser".equals(function)) {
                    sendNotificationToUser(toHandle, responseFor(function, toAppend));
                } else if ("sendUnApprovedProductsEmail".equals(function)) {
                    sendUnApprovedProductsEmail(toHandle, responseFor(function, toAppend));
                } else if ("getForgotUsername".equals(function)) {
                    getForgotUsername(toHandle, responseFor(function, toAppend));
                } else if ("getPurchaseSetting".equals(function)) {
                    getPurchaseSetting(toHandle, responseFor(function, toAppend));
                } else if ("getCurrentProducts".equals(function)) {
                    getCurrentProducts(toHandle, responseFor(function, toAppend));
                } else if ("getInsiderPass".equals(function)) {
                    getInsiderPass(toHandle, responseFor(function, toAppend));
                } else if ("getBBTVAutoFeed".equals(function)) {
                    getBBTVAutoFeed(toHandle, responseFor(function, toAppend));
                } else if ("getBBTVMenuTemplate".equals(function)) {
                    getBBTVMenuTemplate(toHandle, responseFor(function, toAppend));
                } else if ("getCustomBeerAndStyle".equals(function)) {
                    getCustomBeerAndStyle(toHandle, responseFor(function, toAppend));
                } else if ("getBBTVMenuFormat".equals(function)) {
                    getBBTVMenuFormat(toHandle, responseFor(function, toAppend));
                } else {
                    logger.generalWarning("Unknown function '" + function + "'.");
                }
            } else {
                // access violation
                addErrorDetail(toAppend, "Access violation: This method is not available with your client key");
                logger.portalAccessViolation("Tried to call '" + function + "' with key " + ss.toString());
            }
        } catch (Exception e) {
            if (e instanceof HandlerException) {
                throw (HandlerException) e;
            } else {
                logger.midwareError("Non-handler exception thrown in ReportHandler: " + e.toString());
                logger.midwareError("XML: " + toHandle.asXML());
                throw new HandlerException(e);
            }
        } finally {
            // Log report database use
            int queryCount = transconn.getQueryCount();
            logger.dbAction("Executed " + queryCount + " transactional quer" + (queryCount == 1 ? "y" : "ies"));

            transconn.close();
        }
        logger.xml("response: " + toAppend.asXML());
    }

    private Element responseFor(String s, Element e) {
        String responseNamespace = (String) SOAPMessage.getURIMap().get("tkmsg");
        return e.addElement("m:" + s + "Response", responseNamespace);
    }

    private String nullToEmpty(String s) {
        return (null == s) ? "" : s;
    }

    private void close(Statement s) {
        if (s != null) {
            try {
                s.close();
            } catch (SQLException sqle) {
            }
        }
    }

    private void close(ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException sqle) {
            }
        }
    }

    private void close(Connection c) {
        if (c != null) {
            try {
                c.close();
            } catch (SQLException sqle) {
            }
        }
    }

    private void close(RegisteredConnection c) {
        c.close();
    }

    private void addErrorDetail(Element toAppend, String message) {
        toAppend.addElement("error").addElement("detail").addText(message);
    }

    private int getCallerId(Element toHandle) throws HandlerException {
        return HandlerUtils.getRequiredInteger(HandlerUtils.getRequiredElement(toHandle, "caller"), "callerId");
    }

    private boolean checkForeignKey(String table, int value) throws SQLException, HandlerException {
        return checkForeignKey(table, "id", value);
    }

    private boolean checkForeignKey(String table, String field, int value) throws SQLException, HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;
        boolean result = false;

        String select = "SELECT " + field + " FROM " + table +
                " WHERE " + field + " = ?";

        stmt = transconn.prepareStatement(select);
        stmt.setInt(1, value);
        rs = stmt.executeQuery();


        result = rs.next();

        close(rs);
        close(stmt);
        return result;
    }

    private void getCustomerXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element customerEl                  = toAppend.addElement("customer");
            customerEl.addElement("customerId").addText(String.valueOf(rs.getInt(1)));
            customerEl.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            customerEl.addElement("acctNum").addText(String.valueOf(rs.getInt(3)));
            customerEl.addElement("cType").addText(String.valueOf(rs.getInt(4)));
        }

    }

    private void getCustomers(Element toHandle, Element toAppend) throws HandlerException {

        int customerId                      = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int userId                          = HandlerUtils.getOptionalInteger(toHandle, "userId");
        String name                         = HandlerUtils.getOptionalString(toHandle, "customerName");
        int acctNum                         = HandlerUtils.getOptionalInteger(toHandle, "accountNumber");
        int type                            = HandlerUtils.getOptionalInteger(toHandle, "type");

        int paramsSet = 0;
        if (customerId >= 0) {
            paramsSet++;
        }
        if (null != name) {
            paramsSet++;
        }
        if (acctNum >= 0) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getCustomers.");
        }

        String typeString = "";
        if (type > 0) {
            typeString                      = " AND type = ?";
        }
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            if (customerId >= 0) {
                String selectById           = "SELECT id, name, acctNum, type FROM customer WHERE isActive = 1 AND id=?" + typeString;
                stmt                        = transconn.prepareStatement(selectById);
                stmt.setInt(1, customerId);
                if (type > 0) {
                    stmt.setInt(2, type);
                }
                rs                          = stmt.executeQuery();
                getCustomerXML(toAppend, rs);
            } else if (userId >= 0) {
                int groupId                 = -1;
                String selectUserDetails    = "SELECT isManager, groupId FROM user WHERE id = ?";
                stmt                        = transconn.prepareStatement(selectUserDetails);
                stmt.setInt(1, userId);
                rs                          = stmt.executeQuery();
                if (rs.next() && (rs.getInt(1) == 1)) {
                    groupId                 = rs.getInt(2);
                }

                String selectById           = "SELECT c.id, c.name, c.acctNum, c.type FROM customer c WHERE c.isActive = 1 AND c.groupId=? " + typeString;
                stmt                        = transconn.prepareStatement(selectById);
                stmt.setInt(1, groupId);
                if (type > 0) {
                    stmt.setInt(2, type);
                }
                rs                          = stmt.executeQuery();
                getCustomerXML(toAppend, rs);
            } else if (null != name) {
                String selectByName         = "SELECT id, name, acctNum, type FROM customer WHERE isActive = 1 AND name LIKE = ?" + typeString;
                stmt                        = transconn.prepareStatement(selectByName);
                String subName              = '%' + name + '%';
                stmt.setString(1, subName);
                if (type > 0) {
                    stmt.setInt(2, type);
                }
                rs                          = stmt.executeQuery();
                getCustomerXML(toAppend, rs);
            } else if (acctNum >= 0) {
                String selectByAcctNum      = "SELECT id, name, acctNum, type FROM customer WHERE isActive = 1 AND  acctNum=?" + typeString;
                stmt                        = transconn.prepareStatement(selectByAcctNum);
                stmt.setInt(1, acctNum);
                if (type > 0) {
                    stmt.setInt(2, type);
                }
                rs                          = stmt.executeQuery();
                getCustomerXML(toAppend, rs);
            } else {
                String selectAll            = "SELECT id, name, acctNum, type FROM customer WHERE isActive = 1 " + typeString;
                stmt                        = transconn.prepareStatement(selectAll);
                if (type > 0) {
                    stmt.setInt(1, type);
                }
                rs                          = stmt.executeQuery();
                getCustomerXML(toAppend, rs);
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getLocationXML(Element toAppend, ResultSet rs) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs1 = null;

        String selectProductType = "SELECT DISTINCT p.pType FROM inventory i" +
                " LEFT JOIN location l ON l.id = i.location LEFT JOIN product p ON p.id = i.product" +
                " WHERE l.id = ? ORDER BY p.pType;";

        while (rs.next()) {
            int colCount = 1;

            Element locationEl = toAppend.addElement("location");
            locationEl.addElement("locationId").addText(String.valueOf(rs.getInt(colCount++)));
            locationEl.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("addressStreet").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("addressCity").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("addressZip").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("addressState").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("customerId").addText(String.valueOf(rs.getInt(colCount++)));
            locationEl.addElement("customerName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("brixMin").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("brixMax").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("lastPoured").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("lastSold").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("pouredAge").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("soldAge").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("picoPowerup").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("picoVersion").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("latitude").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("longitude").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("zoomLevel").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            //NischaySharma_11-Feb-2009_Start: Added new element to the response xml "varianceAlert"
            locationEl.addElement("varianceAlert").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            //NischaySharma_11-Feb-2009_End
            locationEl.addElement("draftLines").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("concept").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("volImpact").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));

            //NischaySharma_26-Feb-2010_Start: Added new element to the response xml "locationType"
            //and "volAdjustment"
            locationEl.addElement("locationType").addText(String.valueOf(rs.getInt(colCount++)));
            locationEl.addElement("volAdjustment").addText(String.valueOf(rs.getInt(colCount++)));            
            //NischaySharma_26-Feb-2010_End

            stmt = transconn.prepareStatement(selectProductType);
            stmt.setInt(1, rs.getInt(1));
            rs1 = stmt.executeQuery();
            Element pType = locationEl.addElement("pType");
            while (rs1.next()) {
                pType.addElement("type").addText(HandlerUtils.nullToEmpty(rs1.getString(1)));
            }

        }

    }

    private void getLocations(Element toHandle, Element toAppend) throws HandlerException {

        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int locationType                    = HandlerUtils.getOptionalInteger(toHandle, "locationType");
        String name                         = HandlerUtils.getOptionalString(toHandle, "locationName");
        String addrStreet                   = HandlerUtils.getOptionalString(toHandle, "addressStreet");
        String addrCity                     = HandlerUtils.getOptionalString(toHandle, "addressCity");
        String addrState                    = HandlerUtils.getOptionalString(toHandle, "addressState");
        String addrZip                      = HandlerUtils.getOptionalString(toHandle, "addressZip");
        int refCustomerId                   = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int groupId                         = HandlerUtils.getOptionalInteger(toHandle, "groupId");
        int refSupplierId                   = HandlerUtils.getOptionalInteger(toHandle, "supplierId");
        int refUserId                       = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int userId                          = HandlerUtils.getOptionalInteger(toHandle, "groupUserId");
        int regionId                        = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        //int countyId                        = HandlerUtils.getOptionalInteger(toHandle, "countyId");
        int easternOffset                   = HandlerUtils.getOptionalInteger(toHandle, "easternOffset");
        boolean bossInformation             = HandlerUtils.getOptionalBoolean(toHandle, "bossInformation");
        boolean dataRights                  = HandlerUtils.getOptionalBoolean(toHandle, "dataRights");

        PreparedStatement stmt              = null;
        ResultSet rs                        = null, locationRS = null;

        boolean addrSearch = null != addrStreet || null != addrCity || null != addrState || null != addrZip;
        int paramsSet                       = 0;
        if (locationId >= 0) {
            paramsSet++;
        }
        if (refCustomerId >= 0) {
            if (locationType < 0) {
                locationType = 1;
            }
            paramsSet++;
        }
        if (refSupplierId >= 0) {
            paramsSet++;
        }
        if (refUserId >= 0) {
            paramsSet++;
        }
        if (userId >= 0) {
            paramsSet++;
        }
        if (easternOffset >= -3) {
            paramsSet++;
        }
        if (dataRights) {
            paramsSet++;
        }
        if (null != name) {
            paramsSet++;
        }
        if (addrSearch) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getLocations.");
        }

        try {
            //NischaySharma_11-Feb_2009_Start: The select query was changed to fetch varianceAlert also
            String select =
                    " SELECT l.id, l.name, " +
                    " l.addrStreet, l.addrCity, l.addrZip, l.addrState, " +
                    " l.customer, c.name, l.brixMin, l.brixMax, " +
                    " l.lastPoured, l.lastSold, " +
                    " TIME_TO_SEC(TIMEDIFF(NOW(),l.lastPoured)) AS pouredAge," +
                    " TIME_TO_SEC(TIMEDIFF(NOW(),l.lastSold)) AS soldAge," +
                    " l.picoPowerup, l.picoVersion, l.easternOffset, " +
                    " l.latitude, l.longitude, l.zoomLevel, l.varianceAlert, " +
                    //NischaySharma_23-Feb-2010_Start: Added new column to fetch "type" and "volAdjustment"
                    //" l.draftLines, l.concept, l.volImpact " +
                    " l.draftLines, l.concept, l.volImpact, l.type, l.volAdjustment " +
                    //NischaySharma_23-Feb-2010_End
                    " FROM customer c LEFT JOIN location l ON c.id=l.customer LEFT JOIN locationDetails lD ON lD.location = l.id ";
            //NischaySharma_11-Feb-2009_End
            if (refSupplierId >= 0) {
                String selectBySupplierId = select +
                        " LEFT JOIN locationSupplier map ON map.location = l.id " +
                        " LEFT JOIN supplierAddress a ON map.address = a.id LEFT JOIN supplier s ON a.supplier=s.id " +
                        " WHERE lD.active = 1 AND s.id = ? " +
                        " ORDER BY l.name ASC";
                stmt = transconn.prepareStatement(selectBySupplierId);
                stmt.setInt(1, refSupplierId);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (refUserId >= 0) {

                String selectUserExclusions = " SELECT e.tables, e.value FROM exclusion e LEFT JOIN userExclusionMap uEM ON uEM.exclusion = e.id WHERE e.type = 2 AND uEM.user = ? ";
                String userLocationExclusions = "0";
                stmt = transconn.prepareStatement(selectUserExclusions);
                stmt.setInt(1, refUserId);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    String selectLocations = " SELECT l.id FROM location l ";
                    if (rs.getString(1).equals("county")) {
                        selectLocations += " LEFT JOIN county c ON c.id = l.countyIndex WHERE c.id = ?";
                    } else if (rs.getString(1).equals("location")) {
                        selectLocations += " WHERE l.id = ? ";
                    }
                    stmt = transconn.prepareStatement(selectLocations);
                    stmt.setInt(1, Integer.valueOf(rs.getString(2)));
                    locationRS = stmt.executeQuery();
                    while (locationRS.next()) {
                        userLocationExclusions += ", " + locationRS.getString(1);
                    }
                }

               int i = 1;
                String selectByUserRegionId = select +
                        " LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                        " LEFT JOIN groupRegionMap gRM ON gRM.regionMaster = rCM.region" +
                        " LEFT JOIN region r ON r.regionGroup = gRM.id" +
                        " LEFT JOIN userRegionMap uRM ON uRM.region = r.id " +
                        " WHERE lD.active = 1 AND lD.data = 1 AND l.id NOT IN (" + userLocationExclusions + ") AND uRM.user = ? ";
              /*  if (userRegionId > 0) {
                    selectByUserRegionId += " AND uRM.region = ? ";
                }
                if (countyId > 0) {
                    selectByUserRegionId += " AND rCM.county = ? ";
                }*/
                stmt = transconn.prepareStatement(selectByUserRegionId);
                stmt.setInt(i++, refUserId);
               /* if (userRegionId > 0) {
                    stmt.setInt(i++, userRegionId);
                }
                if (countyId > 0) {
                    stmt.setInt(i++, countyId);
                }*/
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (refCustomerId >= 0) {
                if (!checkForeignKey("customer", "id", refCustomerId)) {
                    throw new HandlerException("Foreign Key Not found : customer " + refCustomerId);
                }
                String selectByCustomerId = select +
                        " WHERE lD.active = 1 AND l.customer = ? ";
                if(regionId > 0) {
                    selectByCustomerId      += "  AND l.region =  "+String.valueOf(regionId);
                }
                selectByCustomerId          += " ORDER BY l.name ASC";
                
                stmt = transconn.prepareStatement(selectByCustomerId);
                stmt.setInt(1, refCustomerId);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (groupId >= 0) {
                if (!checkForeignKey("groups", "id", groupId)) {
                    throw new HandlerException("Foreign Key Not found : groups " + groupId);
                }
                String selectByGroupId = select +
                        " WHERE lD.active = 1 AND c.groupId = ? ORDER BY c.name, l.name ASC";
                stmt = transconn.prepareStatement(selectByGroupId);
                stmt.setInt(1, groupId);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (userId >= 0) {
                String selectByUserId = select +
                        " LEFT JOIN userMap uM ON uM.location = l.id WHERE lD.active = 1 AND lD.data = 1 AND uM.user = ? ORDER BY l.name ASC";
                stmt = transconn.prepareStatement(selectByUserId);
                stmt.setInt(1, userId);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } /*else if (countyId >= 0) {
                String selectById = select +
                        " WHERE lD.active = 1 AND lD.data = 1 AND l.countyIndex = ? ORDER BY l.name ASC";
                stmt = transconn.prepareStatement(selectById);
                stmt.setInt(1, countyId);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } */else if (locationId >= 0) {
                String selectById = select +
                        " WHERE l.id = ? ";
                stmt = transconn.prepareStatement(selectById);
                stmt.setInt(1, locationId);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (locationType >= 0) {
                String selectByType = select +
                        " WHERE lD.active = 1 AND l.type = ? ORDER BY l.name ASC";
                stmt = transconn.prepareStatement(selectByType);
                stmt.setInt(1, locationType);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            }  else if (dataRights) {
                String selectByDataRights = select +
                        " WHERE lD.active = 1 AND lD.data = 1 ORDER BY l.name ASC";
                stmt = transconn.prepareStatement(selectByDataRights);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (easternOffset >= -3) {
                String selectByType = select +
                        " WHERE lD.active = 1 AND l.easternOffset = ? ORDER BY l.name ASC";
                stmt = transconn.prepareStatement(selectByType);
                stmt.setInt(1, easternOffset);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (null != name) {
                String selectByName = select +
                        " WHERE lD.active = 1 AND l.name LIKE ? ORDER BY l.name ASC";
                stmt = transconn.prepareStatement(selectByName);
                String likeName = "%" + name + "%";
                stmt.setString(1, likeName);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (addrSearch) {
                StringBuffer buf = new StringBuffer(select +
                        " WHERE lD.active = 1 AND ");

                // add the necessary address search LIKE expressions
                boolean appended = false;
                if (null != addrStreet) {
                    buf.append(" lD.active = 1 AND l.addrStreet LIKE ?");
                    appended = true;
                }
                if (null != addrCity) {
                    buf.append((appended ? " AND" : "") + " l.addrCity LIKE ?");
                    appended = true;
                }
                if (null != addrState) {
                    buf.append((appended ? " AND" : "") + " l.addrState LIKE ?");
                    appended = true;
                }
                if (null != addrZip) {
                    buf.append((appended ? " AND" : "") + " l.addrZip LIKE ?");
                    appended = true;
                }

                // use the setString method for correct database quoting
                stmt = transconn.prepareStatement(buf.toString());
                stmt.setString(1, name);
                int index = 2;
                String like = null;
                if (null != addrStreet) {
                    like = "%" + addrStreet + "%";
                    stmt.setString(index++, like);
                }
                if (null != addrCity) {
                    like = "%" + addrCity + "%";
                    stmt.setString(index++, like);
                }
                if (null != addrState) {
                    like = "%" + addrState + "%";
                    stmt.setString(index++, like);
                }
                if (null != addrZip) {
                    like = "%" + addrZip + "%";
                    stmt.setString(index++, like);
                }

                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else {
                String selectAll = select + " WHERE lD.active = 1 AND c.id > 0 ORDER BY l.name ASC";
                stmt = transconn.prepareStatement(selectAll);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private double getVariance(double poured, double sold) throws HandlerException {
        double variance = 0.00;
        logger.portalAction("getVariance");
        if (poured <= 0.00 && sold <= 0.00) {
            variance = 0.00;
        } else if (poured <= 0.00) {
            variance = 100.00;
        } else {
            variance = ((sold - poured) / poured) * 100;
        }
        return variance;
    }

    private double getPoured(Integer tableId, Integer tableType, String periodStr, String periodDetail, String startTime, String endTime)
            throws HandlerException {

        java.text.DecimalFormat twoDForm = new java.text.DecimalFormat("#.##");
        java.text.DateFormat timeParse = new java.text.SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        double totalPoured = 0.00;

        logger.portalAction("getPoured");

        try {
            java.util.Date start = timeParse.parse(startTime);
            java.util.Date end = timeParse.parse(endTime);

            PeriodType periodType = PeriodType.parseString(periodStr);
            if (null == periodType) {
                throw new HandlerException("Invalid period type: " + periodStr);
            }
            //For Testing purposes change the below date.
            //start = timeParse.parse("2009-06-09 08:00:00");
            //end = timeParse.parse("2009-06-10 08:00:00");
            ReportPeriod period = null;
            try {
                period = new ReportPeriod(periodType, periodDetail, start, end);
            } catch (IllegalArgumentException e) {
                throw new HandlerException(e.getMessage());
            }

            SortedSet<DatePartition> dps = DatePartitionFactory.createPartitions(period);
            //logger.debug("Created partitions: \n"+DatePartitionFactory.partitionReport(dps));
            DatePartitionTree dpt = new DatePartitionTree(dps);

            ReportResults rrs = null;

            switch (tableType) {
                case 2:
                    rrs = ReportResults.getResultsByLocation(period, 0, false, false, tableId, 0, transconn);
                    break;
                case 3:
                    rrs = ReportResults.getResultsByBar(period, 0, false, tableId, 0, transconn);
                    break;
                case 6:
                    rrs = ReportResults.getResultsByBar(period, 0, false, tableId, 0, transconn);
                    break;
                default:
                    break;
            }
            PeriodStructure pss[] = null;
            PeriodStructure ps = null;
            int dpsSize = dps.size();
            int index;
            if (dpsSize > 0) {
                pss = new PeriodStructure[dpsSize];
                //this is a temporary array of the DatePartitions used to construct the PeriodStructures start dates
                Object[] dpa = dps.toArray();
                for (int i = 0; i < dpsSize; i++) {
                    // create a new PeriodStructure and link it to the previous one (or null for the first)
                    ps = new PeriodStructure(ps, ((DatePartition) dpa[i]).getDate());
                    pss[i] = ps;
                }
                int debugCounter = 0;
                while (rrs.next()) {
                    index = dpt.getIndex(rrs.getDate());
                    pss[index].addReading(rrs.getLine(), rrs.getValue(), rrs.getDate(), rrs.getQuantity());
                    debugCounter++;
                    //logger.debug("#"+debugCounter+" ["+index+"]: "+"L "+rrs.getLine()+" V: "+rrs.getValue()+" D: "+rrs.getDate().toString());
                }
                rrs.close();
                //logger.debug("Processed " + debugCounter + " readings");
                for (int i = 0; i < dpsSize; i++) {
                    Map<Integer, Double> lineMap = pss[i].getValues(transconn);
                    if (null != lineMap && lineMap.size() > 0) {
                        for (Integer key : lineMap.keySet()) {
                            totalPoured += Double.parseDouble(twoDForm.format(lineMap.get(key)));
                            //logger.debug("For Line : " + key + " poured = " + String.valueOf(lineMap.get(key)));
                        }
                    }
                }
                //logger.debug("Total Poured = " + twoDForm.format(totalPoured));
                ReportResults.clearLineCache();
            }
        } catch (ParseException pe) {
            String badDate = (null == startTime) ? "start" : "end";
            throw new HandlerException("Could not parse " + badDate + " date.");
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
        }
        return totalPoured;
    }

    private double getSold(Integer tableId, Integer tableType, String periodStr, String periodDetail, String startTime, String endTime)
            throws HandlerException {

        java.text.DecimalFormat twoDForm = new java.text.DecimalFormat("#.##");
        java.text.DateFormat timeParse = new java.text.SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
        double totalSold = 0.00;
        int location = 0, bar = 0;
        String selectCostCenter = "SELECT b.location FROM costCenter c LEFT JOIN bar b ON b.id = c.bar WHERE c.bar = ? ";

        // A cache of beverage ingredient sets (maps PLU -> RRecSet)
        Map<String, Set<ReconciliationRecord>> ingredCache = new HashMap<String, Set<ReconciliationRecord>>();

        // Maps product ids to RRecs (oz values);
        Map<Integer, ReconciliationRecord> productSet = new HashMap<Integer, ReconciliationRecord>();

        logger.portalAction("getSold");

        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            java.util.Date start = timeParse.parse(startTime);
            java.util.Date end = timeParse.parse(endTime);

            PeriodType periodType = PeriodType.parseString(periodStr);
            if (null == periodType) {
                throw new HandlerException("Invalid period type: " + periodStr);
            }
            //For Testing purposes change the below date.
            //start = timeParse.parse("2009-06-09 08:00:00");
            //end = timeParse.parse("2009-06-10 08:00:00");
            ReportPeriod period = null;
            try {
                period = new ReportPeriod(periodType, periodDetail, start, end);
            } catch (IllegalArgumentException e) {
                throw new HandlerException(e.getMessage());
            }

            OldSalesResults srs = null;

            switch (tableType) {
                case 2:
                    location = tableId;
                    srs = OldSalesResults.getResultsByLocation(period, location, transconn);
                    break;
                case 3:
                    bar = tableId;
                    stmt = transconn.prepareStatement(selectCostCenter);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        location = rs.getInt(1);
                        srs = OldSalesResults.getResultsByBarCostCenters(period, location, bar, transconn);
                    } else {
                        srs = OldSalesResults.getResultsByBarPlu(period, bar, transconn);
                    }
                    break;
                case 6:
                    bar = tableId;
                    stmt = transconn.prepareStatement(selectCostCenter);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        location = rs.getInt(1);
                        srs = OldSalesResults.getResultsByBarCostCenters(period, location, bar, transconn);
                    } else {
                        srs = OldSalesResults.getResultsByBarPlu(period, bar, transconn);
                    }
                    break;
                default:
                    break;
            }
            int totalRecords = 0;
            while (srs.next()) {
                String product = srs.getPlu();
                double value = srs.getValue();

                Set<ReconciliationRecord> baseSet = null;
                if (ingredCache.containsKey(product)) {
                    baseSet = ingredCache.get(product);
                } else { // we need to do a db lookup and add the ingredients to the cache
                    baseSet = ReconciliationRecord.recordByPlu(product, location, bar, 1.0, transconn);
                    ingredCache.put(product, baseSet);
                }
                Set<ReconciliationRecord> rSet = ReconciliationRecord.recordByBaseSet(baseSet, value);
                totalRecords += rSet.size();
                // loop through all RRs and add them to the product set.
                for (ReconciliationRecord rr : rSet) {
                    Integer key = new Integer(rr.getProductId());
                    ReconciliationRecord existingRecord = productSet.get(key);
                    if (existingRecord != null) {
                        existingRecord.add(rr);
                    } else {
                        productSet.put(key, rr);
                    }
                }
            }
            //logger.debug("Processed " + totalRecords + " reconciliation record(s)");
            // use the product set to create the XML to return.
            Collection<ReconciliationRecord> recs = productSet.values();
            for (ReconciliationRecord r : recs) {
                totalSold += r.getValue();
            }
            //logger.debug("Total Sold = " + twoDForm.format(totalSold));
        } catch (ParseException pe) {
            String badDate = (null == startTime) ? "start" : "end";
            throw new HandlerException("Could not parse " + badDate + " date.");
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
        return totalSold;
    }

    private void getLocationHours(Element toHandle, Element toAppend) throws HandlerException {

        PeriodShiftType periodShift = PeriodShiftType.instanceOf(HandlerUtils.getRequiredString(toHandle, "periodShift"));
        String businessDateString = HandlerUtils.getRequiredString(toHandle, "businessDate");
        int periodType = periodShift.toSQLQueryInt();

        logger.debug(String.valueOf(periodType));
        switch (periodType) {
            case 0:
                getBusinessHours(toHandle, toAppend, businessDateString);
                break;
            case 1:
                getPreOpenHours(toHandle, toAppend, businessDateString);
                break;
            case 2:
                getOpenHours(toHandle, toAppend, businessDateString);
                break;
            case 3:
                getAfterHours(toHandle, toAppend, businessDateString);
                break;
            case 4:
                getBevSyncHours(toHandle, toAppend, businessDateString);
                break;
        }

    }

    private void getBusinessHours(Element toHandle, Element toAppend, String businessDateString) throws HandlerException {

        int locationId                      = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String selectBusinessHours          = "SELECT " +
                                            " DATE_SUB(Concat(LEFT(?,11), ' ',IFNULL(x.preOpen1,'07:00:00')), INTERVAL eO HOUR) preOpen1, " +
                                            " DATE_SUB(Concat(LEFT(adddate(?,1),11), ' ',IFNULL(x.preOpen2,'07:00:00')), INTERVAL eO HOUR) preOpen2, eO FROM " +
                                            " (SELECT CASE DAYOFWEEK(?) " +
                                            " WHEN 1 THEN Right(lH.preOpenSun,8) " +
                                            " WHEN 2 THEN Right(lH.preOpenMon,8) " +
                                            " WHEN 3 THEN Right(lH.preOpenTue,8) " +
                                            " WHEN 4 THEN Right(lH.preOpenWed,8) " +
                                            " WHEN 5 THEN Right(lH.preOpenThu,8) " +
                                            " WHEN 6 THEN Right(lH.preOpenFri,8) " +
                                            " WHEN 7 THEN Right(lH.preOpenSat,8) END preOpen1, " +
                                            " CASE DAYOFWEEK(adddate(?,1)) " +
                                            " WHEN 1 THEN Right(lH.preOpenSun,8) " +
                                            " WHEN 2 THEN Right(lH.preOpenMon,8) " +
                                            " WHEN 3 THEN Right(lH.preOpenTue,8) " +
                                            " WHEN 4 THEN Right(lH.preOpenWed,8) " +
                                            " WHEN 5 THEN Right(lH.preOpenThu,8) " +
                                            " WHEN 6 THEN Right(lH.preOpenFri,8) " +
                                            " WHEN 7 THEN Right(lH.preOpenSat,8) END preOpen2, " +
                                            " l.easternOffset eO " +
                                            " FROM locationHours lH RIGHT JOIN location l ON lH.location=l.id " +
                                            " WHERE l.id = ?) AS x;";

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        logger.portalAction("getBusinessHours");

        try {
            stmt                            = transconn.prepareStatement(selectBusinessHours);
            stmt.setString(1, businessDateString);
            stmt.setString(2, businessDateString);
            stmt.setString(3, businessDateString);
            stmt.setString(4, businessDateString);
            stmt.setInt(5, locationId);
            rs                              = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("offset").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getPreOpenHours(Element toHandle, Element toAppend, String businessDateString) throws HandlerException {

        int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");


        String selectAfterHours = "SELECT " +
                "DATE_SUB(Concat(LEFT(?,11),IFNULL(x.preOpen,'07:00:00')), INTERVAL eO HOUR) preOpen, " +
                "DATE_SUB(Concat(LEFT(?,11),IFNULL(x.open,'11:00:00')), INTERVAL eO HOUR) Open, eO FROM " +
                "(Select CASE DAYOFWEEK(?) " +
                "WHEN 1 THEN Right(lH.preOpenSun,8) " +
                "WHEN 2 THEN Right(lH.preOpenMon,8) " +
                "WHEN 3 THEN Right(lH.preOpenTue,8) " +
                "WHEN 4 THEN Right(lH.preOpenWed,8) " +
                "WHEN 5 THEN Right(lH.preOpenThu,8) " +
                "WHEN 6 THEN Right(lH.preOpenFri,8) " +
                "WHEN 7 THEN Right(lH.preOpenSat,8) END preOpen, " +
                "CASE DAYOFWEEK(?) " +
                "WHEN 1 THEN Right(lH.openSun,8) " +
                "WHEN 2 THEN Right(lH.openMon,8) " +
                "WHEN 3 THEN Right(lH.openTue,8) " +
                "WHEN 4 THEN Right(lH.openWed,8) " +
                "WHEN 5 THEN Right(lH.openThu,8) " +
                "WHEN 6 THEN Right(lH.openFri,8) " +
                "WHEN 7 THEN Right(lH.openSat,8) END open, " +
                "l.easternOffset eO " +
                "FROM locationHours lH RIGHT JOIN location l ON lH.location=l.id " +
                "WHERE l.id=?) AS x;";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getPreOpenHours");

        try {

            stmt = transconn.prepareStatement(selectAfterHours);
            stmt.setString(1, businessDateString);
            stmt.setString(2, businessDateString);
            stmt.setString(3, businessDateString);
            stmt.setString(4, businessDateString);
            stmt.setInt(5, locationId);
            rs = stmt.executeQuery();

            if (rs.next()) {
                toAppend.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("offset").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getOpenHours(Element toHandle, Element toAppend, String businessDateString) throws HandlerException {


        String selectOpenHours = "SELECT " +
                " DATE_SUB(Concat(LEFT(?,11),IFNULL(x.open,'11:00:00')), INTERVAL eO HOUR) Open, " +
                " DATE_SUB(If(x.close>'12:0:0',concat(LEFT(?,11),IFNULL(x.close,'02:00:00')),concat(LEFT(ADDDATE(?,1),11),IFNULL(x.close,'02:00:00'))), INTERVAL eO HOUR) Close, eO " +
                " FROM (Select CASE DAYOFWEEK(?) " +
                " WHEN 1 THEN Right(lH.openSun,8) " +
                " WHEN 2 THEN Right(lH.openMon,8) " +
                " WHEN 3 THEN Right(lH.openTue,8) " +
                " WHEN 4 THEN Right(lH.openWed,8) " +
                " WHEN 5 THEN Right(lH.openThu,8) " +
                " WHEN 6 THEN Right(lH.openFri,8) " +
                " WHEN 7 THEN Right(lH.openSat,8) END open, " +
                " CASE DAYOFWEEK(?) " +
                " WHEN 1 THEN Right(lH.closeSun,8) " +
                " WHEN 2 THEN Right(lH.closeMon,8) " +
                " WHEN 3 THEN Right(lH.closeTue,8) " +
                " WHEN 4 THEN Right(lH.closeWed,8) " +
                " WHEN 5 THEN Right(lH.closeThu,8) " +
                " WHEN 6 THEN Right(lH.closeFri,8) " +
                " WHEN 7 THEN Right(lH.closeSat,8) END close, " +
                " l.easternOffset eO " +
                " FROM locationHours lH RIGHT JOIN location l ON lH.location=l.id " +
                " WHERE l.id=?) AS x; ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("selectOpenHours");

        try {

            int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");


            //Check that this product doesn't already exist in inventory at this location
            stmt = transconn.prepareStatement(selectOpenHours);
            stmt.setString(1, businessDateString);
            stmt.setString(2, businessDateString);
            stmt.setString(3, businessDateString);
            stmt.setString(4, businessDateString);
            stmt.setString(5, businessDateString);
            stmt.setInt(6, locationId);
            rs = stmt.executeQuery();

            if (rs.next()) {
                toAppend.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("offset").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getAfterHours(Element toHandle, Element toAppend, String businessDateString) throws HandlerException {

        String selectAfterHours = "SELECT " +
                "DATE_SUB(If(x.close>'12:0:0',concat(LEFT(?,11),IFNULL(x.close,'02:00:00')),concat(left(adddate(?,1),11),IFNULL(x.close,'02:00:00'))), INTERVAL eO HOUR) Close, " +
                "DATE_SUB(Concat(LEFT(adddate(?,1),11),IFNULL(x.preOpen,'07:00:00')), INTERVAL eO HOUR) PreOpen, eO FROM " +
                "(Select CASE DAYOFWEEK(?) " +
                "WHEN 1 THEN Right(lH.closeSun,8) " +
                "WHEN 2 THEN Right(lH.closeMon,8) " +
                "WHEN 3 THEN Right(lH.closeTue,8) " +
                "WHEN 4 THEN Right(lH.closeWed,8) " +
                "WHEN 5 THEN Right(lH.closeThu,8) " +
                "WHEN 6 THEN Right(lH.closeFri,8) " +
                "WHEN 7 THEN Right(lH.closeSat,8) END close, " +
                "CASE DAYOFWEEK(adddate(?,1)) " +
                "WHEN 1 THEN Right(lH.preOpenSun,8) " +
                "WHEN 2 THEN Right(lH.preOpenMon,8) " +
                "WHEN 3 THEN Right(lH.preOpenTue,8) " +
                "WHEN 4 THEN Right(lH.preOpenWed,8) " +
                "WHEN 5 THEN Right(lH.preOpenThu,8) " +
                "WHEN 6 THEN Right(lH.preOpenFri,8) " +
                "WHEN 7 THEN Right(lH.preOpenSat,8) END preOpen, " +
                "l.easternOffset eO " +
                "FROM locationHours lH RIGHT JOIN location l ON lH.location=l.id " +
                "WHERE l.id=?) AS x;";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getAfterHours");

        try {
            int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");
            //Check that this product doesn't already exist in inventory at this location
            stmt = transconn.prepareStatement(selectAfterHours);
            stmt.setString(1, businessDateString);
            stmt.setString(2, businessDateString);
            stmt.setString(3, businessDateString);
            stmt.setString(4, businessDateString);
            stmt.setString(5, businessDateString);
            stmt.setInt(6, locationId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("offset").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    private void getBevSyncHours(Element toHandle, Element toAppend, String businessDateString) throws HandlerException {


        String selectBevSyncHours = "SELECT SUBDATE(CONCAT(LEFT(?,11),' ',IFNULL(x.open,'11:00:00')), INTERVAL x.eO HOUR) Open, " +
                " SUBDATE(CONCAT(LEFT(ADDDATE(?,INTERVAL 1 DAY),11),' ',IFNULL(x.preOpen,'05:00:00')), INTERVAL x.eO HOUR) PreOpen, eO " +
                " FROM " +
                " (SELECT " +
                " CASE DAYOFWEEK(?) " +
                " WHEN 1 THEN Right(lH.openSun,8) " +
                " WHEN 2 THEN Right(lH.openMon,8) " +
                " WHEN 3 THEN Right(lH.openTue,8) " +
                " WHEN 4 THEN Right(lH.openWed,8) " +
                " WHEN 5 THEN Right(lH.openThu,8) " +
                " WHEN 6 THEN Right(lH.openFri,8) " +
                " WHEN 7 THEN Right(lH.openSat,8) END open, " +
                " CASE DAYOFWEEK(ADDDATE(?,INTERVAL 1 DAY)) " +
                " WHEN 1 THEN Right(lH.preOpenSun,8) " +
                " WHEN 2 THEN Right(lH.preOpenMon,8) " +
                " WHEN 3 THEN Right(lH.preOpenTue,8) " +
                " WHEN 4 THEN Right(lH.preOpenWed,8) " +
                " WHEN 5 THEN Right(lH.preOpenThu,8) " +
                " WHEN 6 THEN Right(lH.preOpenFri,8) " +
                " WHEN 7 THEN Right(lH.preOpenSat,8) END preOpen, " +
                " l.easternOffset eO " +
                " FROM location l LEFT JOIN locationHours lH ON lH.location=l.id " +
                " WHERE l.id=? ) AS x ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("selectBevSyncHours");

        try {

            int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");


            //Check that this product doesn't already exist in inventory at this location
            stmt = transconn.prepareStatement(selectBevSyncHours);
            stmt.setString(1, businessDateString);
            stmt.setString(2, businessDateString);
            stmt.setString(3, businessDateString);
            stmt.setString(4, businessDateString);
            stmt.setInt(5, locationId);
            rs = stmt.executeQuery();

            if (rs.next()) {
                toAppend.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("offset").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /** RETIRED
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void getDailySupplierReports(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = " SELECT dailyInvReport, dailyBrandReport FROM emailReports WHERE user=? and supplier=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getDailySupplierReports");

        try {
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int supplierId = HandlerUtils.getRequiredInteger(toHandle, "supplierId");

            stmt =
                    transconn.prepareStatement(select);
            stmt.setInt(1, userId);
            stmt.setInt(2, supplierId);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("dailyInventoryReport").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("dailyBrandReport").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /** RETIRED
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void getWeeklySupplierReports(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = " SELECT weeklyBrandReport, weeklyCategoryReport FROM emailReports WHERE user=? and supplier=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getWeeklySupplierReports");

        try {
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int supplierId = HandlerUtils.getRequiredInteger(toHandle, "supplierId");

            stmt =
                    transconn.prepareStatement(select);
            stmt.setInt(1, userId);
            stmt.setInt(2, supplierId);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("weeklyBrandReport").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("weeklyCategoryReport").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getCountyPoints(Element toHandle, Element toAppend) throws HandlerException {

        int countyId = HandlerUtils.getRequiredInteger(toHandle, "countyId");
        int stateId = HandlerUtils.getRequiredInteger(toHandle, "stateId");

        PreparedStatement stmt = null;
        ResultSet zipRS = null;
        ResultSet rs = null;

        try {
            Element countyEl = toAppend.addElement("countyPoints");

            String selectZipList = " SELECT z.id, z.zip, z.zipname, AsText(z.polpnt), AsText(z.swpoint), AsText(z.nepoint) FROM zipList z " +
                    " WHERE z.pointZip = 0 AND z.county = ? AND z.fipsst = ?";
            stmt =
                    transconn.prepareStatement(selectZipList);
            stmt.setInt(1, countyId);
            stmt.setInt(2, stateId);
            zipRS =
                    stmt.executeQuery();
            while (zipRS.next()) {
                Element zipEl = countyEl.addElement("zip");
                zipEl.addElement("id").addText(String.valueOf(zipRS.getInt(1)));
                zipEl.addElement("zipId").addText(String.valueOf(zipRS.getInt(2)));
                zipEl.addElement("zipName").addText(HandlerUtils.nullToEmpty(zipRS.getString(3)));
                zipEl.addElement("zipCenterPoint").addText(HandlerUtils.nullToEmpty(zipRS.getString(4)));
                zipEl.addElement("zipSWPoint").addText(HandlerUtils.nullToEmpty(zipRS.getString(5)));
                zipEl.addElement("zipNEPoint").addText(HandlerUtils.nullToEmpty(zipRS.getString(6)));

                logger.debug("ZipCode Packaging for " + String.valueOf(zipRS.getInt(2)));

                String selectZipPoints = " SELECT zPoints.idgeoz, zPoints.extring, zPoints.hasintring, Replace(AsText(poly), 'POLYGON', '') FROM zipPoints zPoints " +
                        " WHERE zPoints.ZIP = ? AND zPoints.IDGEOZ IS NOT NULL ORDER BY zPoints.IDGEOZ ";
                stmt =
                        transconn.prepareStatement(selectZipPoints);
                stmt.setInt(1, zipRS.getInt(2));
                rs =
                        stmt.executeQuery();
                while (rs.next()) {
                    Element zipPointsEL = zipEl.addElement("zipPoints");
                    zipPointsEL.addElement("id").addText(String.valueOf(rs.getInt(1)));
                    zipPointsEL.addElement("extring").addText(String.valueOf(rs.getInt(2)));
                    zipPointsEL.addElement("hasintring").addText(String.valueOf(rs.getInt(3)));
                    zipPointsEL.addElement("points").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                }

            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getCounties(Element toHandle, Element toAppend) throws HandlerException {

        int refStateId = HandlerUtils.getOptionalInteger(toHandle, "stateId");
        int refRegionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int refUserRegionId = HandlerUtils.getOptionalInteger(toHandle, "userRegionId");
        int refCountyId = HandlerUtils.getOptionalInteger(toHandle, "countyId");

        boolean getCoords = HandlerUtils.getOptionalBoolean(toHandle, "getCoords");
        boolean getLocations = HandlerUtils.getOptionalBoolean(toHandle, "getLocations");

        PreparedStatement stmt = null;
        ResultSet countyRS = null;
        ResultSet locationRS = null;
        ResultSet rs = null;

        int paramsSet = 0;

        String selectCounty = " SELECT c.id, c.state, c.county, CONCAT(c.name,' - ',s.USPSST), Replace(AsText(c.points), 'POLYGON', '') FROM county c LEFT JOIN state s ON s.FIPSST = c.state ";

        if (refStateId >= 0) {
            selectCounty += " WHERE c.state = ? ";
            paramsSet++;

        }
        if (refRegionId >= 0) {
            selectCounty += " LEFT JOIN regionCountyMap rCM ON rCM.county = c.id WHERE rCM.region = ? ";
            paramsSet++;

        }
        if (refUserRegionId >= 0) {
            selectCounty += " LEFT JOIN regionCountyMap rCM ON rCM.county = c.id LEFT JOIN groupRegionMap gRM ON gRM.regionMaster = rCM.region LEFT JOIN region r ON r.regionGroup = gRM.id WHERE r.id = ? ";
            paramsSet++;

        }
        if (refCountyId >= 0) {
            selectCounty += " WHERE c.id = ? ";
            paramsSet++;

        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getCounties");
        }

        try {

            stmt = transconn.prepareStatement(selectCounty);
            if (refStateId >= 0) {
                stmt.setInt(1, refStateId);
            } else if (refRegionId >= 0) {
                stmt.setInt(1, refRegionId);
            } else if (refUserRegionId >= 0) {
                stmt.setInt(1, refUserRegionId);
            } else if (refCountyId >= 0) {
                stmt.setInt(1, refCountyId);
            }
            countyRS = stmt.executeQuery();
            while (countyRS.next()) {
                String locationString = "";
                Element countyEl = toAppend.addElement("county");
                countyEl.addElement("id").addText(String.valueOf(countyRS.getInt(1)));
                countyEl.addElement("state").addText(String.valueOf(countyRS.getInt(2)));
                countyEl.addElement("countyId").addText(String.valueOf(countyRS.getInt(3)));
                countyEl.addElement("countyName").addText(HandlerUtils.nullToEmpty(countyRS.getString(4)));
                if (getCoords) {
                    countyEl.addElement("countyPoints").addText(HandlerUtils.nullToEmpty(countyRS.getString(5)));
                }
                if (getLocations) {
                    int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");

                    String selectUserExclusions = " SELECT e.tables, e.value FROM exclusion e LEFT JOIN userExclusionMap uEM ON uEM.exclusion = e.id WHERE e.type = 2 AND uEM.user = ? ";
                    String userLocationExclusions = "0";
                    stmt = transconn.prepareStatement(selectUserExclusions);
                    stmt.setInt(1, userId);
                    rs = stmt.executeQuery();
                    while (rs.next()) {
                        String selectLocations = " SELECT l.id FROM location l ";
                        if (rs.getString(1).equals("county")) {
                            selectLocations += " LEFT JOIN county c ON c.id = l.countyIndex WHERE c.id = ?";
                        } else if (rs.getString(1).equals("location")) {
                            selectLocations += " WHERE l.id = ? ";
                        }
                        stmt = transconn.prepareStatement(selectLocations);
                        stmt.setInt(1, Integer.valueOf(rs.getString(2)));
                        locationRS = stmt.executeQuery();
                        while (locationRS.next()) {
                            userLocationExclusions += ", " + locationRS.getString(1);
                        }
                    }
                    //logger.debug(userLocationExclusions);
                    String selectCountyLocations = " SELECT id FROM location WHERE id NOT IN (" + userLocationExclusions + ") AND countyIndex = ? ";
                    stmt = transconn.prepareStatement(selectCountyLocations);
                    stmt.setInt(1, countyRS.getInt(1));
                    rs = stmt.executeQuery();
                    while (rs.next()) {
                        locationString = locationString + String.valueOf(rs.getInt(1));
                        if (!rs.isLast()) {
                            locationString = locationString + ", ";
                        }
                    }
                    countyEl.addElement("locations").addText(HandlerUtils.nullToEmpty(locationString));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getRegions(Element toHandle, Element toAppend) throws HandlerException {

        int refUserId = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int refRegionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");

        boolean getCoords = HandlerUtils.getOptionalBoolean(toHandle, "getCoords");
        boolean getProducts = HandlerUtils.getOptionalBoolean(toHandle, "getProducts");

        String selectRegion = " SELECT r.id, r.name, r.regionGroup, r.threshold, Replace(AsText(r.points), 'POLYGON', ''), " +
                " GROUP_CONCAT(DISTINCT pSM.product ORDER BY pSM.product SEPARATOR ', ')" +
                " FROM region r" +
                " LEFT JOIN regionProductSet rPS ON rPS.region = r.id" +
                " LEFT JOIN productSetMap pSM ON pSM.productSet = rPS.productSet" +
                " LEFT JOIN userRegionMap uRM ON uRM.region = r.id ";

        int paramsSet = 0;

        if (refUserId >= 0) {
            selectRegion += " WHERE uRM.user = ? ";
            paramsSet++;

        } else if (refRegionId >= 0) {
            selectRegion += " WHERE r.id = ? ";
            paramsSet++;

        }

        selectRegion += " GROUP BY r.id ORDER BY r.name ";

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getRegions.");
        }

        PreparedStatement stmt = null;
        ResultSet regionRS = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(selectRegion);
            if (refUserId >= 0) {
                stmt.setInt(1, refUserId);
            } else if (refRegionId >= 0) {
                stmt.setInt(1, refRegionId);
            }

            regionRS = stmt.executeQuery();

            while (regionRS.next()) {
                Element regionEl = toAppend.addElement("region");
                regionEl.addElement("regionId").addText(String.valueOf(regionRS.getInt(1)));
                regionEl.addElement("regionName").addText(HandlerUtils.nullToEmpty(regionRS.getString(2)));
                regionEl.addElement("regionGroup").addText(String.valueOf(regionRS.getInt(3)));
                regionEl.addElement("threshold").addText(String.valueOf(regionRS.getString(4)));
                if (getCoords) {
                    regionEl.addElement("regionPoints").addText(HandlerUtils.nullToEmpty(regionRS.getString(5)));
                }

                if (getProducts) {
                    regionEl.addElement("productList").addText(HandlerUtils.nullToEmpty(regionRS.getString(6)));
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getSystemsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element SystemEl = toAppend.addElement("system");

            SystemEl.addElement("systemId").addText(String.valueOf(rs.getInt(1)));
            SystemEl.addElement("locationId").addText(String.valueOf(rs.getInt(2)));
            SystemEl.addElement("line").addText(String.valueOf(rs.getInt(3)));
        }

    }

    private void getSystems(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "systemId");
        int refLocationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");

        int paramsSet = 0;
        if (id >= 0) {
            paramsSet++;
        }

        if (refLocationId >= 0) {
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getSystems.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " +
                            refLocationId);
                }

                String selectByLocationId = "SELECT id, location, lines " +
                        "FROM system WHERE location = ?";
                stmt =
                        transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                rs =
                        stmt.executeQuery();

                getSystemsXML(toAppend, rs);
            } else if (id >= 0) {
                String selectById = "SELECT id, location, lines FROM system " +
                        "WHERE id = ?";
                stmt =
                        transconn.prepareStatement(selectById);
                stmt.setInt(1, id);
                rs =
                        stmt.executeQuery();

                getSystemsXML(toAppend, rs);
            } else {
                String selectAll = "SELECT id, location, lines FROM system";
                stmt =
                        transconn.prepareStatement(selectAll);
                rs =
                        stmt.executeQuery();
                getSystemsXML(toAppend, rs);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
//    private void getSuppliersXML(Element toAppend, ResultSet rs) throws SQLException {
//        while(rs.next()) {
//            Element sEl = toAppend.addElement("supplier");
//            
//            sEl.addElement("id").addText(String.valueOf(rs.getInt(1)));
//            sEl.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
//            sEl.addElement("addrStreet").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
//            sEl.addElement("addrCity").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
//            sEl.addElement("addrState").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
//            sEl.addElement("addrZip").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
//        }
//        
//    }

    /**  Get a list of all suppliers and their associated addresses
     *  args:
     *  <supplierId> OPTIONAL return only addresses from this supplier
     *              If omitted, all suppliers will be returned
     *  <showInactive> OPTIONAL default 0.  If positive, inactive addresses will be included 
     *
     *  return structure:
     *  <supplier>
     *    <supplierId>0000
     *    <supplierName>Name
     *    <address>
     *      <addressId>000
     *      <street>String
     *      <city>String
     *      <state>XX
     *      <zip>10000
     *    </address>
     *    <address ... />
     *  </supplier>
     *  <supplier .. />
     */
    private void getSuppliers(Element toHandle, Element toAppend) throws HandlerException {

        int showInactive = HandlerUtils.getOptionalInteger(toHandle, "showInactive");
        int supplierFilter = HandlerUtils.getOptionalInteger(toHandle, "supplierId");

        String getSuppliers =
                " SELECT id,name FROM supplier " + (supplierFilter > 0 ? "WHERE id=?" : "");
        String getAddresses =
                " SELECT id,addrStreet,addrCity,addrState,addrZip,active " +
                " FROM supplierAddress WHERE supplier=? " + (showInactive <= 0 ? "AND active=1" : "");

        PreparedStatement stmt = null;
        PreparedStatement addrStmt = null;
        ResultSet sups = null;
        ResultSet addrs = null;

        try {
            addrStmt = transconn.prepareStatement(getAddresses);
            stmt =
                    transconn.prepareStatement(getSuppliers);
            if (supplierFilter > 0) {
                stmt.setInt(1, supplierFilter);
            }

            sups = stmt.executeQuery();
            while (sups.next()) {
                Element supEl = toAppend.addElement("supplier");
                int supplierId = sups.getInt(1);
                String supplierName = sups.getString(2);
                supEl.addElement("supplierId").addText(String.valueOf(supplierId));
                supEl.addElement("supplierName").addText(String.valueOf(supplierName));
                addrStmt.setInt(1, supplierId);
                addrs =
                        addrStmt.executeQuery();
                while (addrs.next()) {
                    Element addrEl = supEl.addElement("address");
                    addrEl.addElement("addressId").addText(String.valueOf(addrs.getInt(1)));
                    addrEl.addElement("street").addText(String.valueOf(addrs.getString(2)));
                    addrEl.addElement("city").addText(String.valueOf(addrs.getString(3)));
                    addrEl.addElement("state").addText(String.valueOf(addrs.getString(4)));
                    addrEl.addElement("zip").addText(String.valueOf(addrs.getString(5)));
                    addrEl.addElement("active").addText(String.valueOf(addrs.getString(6)));
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(sups);
            close(addrs);
            close(stmt);
            close(addrStmt);
        }

    }

    /**  Return a list of all associated suppliers from this location
     */
    private void getLocationSuppliers(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        String select =
                " SELECT s.name, a.active, a.addrStreet, a.addrCity, a.addrState, a.addrZip, s.id, a.id, map.repEmail, map.account " +
                " FROM locationSupplier map LEFT JOIN supplierAddress a ON map.address = a.id" +
                " LEFT JOIN supplier s ON a.supplier=s.id WHERE map.location=? ";
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Element sup = toAppend.addElement("supplier");
                sup.addElement("name").addText(String.valueOf(rs.getString(1)));
                sup.addElement("active").addText(String.valueOf(rs.getInt(2)));
                sup.addElement("addrStreet").addText(String.valueOf(rs.getString(3)));
                sup.addElement("addrCity").addText(String.valueOf(rs.getString(4)));
                sup.addElement("addrState").addText(String.valueOf(rs.getString(5)));
                sup.addElement("addrZip").addText(String.valueOf(rs.getString(6)));
                sup.addElement("supplierId").addText(String.valueOf(rs.getInt(7)));
                sup.addElement("addressId").addText(String.valueOf(rs.getInt(8)));
                sup.addElement("repEmail").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
                sup.addElement("accountId").addText(HandlerUtils.nullToEmpty(rs.getString(10)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationSuppliers: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getBarsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element BarE1 = toAppend.addElement("bar");

            BarE1.addElement("barId").addText(String.valueOf(rs.getInt(1)));
            BarE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            BarE1.addElement("locationId").addText(String.valueOf(rs.getInt(3)));
            BarE1.addElement("zoneId").addText(String.valueOf(rs.getInt(4)));
            //NischaySharma_09-Feb-2009_Start: Added latitude & longitude to the response xml
            BarE1.addElement("latitude").addText(String.valueOf(rs.getDouble(5)));
            BarE1.addElement("longitude").addText(String.valueOf(rs.getDouble(6)));
            //NischaySharma_09-Feb-2009_End
            BarE1.addElement("type").addText(String.valueOf(rs.getInt(7)));
        }

    }

    private void getBars(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int zoneId = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int refLocationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int refCustomerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int refUserId = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");

        int paramsSet = 0;
        if (id >= 0) {
            paramsSet++;
        }

        if (zoneId >= 0) {
            paramsSet++;
        }

        if (refLocationId >= 0) {
            paramsSet++;
        }

        if (refCustomerId >= 0) {
            paramsSet++;
        }

        if (refUserId >= 0) {
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getBars.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " +
                            refLocationId);
                }
//NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
//select statement.

                String selectByLocationId = "SELECT id, name, location, zone, latitude, longitude, type " +
                        "FROM bar WHERE location = ?";
                //NischaySharma_09-Feb-2009_End
                stmt =
                        transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                rs =
                        stmt.executeQuery();
                getBarsXML(toAppend, rs);
            } else if (refCustomerId >= 0) {
                if (!checkForeignKey("customer", "id", refCustomerId)) {
                    throw new HandlerException("Foreign Key Not found : customer " +
                            refCustomerId);
                }
//NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
//select statement.

                String selectByCustomerId = "SELECT bar.id, bar.name, bar.location, bar.zone, bar.latitude, bar.longitude, bar.type " +
                        "FROM bar LEFT JOIN location ON location.id=bar.location " +
                        "WHERE location.customer=?";
                //NischaySharma_09-Feb_2009_End
                if(regionId > 0) {
                selectByCustomerId                     += "  AND location.region =  "+String.valueOf(regionId);
                }
                stmt =
                        transconn.prepareStatement(selectByCustomerId);
                stmt.setInt(1, refCustomerId);
                rs =
                        stmt.executeQuery();
                getBarsXML(toAppend, rs);

            } else if (refUserId >= 0) {
                if (!checkForeignKey("user", "id", refUserId)) {
                    throw new HandlerException("Foreign Key Not found : user " +
                            refUserId);
                }
//NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
//select statement.

                String selectByUserId = "SELECT bar.id, bar.name, bar.location, bar.zone, bar.latitude, bar.longitude, bar.type " +
                        "FROM bar LEFT JOIN userMap ON userMap.location=bar.location " +
                        "WHERE userMap.user=?";
                //NischaySharma_09-Feb_2009_End
                stmt =
                        transconn.prepareStatement(selectByUserId);
                stmt.setInt(1, refUserId);
                rs =
                        stmt.executeQuery();
                getBarsXML(toAppend, rs);

            } else if (zoneId >= 0) {
                if (!checkForeignKey("zone", "id", zoneId)) {
                    throw new HandlerException("Foreign Key Not found : zone " +
                            zoneId);
                }
//NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
//select statement.

                String selectByZoneId = "SELECT id, name, location, zone, latitude, longitude, type " +
                        "FROM bar WHERE zone = ?";
                //NischaySharma_09-Feb_2009_End
                stmt =
                        transconn.prepareStatement(selectByZoneId);
                stmt.setInt(1, zoneId);
                rs =
                        stmt.executeQuery();
                getBarsXML(toAppend, rs);
            } else if (id >= 0) {
                //NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
                //select statement.
                String selectByBarId = "SELECT id, name, location, zone, latitude, longitude, type " +
                        "FROM bar WHERE id=?";
                //NischaySharma_09-Feb_2009_End
                stmt =
                        transconn.prepareStatement(selectByBarId);
                stmt.setInt(1, id);
                rs =
                        stmt.executeQuery();

                getBarsXML(toAppend, rs);
            } else {
                //NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
                //select statement.
                String selectByLocationId = "SELECT id, name, location, zone, latitude, longitude, type " +
                        "FROM bar";
                //NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
                //select statement.
                stmt =
                        transconn.prepareStatement(selectByLocationId);
                rs =
                        stmt.executeQuery();

                getBarsXML(toAppend, rs);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getProductsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element ProductE1 = toAppend.addElement("product");

            ProductE1.addElement("productId").addText(String.valueOf(rs.getInt(1)));
            ProductE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));

        }

    }

    private void getProducts(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "productId");
        String name = HandlerUtils.getOptionalString(toHandle, "name");

        int paramsSet = 0;
        if (id >= 0) {
            paramsSet++;
        }

        if (null != name) {
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getProducts.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {

            if (id >= 0) {
                String selectById = "SELECT id, name FROM product " +
                        "WHERE isActive = 1 AND id = ?";
                stmt =
                        transconn.prepareStatement(selectById);
                stmt.setInt(1, id);
                rs =
                        stmt.executeQuery();
                getProductsXML(toAppend, rs);
            } //NischaySharma_08-May-2009_Start: Added check if that if name is empty string then 
            //do not execue the query for name
            else if (null != name && !name.equals("")) {
                String selectByName = "SELECT id, name " +
                        "FROM product WHERE isActive = 1 AND name LIKE ?";
                name =
                        '%' + name + '%';
                stmt =
                        transconn.prepareStatement(selectByName);
                stmt.setString(1, name);
                rs =
                        stmt.executeQuery();
                getProductsXML(toAppend, rs);
            } //NischaySharma_08-May-2009_End
            else {
                String selectAll = "SELECT id, name FROM product WHERE isActive = 1 AND id>0";
                stmt =
                        transconn.prepareStatement(selectAll);
                rs =
                        stmt.executeQuery();
                getProductsXML(toAppend, rs);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a total tap count for the requried drill down
     */
    private void getLocationCount(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int countyId = HandlerUtils.getOptionalInteger(toHandle, "countyId");
        int bevSync                         = HandlerUtils.getOptionalInteger(toHandle, "bevSync");
        String state                        = HandlerUtils.getOptionalString(toHandle, "state");


         String conditionString = " ",specificStates=" ";

        if (regionId > 0) {
            conditionString = " AND uRM.region = ? ";
        } else if (countyId > 0) {
            conditionString = " AND l.countyIndex = ? ";
        }

        int paramsSet = 0;

        if (regionId >= 0) {
            paramsSet++;
        } else if (countyId >= 0) {
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getLocationCount.");
        }
        if(bevSync>0) {
            
            if (state != null && !state.equals("ALL")) {
                
                specificStates              ="AND l.addrState = '"+state+"' ";
                
            }
            
            
        }
        

        PreparedStatement stmt = null;
        ResultSet rs = null, locationRS = null;

        try {
            String selectUserExclusions = " SELECT e.tables, e.value FROM exclusion e LEFT JOIN userExclusionMap uEM ON uEM.exclusion = e.id WHERE e.type = 2 AND uEM.user = ? ";
            String userLocationExclusions = "0";
            if(bevSync == 1) {
            stmt = transconn.prepareStatement(selectUserExclusions);
            stmt.setInt(1, userId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                String selectLocations = " SELECT l.id FROM location l ";
                if (rs.getString(1).equals("county")) {
                    selectLocations += " LEFT JOIN county c ON c.id = l.countyIndex WHERE c.id = ?";
                } else if (rs.getString(1).equals("location")) {
                    selectLocations += " WHERE l.id = ? ";
                }
                stmt = transconn.prepareStatement(selectLocations);
                stmt.setInt(1, Integer.valueOf(rs.getString(2)));
                locationRS = stmt.executeQuery();
                while (locationRS.next()) {
                    userLocationExclusions += ", " + locationRS.getString(1);
                }
            }
            }

            String selectLocationCount = " SELECT count(l.id) FROM location l LEFT JOIN locationDetails lD ON lD.location = l.id " +
                " LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                " LEFT JOIN groupRegionMap gRM ON gRM.regionMaster = rCM.region" +
                " LEFT JOIN region r ON r.regionGroup = gRM.id" +
                " LEFT JOIN userRegionMap uRM ON uRM.region = r.id " +
                " WHERE lD.active = 1 AND lD.data = 1 AND l.id NOT IN (" + userLocationExclusions +") AND uRM.user = ?  " + conditionString;

            String selectBevSyncLocationCount = " SELECT count(l.id) FROM location l LEFT JOIN locationDetails lD ON lD.location = l.id " +
                               " WHERE lD.active = 1 AND lD.data = 1 AND lD.beerboard =1  " + specificStates;
            if(bevSync == 1) {
                stmt = transconn.prepareStatement(selectBevSyncLocationCount);
                
            } else {
            stmt = transconn.prepareStatement(selectLocationCount);
            stmt.setInt(1, userId);
            if (regionId >= 0) {
                stmt.setInt(2, regionId);
            } else if (countyId >= 0) {
                stmt.setInt(2, countyId);
            }
            }

            rs = stmt.executeQuery();

            if (rs.next()) {
                Element tapCount = toAppend.addElement("locationCount");
                tapCount.addText(String.valueOf(rs.getInt(1)));
                logger.debug("Count:"+rs.getInt(1));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void getActiveTextAlerts(Element toHandle, Element toAppend) throws HandlerException {

        String selectUserAlerts = " SELECT u.id, u.name, u.customer, u.mobile, u.carrier, t.id, t.alert, t.tableId, t.tableType, " +
                " t.minAlertThreshold, t.maxAlertThreshold, t.alertFrequency, t.currentFrequency, TIMESTAMP(concat(left(now(),11),IFNULL(t.alertTime, '07:00:00'))), " +
                " DATE_ADD((concat(left(now(),11),IFNULL(t.alertTime, '07:00:00'))),Interval (t.alertFrequency * 5) MINUTE) " +
                " FROM textAlert t LEFT JOIN user u on u.id = t.user ORDER BY t.alert, t.tableId, t.tableType;";
        String deactivateAlerts = " UPDATE alerts SET status = 0 WHERE unitId = ?;";
        ArrayList<Integer> deactivationArray = new ArrayList();
        PreparedStatement stmt = null;
        ResultSet rs = null;

        HashMap<Integer, String> activeAlerts = new HashMap<Integer, String>();

        logger.portalAction("getActiveTextAlerts");

        try {
            stmt = transconn.prepareStatement(selectUserAlerts);
            rs = stmt.executeQuery();
            while (rs.next()) {
                int colCount = 1;
                int userId = rs.getInt(colCount++);
                String userName = rs.getString(colCount++);
                int customerId = rs.getInt(colCount++);
                String mobile = rs.getString(colCount++);
                String carrier = rs.getString(colCount++);
                int alertId = rs.getInt(colCount++);
                int alertType = rs.getInt(colCount++);
                int tableId = rs.getInt(colCount++);
                int tableType = rs.getInt(colCount++);
                double minAlertThreshold = rs.getDouble(colCount++);
                double maxAlertThreshold = rs.getDouble(colCount++);
                int alertFrequency = rs.getInt(colCount++);
                int currentFrequency = rs.getInt(colCount++);
                String alertTime = rs.getString(colCount++);
                String alertEndTime = rs.getString(colCount++);
                
                if (alertFrequency > currentFrequency) {
                    activeAlerts = checkActiveAlerts(alertId, alertType, tableId, tableType, minAlertThreshold, maxAlertThreshold, alertTime, alertEndTime);
                    if (activeAlerts.size() > 0) {
                        for (Integer akey : activeAlerts.keySet()) {
                            Element textAlerts = toAppend.addElement("textAlerts");
                            textAlerts.addElement("userId").addText(String.valueOf(userId));
                            textAlerts.addElement("username").addText(HandlerUtils.nullToEmpty(userName));
                            textAlerts.addElement("customerId").addText(String.valueOf(customerId));
                            textAlerts.addElement("mobile").addText(HandlerUtils.nullToEmpty(mobile));
                            textAlerts.addElement("carrier").addText(HandlerUtils.nullToEmpty(carrier));
                            textAlerts.addElement("alertId").addText(String.valueOf(alertId));
                            textAlerts.addElement("alertDescription").addText(HandlerUtils.nullToEmpty(String.valueOf(activeAlerts.get(akey))));
                            if (alertType != 2 && alertType != 4) {
                                deactivationArray.add(akey);
                            }
                        }
                    }
                } 
            }

            //logger.debug("Removing Alerts ");
            Iterator<Integer> itr = deactivationArray.iterator();
            while (itr.hasNext()) {
                stmt = transconn.prepareStatement(deactivateAlerts);
                stmt.setInt(1, itr.next());
                stmt.executeUpdate();
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getDataCorrectionInfo(Element toHandle, Element toAppend) throws HandlerException {

        int componentId = HandlerUtils.getRequiredInteger(toHandle, "componentId");
        int modExcluded = HandlerUtils.getOptionalInteger(toHandle, "modExcluded");
        String businessDateString = HandlerUtils.getOptionalString(toHandle, "businessDate");

        String selectComponentInfo = " SELECT cLM.id, cLM.location, cLM.lastCheckId FROM componentLocationMap cLM WHERE cLM.component = ? ";
        String UpdateComponentInfo = " UPDATE componentLocationMap SET lastCheckId = ? WHERE id = ? ";
        String selectNewDataModInfo = " SELECT MAX(dM.id), MIN(dM.start), MAX(dM.end) FROM dataModNew dM " +
                " WHERE dM.location = ? AND dM.id > ? ";
        if (modExcluded > 0) {
            selectNewDataModInfo += " AND dM.modType NOT IN (?) ";
        }
        if (!(businessDateString == null)) {
            selectNewDataModInfo += " AND dM.start < ? ";
        }
        selectNewDataModInfo += " GROUP BY dM.location ORDER BY dM.id; ";
        String selectLocation = " SELECT l.id, l.name, l.easternOffset FROM location l LEFT JOIN locationDetails lD ON lD.location = l.id WHERE lD.active = 1 ";
        String selectBar = " SELECT b.id, b.name FROM bar b WHERE b.location = ? ";

        int locationId = 0, location = 0, lastCheckId = 0, newLastCheckId = 0, modType = 0, bar = 0, componentMapId = 0, i = 0;
        String locationName = null, barName = null;
        PreparedStatement stmt = null;
        ResultSet rs = null, rsLocation = null, rsNewData = null, rsBar = null;
        Double offset = 0.00;
        try {
            stmt = transconn.prepareStatement(selectComponentInfo);
            stmt.setInt(1, componentId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                componentMapId = rs.getInt(1);
                locationId = rs.getInt(2);
                lastCheckId = rs.getInt(3);
                newLastCheckId = lastCheckId;
                if (locationId > 0) {
                    selectLocation += " AND l.id = " + locationId + ";";
                }
                stmt = transconn.prepareStatement(selectLocation);
                rsLocation = stmt.executeQuery();
                while (rsLocation.next()) {
                    location = rsLocation.getInt(1);
                    locationName = rsLocation.getString(2);
                    offset = rsLocation.getDouble(3);
                    //logger.debug("Providing data correction details for " + locationName);
                    stmt = transconn.prepareStatement(selectNewDataModInfo);
                    stmt.setInt(1, location);
                    stmt.setInt(2, lastCheckId);
                    if (modExcluded > 0) {
                        stmt.setInt(3, modExcluded);
                    }
                    if (!businessDateString.isEmpty()) {
                        stmt.setString(4, businessDateString);
                    }
                    rsNewData = stmt.executeQuery();

                    while (rsNewData.next()) {
                        Element elLocation = toAppend.addElement("location");
                        elLocation.addElement("locationId").addText(String.valueOf(location));
                        //elLocation.addElement("locationName").addText(HandlerUtils.nullToEmpty(locationName));

                        if (newLastCheckId < rsNewData.getInt(1)) {
                            newLastCheckId = rsNewData.getInt(1);
                        }
                        String startStr = rsNewData.getString(2);
                        String endStr = rsNewData.getString(3);

                        stmt = transconn.prepareStatement(selectBar);
                        stmt.setInt(1, location);
                        rsBar = stmt.executeQuery();
                        while (rsBar.next()) {
                            bar = rsBar.getInt(1);
                            barName = rsBar.getString(2);

                            Element elBar = elLocation.addElement("bar");
                            elBar.addElement("barId").addText(String.valueOf(bar));
                            //elBar.addElement("barName").addText(HandlerUtils.nullToEmpty(barName));

                            java.util.Date start = null, end = null;
                            try {
                                start = newDateFormat.parse(startStr);
                                end = newDateFormat.parse(endStr);
                            } catch (ParseException pe) {
                                String badDate = (null == start) ? "start" : "end";
                                throw new HandlerException("Could not parse " + badDate + " date.");
                            }
                            start.setHours(7 - offset.intValue());
                            start.setMinutes(0);
                            start.setSeconds(0);
                            end.setMinutes(0);
                            end.setSeconds(0);

                            String perdiodDetail = String.valueOf(start.getHours());
                            ReportPeriod period = new ReportPeriod(PeriodType.DAILY, perdiodDetail, start, end);
                            SortedSet<DatePartition> dps = DatePartitionFactory.createPartitions(period);
                            //logger.debug("Created partitions: \n"+DatePartitionFactory.partitionReport(dps));
                            for (DatePartition dp : dps) {
                                Element elPeriod = elBar.addElement("period");
                                elPeriod.addElement("periodDate").addText(newDateFormat.format(dp.getDate()));
                            }
                        }
                    }
                }
                stmt = transconn.prepareStatement(UpdateComponentInfo);
                stmt.setInt(1, newLastCheckId);
                stmt.setInt(2, componentMapId);
                stmt.executeUpdate();
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rsBar);
            close(rsNewData);
            close(rs);
            close(stmt);
        }
    }

    private String dateToString(java.util.Date toConvert) {
        SimpleDateFormat newDateFormat = new SimpleDateFormat("HH:mm:ss");
        String convertedDate = newDateFormat.format(toConvert);
        return convertedDate;
    }

    /**
     * The folowing code is to get sms alerts for each user for the location
     * that they provide - SR
     */
    private void getEmailReports(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String selectUserReports = " SELECT eR.id, eR.report, eR.tableId, eR.tableType, eR.tableValues, eR.minAlertThreshold, eR.maxAlertThreshold, eR.reportFormat, eR.time FROM emailReport eR WHERE eR.user=? AND eR.platform = ?; ";

        SimpleDateFormat f = new SimpleDateFormat("HH:mm:ss");
        PreparedStatement stmt = null;
        ResultSet rs = null, innerrs = null, locationRS;
        String userLocationExclusions = "0";
        logger.portalAction("getEmailReports");
        Element reportTime = null, toolTip = null;
        try {
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int platform = HandlerUtils.getRequiredInteger(toHandle, "platform");
            stmt = transconn.prepareStatement(selectUserReports);
            stmt.setInt(1, userId);
            stmt.setInt(2, platform);
            rs = stmt.executeQuery();
            int colCount = 1;
            while (rs.next()) {
                colCount = 1;
                Element emailReports = toAppend.addElement("emailReports");
                int reportId = rs.getInt(colCount++);
                int report = rs.getInt(colCount++);
                int tableId = rs.getInt(colCount++);
                int tableType = rs.getInt(colCount++);
                String tableValues = rs.getString(colCount++);
                emailReports.addElement("id").addText(String.valueOf(reportId));
                emailReports.addElement("report").addText(String.valueOf(report));
                emailReports.addElement("tableId").addText(String.valueOf(tableId));
                emailReports.addElement("tableType").addText(String.valueOf(tableType));
                emailReports.addElement("tableValues").addText(HandlerUtils.nullToEmpty(tableValues));
                emailReports.addElement("reportDescription").addText(HandlerUtils.nullToEmpty(getAlertDescription(tableId, tableType)));
                emailReports.addElement("minAlertThreshold").addText(String.valueOf(rs.getDouble(colCount++)));
                emailReports.addElement("maxAlertThreshold").addText(String.valueOf(rs.getDouble(colCount++)));
                emailReports.addElement("reportFormat").addText(String.valueOf(rs.getInt(colCount++)));
                switch (rs.getInt(colCount++)) {
                    case 0:
                        reportTime = emailReports.addElement("reportTime");
                        break;
                    case 1:
                        String selectUserReportsTimes = " SELECT eTT.id, eTT.time, eTT.day FROM emailTimeTable eTT WHERE eTT.user=? AND eTT.report = ?; ";
                        stmt = transconn.prepareStatement(selectUserReportsTimes);
                        stmt.setInt(1, userId);
                        stmt.setInt(2, reportId);
                        innerrs = stmt.executeQuery();
                        while (innerrs.next()) {
                            reportTime = emailReports.addElement("reportTime");
                            String alertTime = innerrs.getString(2);
                            java.util.Date d = f.parse(alertTime);
                            java.util.Date date = new java.util.Date(d.getTime() + getAlertOffsetInMillis(tableId, tableType));
                            reportTime.addElement("timeId").addText(String.valueOf(innerrs.getInt(1)));
                            reportTime.addElement("time").addText(HandlerUtils.nullToEmpty(dateToString(date)));
                            reportTime.addElement("day").addText(String.valueOf(innerrs.getInt(3)));
                        }
                        break;
                    default:
                        reportTime = emailReports.addElement("reportTime");
                        break;
                }
                switch (platform) {
                    case 1:
                        toolTip = emailReports.addElement("toolTip");
                        break;
                    case 2:
                        try {
                            String selectUserExclusions = " SELECT e.tables, e.value FROM exclusion e LEFT JOIN userExclusionMap uEM ON uEM.exclusion = e.id WHERE e.type = 2 AND uEM.user = ? ";
                            stmt = transconn.prepareStatement(selectUserExclusions);
                            stmt.setInt(1, userId);
                            innerrs = stmt.executeQuery();
                            while (innerrs.next()) {
                                String selectLocations = " SELECT l.id FROM location l ";
                                if (innerrs.getString(1).equals("county")) {
                                    selectLocations += " LEFT JOIN county c ON c.id = l.countyIndex WHERE c.id = ?";
                                } else if (innerrs.getString(1).equals("location")) {
                                    selectLocations += " WHERE l.id = ? ";
                                }
                                stmt = transconn.prepareStatement(selectLocations);
                                stmt.setInt(1, Integer.valueOf(innerrs.getString(2)));
                                locationRS = stmt.executeQuery();
                                while (locationRS.next()) {
                                    userLocationExclusions += ", " + locationRS.getString(1);
                                }
                                locationRS.close();
                            }
                        } catch (SQLException sqle) {
                            throw new HandlerException(sqle);
                        } finally {
                        }

                        String selectToolTipInfo = " SELECT CONCAT(SUBSTRING(c.name,1,12),'-',SUBSTRING(l.name,1,12)) FROM location l LEFT JOIN customer c ON c.id = l.customer WHERE l.id IN (" + tableValues +" ) AND l.id NOT IN (" + userLocationExclusions + "); ";
                        stmt = transconn.prepareStatement(selectToolTipInfo);
                        innerrs = stmt.executeQuery();
                        while (innerrs.next()) {
                            toolTip = emailReports.addElement("toolTip");
                            toolTip.addElement("locInfo").addText(HandlerUtils.nullToEmpty(innerrs.getString(1)));
                        }
                        break;
                    default:
                        toolTip = emailReports.addElement("toolTip");
                        break;
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } catch (Exception e) {
            logger.dbError("Parse error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(stmt);
            close(rs);
            close(innerrs);
        }

    }

    /**
     * The folowing code is to get sms alerts for each user for the location
     * that they provide - SR
     */
    private void getTextAlerts(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String selectUserAlerts = " SELECT tA.id, tA.alert, tA.tableId, tA.tableType, tA.minAlertThreshold, tA.maxAlertThreshold, tA.alertTime, tA.alertFrequency FROM textAlert tA WHERE tA.user=?; ";

        SimpleDateFormat f = new SimpleDateFormat("HH:mm:ss");
        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getTextAlerts");

        try {
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            stmt = transconn.prepareStatement(selectUserAlerts);
            stmt.setInt(1, userId);
            rs = stmt.executeQuery();
            int colCount = 1;
            while (rs.next()) {
                colCount = 1;
                Element textAlerts = toAppend.addElement("textAlerts");
                textAlerts.addElement("id").addText(String.valueOf(rs.getInt(colCount++)));
                textAlerts.addElement("alert").addText(String.valueOf(rs.getInt(colCount++)));
                int tableId = rs.getInt(colCount++);
                int tableType = rs.getInt(colCount++);
                textAlerts.addElement("tableId").addText(String.valueOf(tableId));
                textAlerts.addElement("tableType").addText(String.valueOf(tableType));
                textAlerts.addElement("alertDescription").addText(HandlerUtils.nullToEmpty(getAlertDescription(rs.getInt(3), rs.getInt(4))));
                textAlerts.addElement("minAlertThreshold").addText(String.valueOf(rs.getDouble(colCount++)));
                textAlerts.addElement("maxAlertThreshold").addText(String.valueOf(rs.getDouble(colCount++)));
                String alertTime = rs.getString(colCount++);
                java.util.Date d = f.parse(alertTime);
                java.util.Date date = new java.util.Date(d.getTime() + getAlertOffsetInMillis(tableId, tableType));
                textAlerts.addElement("alertTime").addText(HandlerUtils.nullToEmpty(dateToString(date)));
                textAlerts.addElement("alertFrequency").addText(String.valueOf(rs.getDouble(colCount++)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } catch (Exception e) {
            logger.dbError("Parse error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getVarianceEmailAlerts(Element toHandle, Element toAppend) throws HandlerException {

        String selectUserInfo = " SELECT u.name, u.email, c.name, l.id, l.name, l.easternOffset, DATE_SUB(l.lastSold, INTERVAL -l.easternOffset HOUR), DATE_SUB(l.lastPoured, INTERVAL -l.easternOffset HOUR)," +
                " DATE_SUB(If(CURTIME()<'12:00:00',concat(left(subdate(now(),1),11),IFNULL(x.openYesterday,'11:00:00')),concat(left(now(),11),IFNULL(x.openToday,'11:00:00'))), INTERVAL l.easternOffset HOUR) Open," +
                " DATE_SUB(If(CURTIME()<'12:00:00',If(IFNULL(x.closeYesterday,'02:00:00')<'12:00:00',concat(left(now(),11),IFNULL(x.closeYesterday,'02:00:00')),concat(left(subdate(now(),1),11),IFNULL(x.closeYesterday,'02:00:00'))),If(IFNULL(x.closeToday,'02:00:00')<'12:00:00',concat(left(adddate(now(),1),11),IFNULL(x.closeToday,'02:00:00')),concat(left(now(),11),IFNULL(x.closeToday,'02:00:00')))), INTERVAL l.easternOffset HOUR) startClose," +
                " DATE_SUB(If(CURTIME()<'12:00:00',If(IFNULL(x.closeYesterday,'02:00:00')<'12:00:00',concat(left(now(),11),IFNULL(x.closeYesterday,'02:00:00')),concat(left(subdate(now(),1),11),IFNULL(x.closeYesterday,'02:00:00'))),If(IFNULL(x.closeToday,'02:00:00')<'12:00:00',concat(left(adddate(now(),1),11),IFNULL(x.closeToday,'02:00:00')),concat(left(now(),11),IFNULL(x.closeToday,'02:00:00')))), INTERVAL ((l.easternOffset * 60) - (e.alertFrequency * 5)) MINUTE) endClose" +
                " FROM emailAlert e LEFT JOIN user u on u.id = e.user" +
                " LEFT JOIN location l on l.id = e.tableId" +
                " LEFT JOIN customer c on c.id = l.customer" +
                " LEFT JOIN (Select location," +
                " CASE DAYOFWEEK(NOW())" +
                " WHEN 1 THEN Right(lH.closeSun,8)" +
                " WHEN 2 THEN Right(lH.closeMon,8)" +
                " WHEN 3 THEN Right(lH.closeTue,8)" +
                " WHEN 4 THEN Right(lH.closeWed,8)" +
                " WHEN 5 THEN Right(lH.closeThu,8)" +
                " WHEN 6 THEN Right(lH.closeFri,8)" +
                " WHEN 7 THEN Right(lH.closeSat,8) END closeToday," +
                " CASE DAYOFWEEK(NOW()-1000000)" +
                " WHEN 1 THEN Right(lH.closeSun,8)" +
                " WHEN 2 THEN Right(lH.closeMon,8)" +
                " WHEN 3 THEN Right(lH.closeTue,8)" +
                " WHEN 4 THEN Right(lH.closeWed,8)" +
                " WHEN 5 THEN Right(lH.closeThu,8)" +
                " WHEN 6 THEN Right(lH.closeFri,8)" +
                " WHEN 7 THEN Right(lH.closeSat,8) END closeYesterday," +
                " CASE DAYOFWEEK(NOW())" +
                " WHEN 1 THEN Right(lH.openSun,8)" +
                " WHEN 2 THEN Right(lH.openMon,8)" +
                " WHEN 3 THEN Right(lH.openTue,8)" +
                " WHEN 4 THEN Right(lH.openWed,8)" +
                " WHEN 5 THEN Right(lH.openThu,8)" +
                " WHEN 6 THEN Right(lH.openFri,8)" +
                " WHEN 7 THEN Right(lH.openSat,8) END openToday," +
                " CASE DAYOFWEEK(NOW()-1000000)" +
                " WHEN 1 THEN Right(lH.openSun,8)" +
                " WHEN 2 THEN Right(lH.openMon,8)" +
                " WHEN 3 THEN Right(lH.openTue,8)" +
                " WHEN 4 THEN Right(lH.openWed,8)" +
                " WHEN 5 THEN Right(lH.openThu,8)" +
                " WHEN 6 THEN Right(lH.openFri,8)" +
                " WHEN 7 THEN Right(lH.openSat,8) END openYesterday" +
                " FROM locationHours lH) AS x ON x.location = e.tableId";

        java.util.Date timestamp = new java.util.Date(new java.util.Date().getTime());
        java.util.Date storeStartCloseTime = new java.util.Date(2007, 1, 1, 7, 0, 0);
        java.util.Date storeEndCloseTime = new java.util.Date(2007, 1, 1, 7, 0, 0);

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(selectUserInfo);
            rs = stmt.executeQuery();

            while (rs.next()) {
                storeStartCloseTime = rs.getTimestamp(10);
                storeEndCloseTime = rs.getTimestamp(11);
                if (timestamp.after(storeStartCloseTime) && timestamp.before(storeEndCloseTime)) {
                    Element user = toAppend.addElement("varianceAlertDetail");
                    user.addElement("user").addText(rs.getString(1));
                    user.addElement("userEmail").addText(rs.getString(2));
                    user.addElement("customer").addText(rs.getString(3));
                    user.addElement("locationId").addText(rs.getString(4));
                    user.addElement("location").addText(rs.getString(5));
                    user.addElement("offset").addText(rs.getString(6));
                    user.addElement("lastSold").addText(rs.getString(7));
                    user.addElement("lastPoured").addText(rs.getString(8));
                    user.addElement("storeOpen").addText(rs.getString(9));
                    user.addElement("storeClose").addText(rs.getString(10));
                } else {
                    logger.debug("Time did not match");
                    logger.debug("DB Time: " + rs.getString(10));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /** Converts a java.util.Date to a java.sql.Date
     */
    private java.sql.Timestamp toSqlTimestamp(java.util.Date d) {
        return new java.sql.Timestamp(d.getTime());
    }

    private boolean hasSoldTimestamp(Integer tableId, Integer tableType, int delayMin) throws HandlerException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        java.util.Date timestamp = new java.util.Date(new java.util.Date().getTime() - (delayMin * 60 * 1000));
        logger.debug("New adjusted Time Stamp: " + delayMin + ", timestamp is " + timestamp.toString());
        boolean hasSoldTimestamp = false;

        try {
            String selectSoldTimestamp = "";

            switch (tableType) {
                case 1:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter LEFT JOIN location l ON l.id = c.location " +
                            " WHERE l.customer = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1 ";
                    break;

                case 2:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter LEFT JOIN location l ON l.id = c.location " +
                            " WHERE l.id = ? AND s.date > ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 3:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter " +
                            " WHERE c.bar = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 4:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter LEFT JOIN location l ON l.id = c.location " +
                            " LEFT JOIN cooler c ON c.location = l.id WHERE c.id = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 5:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter " +
                            " WHERE c.zone = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 6:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter " +
                            " WHERE c.bar = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 7:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter " +
                            " WHERE c.station = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 8:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter LEFT JOIN location l ON l.id = c.location " +
                            " LEFT JOIN system sy ON sy.location = l.id WHERE sy.id = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 9:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter LEFT JOIN location l ON l.id = c.location " +
                            " LEFT JOIN inventory i ON i.location = l.id  WHERE i.kegLine = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 10:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter LEFT JOIN location l ON l.id = c.location " +
                            " LEFT JOIN inventory i ON i.location = l.id  WHERE i.id = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 11:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter LEFT JOIN location l ON l.id = c.location " +
                            " LEFT JOIN system sy ON sy.location = l.id LEFT JOIN line li ON li.system = sy.id WHERE li.id = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1  ";
                    break;

                case 12:
                    selectSoldTimestamp += " SELECT 1 FROM groups g WHERE g.id = ? ";
                    break;

                case 13:
                    selectSoldTimestamp += " SELECT 1 FROM region r WHERE r.id = ? ";
                    break;

                case 14:
                    selectSoldTimestamp += " SELECT 1 FROM county c LEFT JOIN state s ON s.FIPSST = c.state WHERE c.id = ? ";
                    break;

                default:
                    selectSoldTimestamp += " SELECT s.sid FROM salesNew s LEFT JOIN costCenter c ON c.ccID = s.costCenter LEFT JOIN location l ON l.id = c.location " +
                            " WHERE l.customer = ? AND s.date > ? ORDER BY s.date DESC LIMIT 1 ";
                    break;
            }
            stmt = transconn.prepareStatement(selectSoldTimestamp);
            stmt.setInt(1, tableId);
            stmt.setTimestamp(2, toSqlTimestamp(timestamp));
            rs = stmt.executeQuery();
            if (rs.next()) {
                hasSoldTimestamp = true;
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
        return hasSoldTimestamp;
    }



    private int getLocationType(Integer tableId, Integer tableType) throws HandlerException {
        PreparedStatement stmt = null;
        ResultSet rs = null;

        int locationType = 1;

        try {
            String selectLocationType = "";

            switch (tableType) {
                case 1:
                    selectLocationType += " SELECT type FROM customer WHERE id = ? ";
                    break;

                case 2:
                    selectLocationType += " SELECT l.type FROM location l WHERE l.id = ? ";
                    break;

                case 3:
                    selectLocationType += " SELECT l.type FROM bar b LEFT JOIN location l ON l.id = b.location WHERE b.id = ? ";
                    break;

                case 4:
                    selectLocationType += " SELECT l.type FROM cooler c LEFT JOIN location l ON l.id = c.location WHERE c.id = ? ";
                    break;

                case 5:
                    selectLocationType += " SELECT l.type FROM zone z LEFT JOIN locatoion l ON l.id = z.location WHERE z.id = ? ";
                    break;

                case 6:
                    selectLocationType += " SELECT l.type FROM bar b LEFT JOIN zone z ON z.id = b.zone " +
                            " LEFT JOIN location l ON l.id = z.location WHERE b.id = ? ";
                    break;

                case 7:
                    selectLocationType += " SELECT l.type FROM station st LEFT JOIN bar b ON b.id = st.bar " +
                            " LEFT JOIN zone z ON z.id = b.zone LEFT JOIN location l ON l.id = z.location WHERE st.id = ? ";
                    break;

                case 8:
                    selectLocationType += " SELECT l.type FROM system s LEFT JOIN location l ON l.id = s.location WHERE s.id = ? ";
                    break;

                case 9:
                    selectLocationType += " SELECT l.type FROM inventory i LEFT JOIN location l ON l.id = i.location " +
                            " LEFT JOIN product p ON p.id = i.product WHERE i.kegLine = ? ";
                    break;

                case 10:
                    selectLocationType += " SELECT l.type FROM inventory i LEFT JOIN location l ON l.id = i.location " +
                            " LEFT JOIN product p ON p.id = i.product WHERE i.id = ? ";
                    break;

                case 11:
                    selectLocationType += " SELECT l.type FROM line li LEFT JOIN system s ON s.id = li.system " +
                            " LEFT JOIN location l ON l.id = s.location WHERE li.id = ? ";
                    break;

                case 12:
                    selectLocationType += " SELECT 1 FROM groups g WHERE g.id = ? ";
                    break;

                case 13:
                    selectLocationType += " SELECT 1 FROM region r WHERE r.id = ? ";
                    break;

                case 14:
                    selectLocationType += " SELECT 1 FROM county c LEFT JOIN state s ON s.FIPSST = c.state WHERE c.id = ? ";
                    break;

                default:
                    selectLocationType += " SELECT type FROM customer WHERE id = ? ";
                    break;
            }


            stmt = transconn.prepareStatement(selectLocationType);
            stmt.setInt(1, tableId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                locationType = rs.getInt(1);
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
        //logger.debug(String.valueOf(alertOffsetInMillis));
        return locationType;
    }

    private long getAlertOffsetInMillis(Integer tableId, Integer tableType) throws HandlerException {
        PreparedStatement stmt = null;
        ResultSet rs = null;

        long alertOffsetInMillis = 0;

        try {
            String selectAlertOffsetInMillis = "";

            switch (tableType) {
                case 1:
                    selectAlertOffsetInMillis += " SELECT 0.00 FROM customer WHERE id = ? ";
                    break;

                case 2:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM location l WHERE l.id = ? ";
                    break;

                case 3:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM bar b LEFT JOIN location l ON l.id = b.location WHERE b.id = ? ";
                    break;

                case 4:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM cooler c LEFT JOIN location l ON l.id = c.location WHERE c.id = ? ";
                    break;

                case 5:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM zone z LEFT JOIN locatoion l ON l.id = z.location WHERE z.id = ? ";
                    break;

                case 6:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM bar b LEFT JOIN zone z ON z.id = b.zone " +
                            " LEFT JOIN location l ON l.id = z.location WHERE b.id = ? ";
                    break;

                case 7:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM station st LEFT JOIN bar b ON b.id = st.bar " +
                            " LEFT JOIN zone z ON z.id = b.zone LEFT JOIN location l ON l.id = z.location WHERE st.id = ? ";
                    break;

                case 8:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM system s LEFT JOIN location l ON l.id = s.location WHERE s.id = ? ";
                    break;

                case 9:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM inventory i LEFT JOIN location l ON l.id = i.location " +
                            " LEFT JOIN product p ON p.id = i.product WHERE i.kegLine = ? ";
                    break;

                case 10:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM inventory i LEFT JOIN location l ON l.id = i.location " +
                            " LEFT JOIN product p ON p.id = i.product WHERE i.id = ? ";
                    break;

                case 11:
                    selectAlertOffsetInMillis += " SELECT l.easternOffset FROM line li LEFT JOIN system s ON s.id = li.system " +
                            " LEFT JOIN location l ON l.id = s.location WHERE li.id = ? ";
                    break;

                case 12:
                    selectAlertOffsetInMillis += " SELECT 0.00 FROM groups g WHERE g.id = ? ";
                    break;

                case 13:
                    selectAlertOffsetInMillis += " SELECT 0.00 FROM region r WHERE r.id = ? ";
                    break;

                case 14:
                    selectAlertOffsetInMillis += " SELECT 0.00 FROM county c LEFT JOIN state s ON s.FIPSST = c.state WHERE c.id = ? ";
                    break;

                default:
                    selectAlertOffsetInMillis += " ";
                    break;
            }


            stmt = transconn.prepareStatement(selectAlertOffsetInMillis);
            stmt.setInt(1, tableId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                alertOffsetInMillis = 1000 * 60 * 60 * rs.getLong(1);
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
        //logger.debug(String.valueOf(alertOffsetInMillis));
        return alertOffsetInMillis;
    }

    private String getAlertDescription(Integer tableId, Integer tableType) throws HandlerException {
        PreparedStatement stmt = null;
        ResultSet rs = null;

        String alertDescription = "";

        try {
            String selectAlertDescription = "";


            switch (tableType) {
                case 1:
                    selectAlertDescription += " SELECT SUBSTRING(name,1,14) FROM customer WHERE id = ? ";
                    break;

                case 2:
                    selectAlertDescription += " SELECT SUBSTRING(l.name,1,14) FROM location l LEFT JOIN customer c ON c.id = l.customer WHERE l.id = ? ";
                    break;

                case 3:
                    selectAlertDescription += " SELECT CONCAT(SUBSTRING(l.name,1,12),'-',SUBSTRING(b.name,1,5)) FROM bar b LEFT JOIN location l ON l.id = b.location WHERE b.id = ? ";
                    break;

                case 4:
                    selectAlertDescription += " SELECT CONCAT(SUBSTRING(c.name,1,12),'-',SUBSTRING(l.name,1,12)) FROM cooler c LEFT JOIN location l ON l.id = c.location LEFT JOIN customer cu ON cu.id = l.customer" +
                            " WHERE c.id = ? ";
                    break;

                case 5:
                    selectAlertDescription += " SELECT CONCAT(SUBSTRING(l.name,1,12),'-',SUBSTRING(z.name,1,5)) FROM zone z LEFT JOIN locatoion l ON l.id = z.location WHERE z.id = ? ";
                    break;

                case 6:
                    selectAlertDescription += " SELECT CONCAT(SUBSTRING(l.name,1,12),'-',z.name,'-',b.name) FROM bar b LEFT JOIN zone z ON z.id = b.zone " +
                            " LEFT JOIN location l ON l.id = z.location WHERE b.id = ? ";
                    break;

                case 7:
                    selectAlertDescription += " SELECT CONCAT(SUBSTRING(l.name,1,12),'-',z.name,'-',b.name,'-',st.name) FROM station st LEFT JOIN bar b ON b.id = st.bar " +
                            " LEFT JOIN zone z ON z.id = b.zone LEFT JOIN location l ON l.id = z.location WHERE st.id = ? ";
                    break;

                case 8:
                    selectAlertDescription += " SELECT CONCAT(SUBSTRING(l.name,1,12),'-',s.systemId) FROM system s LEFT JOIN location l ON l.id = s.location WHERE s.id = ? ";
                    break;

                case 9:
                    selectAlertDescription += " SELECT CONCAT(SUBSTRING(l.name,1,12),'-',i.kegLine,'-',SUBSTRING(p.name,1,5)) FROM inventory i LEFT JOIN location l ON l.id = i.location " +
                            " LEFT JOIN product p ON p.id = i.product WHERE i.kegLine = ? ";
                    break;

                case 10:
                    selectAlertDescription += " SELECT SUBSTRING(p.name,1,18) FROM inventory i LEFT JOIN location l ON l.id = i.location " +
                            " LEFT JOIN product p ON p.id = i.product WHERE i.id = ? ";
                    break;

                case 11:
                    selectAlertDescription += " SELECT CONCAT('Sys ',s.systemId,' - ID ', li.lineIndex + 1, ' - ',SUBSTRING(p.name,1,5)) FROM line li LEFT JOIN system s ON s.id = li.system " +
                            " LEFT JOIN product p ON p.id = li.product WHERE li.id = ? ";
                    break;

                case 12:
                    selectAlertDescription += " SELECT SUBSTRING(g.name,1,12) FROM groups g WHERE g.id = ? ";
                    break;

                case 13:
                    selectAlertDescription += " SELECT SUBSTRING(r.name,1,12) FROM region r WHERE r.id = ? ";
                    break;

                case 14:
                    selectAlertDescription += " SELECT CONCAT(c.name,' - ',s.USPSST) FROM county c LEFT JOIN state s ON s.FIPSST = c.state WHERE c.id = ? ";
                    break;

                default:
                    selectAlertDescription += " ";
                    break;

            }


            stmt = transconn.prepareStatement(selectAlertDescription);
            stmt.setInt(1, tableId);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                alertDescription = rs.getString(1);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

        return alertDescription;

    }

    private HashMap<Integer, String> checkActiveInventoryAlert(Integer alertId, Integer tableId, Integer tableType, String alertTime) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null, tempRS = null;

        HashMap<Integer, String> inventoryAlert = new HashMap<Integer, String>();
        String alertDescription = "";

        try {
            String selectAlertDescription = "SELECT a.unitId, ROUND(a.value,2) FROM alerts a LEFT JOIN inventory i ON i.id = a.unitId " +
                    " WHERE a.alertType = 3 AND a.status = 1";
            String updateAlertFrequency = "UPDATE textAlert SET currentFrequency = currentFrequency + 1 WHERE id = ?";
            boolean alertSent = false;

            String selectTempAlertTime = "SELECT id, (date + INTERVAL 40 MINUTE), active FROM tempActiveAlertTime WHERE alertId = ? AND unitId = ?";
            String insertActiveAlertTime = "INSERT INTO tempActiveAlertTime (alertId, unitId, date) VALUES (?,?,?)";
            String updateActiveAlertTime = "UPDATE tempActiveAlertTime SET date = ? WHERE id = ?";
            String deactivateAlerts = " UPDATE alerts SET status = 0 WHERE unitId = ?;";

            switch (tableType) {
                case 2:
                    selectAlertDescription += " AND i.location = ? ";
                    break;
                case 10:
                    selectAlertDescription += " AND i.id = ? ";
                    break;
                default:
                    selectAlertDescription += " ";
                    break;
            }
            stmt = transconn.prepareStatement(selectAlertDescription);
            stmt.setInt(1, tableId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                java.util.Date currentTime = new java.util.Date();
                java.util.Date lastCheckTime = new java.util.Date();
                stmt = transconn.prepareStatement(selectTempAlertTime);
                stmt.setInt(1, alertId);
                stmt.setInt(2, rs.getInt(1));
                tempRS = stmt.executeQuery();
                if (tempRS.next()) {
                    lastCheckTime = tempRS.getDate(2);
                    java.text.DateFormat timeParse = new java.text.SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
                    java.util.Date alertTimeStamp = timeParse.parse(alertTime);
                    int millisecondsToWait = ((alertTimeStamp.getHours() * 60) + alertTimeStamp.getMinutes()) * 60000;
                    if (currentTime.getTime() > (lastCheckTime.getTime() + millisecondsToWait)) {
                        alertDescription = "Low Stock Alert\n" + getAlertDescription(rs.getInt(1), 10) + " : " + rs.getString(2);
                        inventoryAlert.put(rs.getInt(1), alertDescription);
                        alertSent = true;

                        stmt = transconn.prepareStatement(updateActiveAlertTime);
                        stmt.setTimestamp(1, new java.sql.Timestamp(lastCheckTime.getTime() + millisecondsToWait));
                        stmt.setInt(2, tempRS.getInt(1));
                        stmt.executeUpdate();
                    } else {
                        stmt = transconn.prepareStatement(deactivateAlerts);
                        stmt.setInt(1, rs.getInt(1));
                        stmt.executeUpdate();
                    }
                } else {
                    alertDescription = "Low Stock Alert\n" + getAlertDescription(rs.getInt(1), 10) + " : " + rs.getString(2);
                    inventoryAlert.put(rs.getInt(1), alertDescription);
                    alertSent = true;

                    stmt = transconn.prepareStatement(insertActiveAlertTime);
                    stmt.setInt(1, alertId);
                    stmt.setInt(2, rs.getInt(1));
                    stmt.setTimestamp(3, new java.sql.Timestamp(currentTime.getTime()));
                    stmt.executeUpdate();
                }
            }
            if (alertSent){
                stmt = transconn.prepareStatement(updateAlertFrequency);
                stmt.setInt(1, alertId);
                stmt.executeUpdate();
            } 

        } catch (ParseException pe) {
            logger.dbError("Parse Exception : " + pe.getMessage());
            throw new HandlerException(pe);
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(tempRS);
            close(rs);
            close(stmt);
        }

        return inventoryAlert;
    }

    private HashMap<Integer, String> checkActiveVarianceAlert(Integer tableId, Integer tableType, double alertThreshold, String alertTime, String alertEndTime) throws HandlerException {

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        HashMap<Integer, String> varianceAlert
                                            = new HashMap<Integer, String>();

        try {
            stmt                            = transconn.prepareStatement("SELECT type FROM location WHERE id = ?");
            stmt.setInt(1, tableId);
            rs                              = stmt.executeQuery();
            if (rs.next()) {
                if (rs.getInt(1) == 1) {
                    java.text.DateFormat timeParse
                                            = new java.text.SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
                    java.util.Date alertTimeStamp
                                            = timeParse.parse(alertTime);
                    java.util.Date alertEndTimeStamp
                                            = timeParse.parse(alertEndTime);
                    java.util.Date currentTimestamp
                                            = new Date(new java.util.Date().getTime());
                    if (currentTimestamp.after(alertTimeStamp) && currentTimestamp.before(alertEndTimeStamp)) {
                        varianceAlert       = checkActiveRetailVarianceAlert(tableId, tableType, alertThreshold, alertTime);
                    }
                } else {
                    varianceAlert           = checkActiveConcessionsVarianceAlert(tableId, tableType, alertThreshold);
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } catch (Exception e) {
            logger.dbError("Handler error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(rs);
            close(stmt);
        }
        return varianceAlert;
    }

    private HashMap<Integer, String> checkActiveConcessionsVarianceAlert(Integer tableId, Integer tableType, double alertThreshold) throws HandlerException {

        PreparedStatement stmt              = null;
        ResultSet rs                        = null, innerRS = null;
        double totalPoured                  = 0.00, totalSold = 0.00, totalVariance = 0.00;
        double offset                       = 0.00;
        HashMap<Integer, String> varianceAlert
                                            = new HashMap<Integer, String>();
        String alertDescription             = "";
        java.text.DecimalFormat twoDForm    = new java.text.DecimalFormat("#.##");
        String start                        = null, end = null;

        try {
            String getEventTime             = "SELECT ADDDATE(preOpen, INTERVAL 30 MINUTE), ADDDATE(eventEnd, INTERVAL 30 MINUTE) FROM eventHours WHERE location = ? AND date = CURDATE() ORDER BY preOpen;";
            stmt                            = transconn.prepareStatement(getEventTime);
            stmt.setInt(1, tableId);
            rs                              = stmt.executeQuery();
            if (rs.next()) {
                start                       = rs.getString(1);
                end                         = rs.getString(2);
                java.text.DateFormat timeParse
                                            = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                java.util.Date alertStartTimeStamp
                                            = timeParse.parse(start);
                java.util.Date alertEndTimeStamp
                                            = timeParse.parse(end);
                java.util.Date currentTimestamp
                                            = Calendar.getInstance().getTime();
                if (currentTimestamp.after(alertStartTimeStamp) && currentTimestamp.before(alertEndTimeStamp) && (currentTimestamp.getMinutes() == 15 || currentTimestamp.getMinutes() == 45)) {
                    Calendar startCal       = Calendar.getInstance();
                    startCal.setTime(new java.util.Date());
                    startCal.add(Calendar.MINUTE, -45);
                    Calendar endCal         = Calendar.getInstance();
                    endCal.setTime(new java.util.Date());
                    endCal.add(Calendar.MINUTE, -15);
                    logger.debug("Start: " + timeParse.format(startCal.getTime()));
                    logger.debug("End: " + timeParse.format(endCal.getTime()));
                    stmt                    = transconn.prepareStatement("SELECT id, name FROM bar WHERE location = ?");
                    stmt.setInt(1, tableId);
                    innerRS                 = stmt.executeQuery();
                    while (innerRS.next()) {
                        int barId           = innerRS.getInt(1);
                        totalPoured         = getPoured(barId, 6, "Daily", String.valueOf(Math.round(8 - offset)), timeParse.format(startCal.getTime()), timeParse.format(endCal.getTime()));
                        totalSold           = getSold(barId, 6, "Daily", String.valueOf(Math.round(8 - offset)), timeParse.format(startCal.getTime()), timeParse.format(endCal.getTime()));
                        totalVariance       = getVariance(totalPoured, totalSold);
                        logger.debug("Variance for stand " + innerRS.getString(2)  + " is " + twoDForm.format(totalVariance));
                        if ((totalVariance < alertThreshold) && (totalSold > 10))  {
                            alertDescription
                                            = "High Variance Alert\n" + getAlertDescription(barId, 6) + " : " + twoDForm.format(totalVariance) + "%";
                            varianceAlert.put(barId, alertDescription);
                        }
                    }
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } catch (Exception e) {
            logger.dbError("Handler error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(rs);
            close(innerRS);
            close(stmt);
        }

        return varianceAlert;
    }

    private HashMap<Integer, String> checkActiveRetailVarianceAlert(Integer tableId, Integer tableType, double alertThreshold,
            String end) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;
        double totalPoured = 0.00, totalSold = 0.00, totalVariance = 0.00;
        double offset = 0.00;
        HashMap<Integer, String> varianceAlert = new HashMap<Integer, String>();
        String alertDescription = "";
        java.text.DecimalFormat twoDForm = new java.text.DecimalFormat("#.##");
        String start = null;

        try {
            String getStartTime = "SELECT DATE_SUB(Concat(IF(LEFT(NOW(),11) < '11:00:00', LEFT(SUBDATE(NOW(),1),11), LEFT(NOW(),11)),IFNULL(x.open, '11:00:00')), INTERVAL eO HOUR) Open, " +
                    " x.eO offset FROM " +
                    " (Select CASE DAYOFWEEK(NOW()-1000000)" +
                    " WHEN 1 THEN Right(lH.openSun,8)" +
                    " WHEN 2 THEN Right(lH.openMon,8)" +
                    " WHEN 3 THEN Right(lH.openTue,8)" +
                    " WHEN 4 THEN Right(lH.openWed,8)" +
                    " WHEN 5 THEN Right(lH.openThu,8)" +
                    " WHEN 6 THEN Right(lH.openFri,8)" +
                    " WHEN 7 THEN Right(lH.openSat,8) END open," +
                    " l.easternOffset eO" +
                    " FROM location l LEFT JOIN locationHours lH ON lH.location=l.id";

            switch (tableType) {
                case 2:
                    getStartTime += " WHERE l.id=?) AS x; ";
                    break;
                case 3:
                    getStartTime += " LEFT JOIN bar b ON l.id = b.location WHERE b.id=?) AS x; ";
                    break;
                case 6:
                    getStartTime += " LEFT JOIN bar b ON l.id = b.location WHERE b.id=?) AS x; ";
                    break;
                default:
                    getStartTime += " ) AS x;";
                    break;
            }
            stmt = transconn.prepareStatement(getStartTime);
            stmt.setInt(1, tableId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                start = rs.getString(1);
                offset = rs.getInt(2);
            }
            totalPoured = getPoured(tableId, tableType, "Daily", String.valueOf(Math.round(8 - offset)), start, end);
            totalSold = getSold(tableId, tableType, "Daily", String.valueOf(Math.round(8 - offset)), start, end);
            totalVariance = getVariance(totalPoured, totalSold);
            //logger.debug("Variance is " + twoDForm.format(totalVariance));
            if (totalVariance < alertThreshold) {
                alertDescription = "High Variance Alert\n" + getAlertDescription(tableId, tableType) + " : " + twoDForm.format(totalVariance) + "%";
                varianceAlert.put(0, alertDescription);
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

        return varianceAlert;
    }

    private HashMap<Integer, String> checkActiveAfterHoursAlert(Integer alertId, Integer tableId, Integer tableType, double alertThreshold) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String updateAlertFrequency = "UPDATE textAlert SET currentFrequency = currentFrequency + 1 WHERE id = ?";
        boolean alertSent = false;

        int locationType = getLocationType(tableId, tableType);
        int delayMin = 10;
        HashMap<Integer, String> afterHourAlert = new HashMap<Integer, String>();
        String alertDescription = "";

        try {
            String selectAlertDescription = "SELECT b.id, a.unitId, ROUND(a.value,2) FROM alerts a LEFT JOIN line l ON l.id = a.unitId LEFT JOIN bar b ON b.id = l.bar " +
                    " WHERE a.alertType = 2 AND a.status = 1 AND a.value > ? ";
            String deactivateAlerts = " UPDATE alerts SET status = 0 WHERE unitId = ?;";

            switch (tableType) {
                case 2:
                    selectAlertDescription += " AND b.location = ? ";
                    break;
                case 3:
                    selectAlertDescription += " AND b.id = ? ";
                    break;
                default:
                    selectAlertDescription += " ";
                    break;
            }
            stmt = transconn.prepareStatement(selectAlertDescription);
            stmt.setDouble(1, alertThreshold);
            stmt.setInt(2, tableId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                alertDescription = "After Hours Alert\n" + getAlertDescription(rs.getInt(1), 3) + ":" + String.valueOf(rs.getDouble(3) + "Oz");
                alertSent = true;
                switch(locationType)
                {
                    case 1:
                        afterHourAlert.put(rs.getInt(2), alertDescription);
                        break;
                    case 2:
                       if (!hasSoldTimestamp(rs.getInt(1), 3, delayMin)) {
                            afterHourAlert.put(rs.getInt(2), alertDescription);
                        } else {
                           stmt = transconn.prepareStatement(deactivateAlerts);
                           stmt.setInt(1, rs.getInt(2));
                           stmt.executeUpdate();
                        }
                        break;
                    default:
                        afterHourAlert.put(rs.getInt(2), alertDescription);
                        break;
                }
            }
            
            // Increasing the current frequency counter to stop sending additional alerts
            if (alertSent){
                stmt = transconn.prepareStatement(updateAlertFrequency);
                stmt.setInt(1, alertId);
                stmt.executeUpdate();
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

        return afterHourAlert;
    }

    private HashMap<Integer, String> checkActiveTemperatureAlert(Integer alertId, Integer tableId, Integer tableType,
            double minAlertThreshold, double maxAlertThreshold, String alertTime) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null, tempRS = null;

        HashMap<Integer, String> temperatureAlert = new HashMap<Integer, String>();
        String alertDescription = "", selectCoolerId = "", coolerName = "Unknown Cooler";
        int coolerId = 0;

        String checkForAlert = "SELECT ROUND(value,0), date FROM coolerTemperature WHERE cooler = ? AND value NOT BETWEEN ? AND ? AND date > ( CURRENT_TIMESTAMP - INTERVAL 5 MINUTE) ";
        String updateAlertFrequency = "UPDATE textAlert SET currentFrequency = currentFrequency + 1 WHERE id = ?";
        String resetAlertFrequency = "UPDATE textAlert SET currentFrequency = 0 WHERE id = ?";

        String selectTempAlertTime = "SELECT id, (date + INTERVAL 40 MINUTE), active FROM tempActiveAlertTime WHERE alertId = ?";
        String insertActiveAlertTime = "INSERT INTO tempActiveAlertTime (alertId, date) VALUES (?,?)";
        String updateActiveAlertTime = "UPDATE tempActiveAlertTime SET active = ?, date = ? WHERE id = ?";
        String deleteActiveAlertTime = "DELETE FROM tempActiveAlertTime WHERE alertId = ?";


        try {

            switch (tableType) {
                case 1:
                    selectCoolerId = " SELECT c.id, c.name FROM cooler c LEFT JOIN location l ON l.id = c.location WHERE l.customer = ? ORDER BY c.id LIMIT 1";
                    stmt = transconn.prepareStatement(selectCoolerId);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        coolerId = rs.getInt(1);
                        coolerName = rs.getString(2);
                    }
                    break;

                case 2:
                    selectCoolerId = " SELECT c.id, c.name FROM cooler c WHERE c.location = ? ORDER BY c.id LIMIT 1";
                    stmt = transconn.prepareStatement(selectCoolerId);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        coolerId = rs.getInt(1);
                        coolerName = rs.getString(2);
                    }
                    break;

                case 3:
                    selectCoolerId = " SELECT c.id, c.name FROM cooler c LEFT JOIN bar b ON b.location = c.location WHERE b.id = ? ORDER BY c.id LIMIT 1";
                    stmt = transconn.prepareStatement(selectCoolerId);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        coolerId = rs.getInt(1);
                        coolerName = rs.getString(2);
                    }
                    break;

                case 4:
                    selectCoolerId = " SELECT c.id, c.name FROM cooler c WHERE c.id = ? ORDER BY c.id LIMIT 1";
                    stmt = transconn.prepareStatement(selectCoolerId);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        coolerId = rs.getInt(1);
                        coolerName = rs.getString(2);
                    }
                    break;

                case 5:
                    selectCoolerId = " SELECT c.id, c.name FROM cooler c WHERE c.zone = ? ORDER BY c.id LIMIT 1 ";
                    stmt = transconn.prepareStatement(selectCoolerId);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        coolerId = rs.getInt(1);
                        coolerName = rs.getString(2);
                    }
                    break;

                case 6:
                    selectCoolerId = " SELECT c.id, c.name FROM cooler c LEFT JOIN bar b ON b.zone = c.zone WHERE b.id = ? ORDER BY c.id LIMIT 1 ";
                    stmt = transconn.prepareStatement(selectCoolerId);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        coolerId = rs.getInt(1);
                        coolerName = rs.getString(2);
                    }
                    coolerId = tableId;
                    break;

                case 7:
                    selectCoolerId = " SELECT c.id, c.name FROM cooler c LEFT JOIN bar b ON b.zone = c.zone LEFT JOIN station st ON st.bar = b.id WHERE st.id = ? ORDER BY c.id LIMIT 1 ";
                    stmt = transconn.prepareStatement(selectCoolerId);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        coolerId = rs.getInt(1);
                        coolerName = rs.getString(2);
                    }
                    break;

                case 8:
                    selectCoolerId = " SELECT c.id, c.name FROM cooler c LEFT JOIN system s ON s.systemId = c.system WHERE s.id = ? ORDER BY c.id LIMIT 1 ";
                    stmt = transconn.prepareStatement(selectCoolerId);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        coolerId = rs.getInt(1);
                        coolerName = rs.getString(2);
                    }
                    break;

                case 9:
                    coolerId = tableId;
                    break;

                case 10:
                    coolerId = tableId;
                    break;

                case 11:
                    selectCoolerId = " SELECT c.id FROM cooler c LEFT JOIN system s ON s.systemId = c.system LEFT JOIN line li ON li.system = s.id WHERE li.id = ? " +
                            " ORDER BY c.id LIMIT 1";
                    stmt = transconn.prepareStatement(selectCoolerId);
                    stmt.setInt(1, tableId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        coolerId = rs.getInt(1);
                        coolerName = rs.getString(2);
                    }
                    break;

                case 12:
                    coolerId = tableId;
                    break;

                case 13:
                    coolerId = tableId;
                    break;

                case 14:
                    coolerId = tableId;
                    break;

                default:
                    coolerId = tableId;
                    break;
            }

            stmt = transconn.prepareStatement(checkForAlert);
            stmt.setInt(1, coolerId);
            stmt.setDouble(2, minAlertThreshold);
            stmt.setDouble(3, maxAlertThreshold);
            rs = stmt.executeQuery();
            if (rs.next()) {
                java.util.Date currentTime = new java.util.Date();
                java.util.Date lastCheckTime = new java.util.Date();
                stmt = transconn.prepareStatement(selectTempAlertTime);
                stmt.setInt(1, alertId);
                tempRS = stmt.executeQuery();
                if (tempRS.next()) {
                    lastCheckTime = tempRS.getTimestamp(2);
                    if (tempRS.getInt(3) == 1) {
                        if (currentTime.after(lastCheckTime)) {
                            //Code for USBN alert frequency
                            alertDescription = "Temperature Alert\n" + getAlertDescription(tableId, tableType) + "\n" + coolerName + " : " + rs.getString(1) + " F";
                            temperatureAlert.put(0, alertDescription);
                            stmt = transconn.prepareStatement(updateActiveAlertTime);
                            stmt.setInt(1, 0);
                            stmt.setTimestamp(2, tempRS.getTimestamp(2));
                            stmt.setInt(3, tempRS.getInt(1));
                            stmt.executeUpdate();

                            stmt = transconn.prepareStatement(updateAlertFrequency);
                            stmt.setInt(1, alertId);
                            stmt.executeUpdate();

                        }
                    } else {
                        //Code for multiple alert frequency
                        java.text.DateFormat timeParse = new java.text.SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
                        java.util.Date alertTimeStamp = timeParse.parse(alertTime);
                        int millisecondsToWait = ((alertTimeStamp.getHours() * 60) + alertTimeStamp.getMinutes()) * 60000;
                        if (millisecondsToWait > 0) {
                            stmt = transconn.prepareStatement(updateActiveAlertTime);
                            stmt.setInt(1, 1);
                            stmt.setTimestamp(2, new java.sql.Timestamp(lastCheckTime.getTime() + millisecondsToWait));
                            stmt.setInt(3, tempRS.getInt(1));
                            stmt.executeUpdate();
                        }
                    }
                } else {
                    stmt = transconn.prepareStatement(insertActiveAlertTime);
                    stmt.setInt(1, alertId);
                    stmt.setTimestamp(2, new java.sql.Timestamp(currentTime.getTime()));
                    stmt.executeUpdate();
                }
            } else {
                stmt = transconn.prepareStatement(deleteActiveAlertTime);
                stmt.setInt(1, alertId);
                stmt.executeUpdate();

                stmt = transconn.prepareStatement(resetAlertFrequency);
                stmt.setInt(1, alertId);
                stmt.executeUpdate();
            }
        } catch (ParseException pe) {
            logger.dbError("Parse Exception: " + pe.getMessage());
            throw new HandlerException(pe);
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(tempRS);
            close(rs);
            close(stmt);
        }
        return temperatureAlert;
    }

    private HashMap<Integer, String> checkActiveCoolerTemperatureAlert(Integer tableId, Integer tableType) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;

        HashMap<Integer, String> temperatureAlert = new HashMap<Integer, String>();
        String alertDescription = "";

        try {
            String selectAlertDescription = "SELECT unitId, ROUND(value,0) FROM alerts WHERE alertType = 1 AND status = 1 AND unitId = ?";
            stmt = transconn.prepareStatement(selectAlertDescription);
            stmt.setInt(1, tableId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                alertDescription = "Temperature Alert\n" + getAlertDescription(tableId, tableType) + " : " + rs.getString(2) + " F";
                temperatureAlert.put(rs.getInt(1), alertDescription);
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
        return temperatureAlert;
    }

    private HashMap<Integer, String> checkActiveAlerts(Integer alertId, Integer alertType, Integer tableId, Integer tableType, double minAlertThreshold, double maxAlertThreshold,
            String alertTime, String alertEndTime) throws HandlerException {

        HashMap<Integer, String> activeAlerts = new HashMap<Integer, String>();

        try {
            switch (alertType) {
                case 1:
                    activeAlerts = checkActiveCoolerTemperatureAlert(tableId, tableType);
                    break;

                case 2:
                    activeAlerts = checkActiveAfterHoursAlert(alertId, tableId, tableType, maxAlertThreshold);
                    break;

                case 3:
                    activeAlerts = checkActiveInventoryAlert(alertId, tableId, tableType, alertTime);
                    break;

                case 4:
                    activeAlerts = checkActiveVarianceAlert(tableId, tableType, maxAlertThreshold, alertTime, alertEndTime);
                    break;

                case 5:
                    activeAlerts = checkActiveTemperatureAlert(alertId, tableId, tableType, minAlertThreshold, maxAlertThreshold, alertTime);
                    break;

                default:
                    activeAlerts = new HashMap<Integer, String>();
                    break;

            }


        } catch (Exception e) {
            logger.dbError("Handler error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
        }
        return activeAlerts;

    }

    /**  Return a total tap count for the requried drill down
     */
    private void getTapCount(Element toHandle, Element toAppend) throws HandlerException {

        int userId                          = HandlerUtils.getRequiredInteger(toHandle, "userId");
        int regionId                        = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int countyId                        = HandlerUtils.getOptionalInteger(toHandle, "countyId");
        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int bevSync                         = HandlerUtils.getOptionalInteger(toHandle, "bevSync");
        String state                        = HandlerUtils.getOptionalString(toHandle, "state");


        String startDate                    = HandlerUtils.getOptionalString(toHandle, "startDate");
        String endDate                      = HandlerUtils.getOptionalString(toHandle, "endDate");

        if (endDate == null || endDate.equals("")) {
            Calendar c1                     = Calendar.getInstance();
            java.util.Date d1               = c1.getTime();
            endDate                         = String.valueOf(d1.getYear() + 1900) + "-" + String.valueOf(d1.getMonth()+1) + "-" + String.valueOf(d1.getDate());
        }

        DateParameter validatedStartDate    = new DateParameter(startDate);
        DateParameter validatedEndDate      = new DateParameter(endDate);

        if (!validatedStartDate.isValid()) {
            logger.debug("Aborted report, invalid start date '" + startDate + "'");
            addErrorDetail(toAppend, "Invalid Start Date");
        } else if (!validatedEndDate.isValid()) {
            logger.debug("Aborted report, invalid end date '" + endDate + "'");
            addErrorDetail(toAppend, "Invalid End Date");
        }

        boolean getTapShareChange           = HandlerUtils.getOptionalBoolean(toHandle, "getTapShareChange");

        PreparedStatement stmt              = null;
        ResultSet rs = null, locationRS = null;

        int paramsSet = 0;

        if (regionId >= 0) {
            paramsSet++;
        } else if (countyId >= 0) {
            paramsSet++;
        } else if (locationId >= 0) {
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getTapCount.");
        }

        String conditionString = " ",specificStates=" ",specificLocation=" ";
        int parameter = -1;

        if (regionId > 0) {
            conditionString = " AND uRM.region = ? ";
            parameter       = regionId;
        } else if (countyId > 0) {
            conditionString = " AND l.countyIndex = ? ";
            parameter       = countyId;
        } else if (locationId > 0) {
            conditionString = " AND l.id = ? ";
            parameter       = locationId;
        }
         if(bevSync>0) {
            
            if (state != null && !state.equals("ALL")) {
                
                specificStates              ="AND l.addrState = '"+state+"' ";
                
            }
            if(locationId > 0) {
                
                specificLocation             =" AND l.id ="+locationId+" "; 
            }
            
        }
        

        try {
            String userLocationExclusions = "0";
            if(bevSync <1){
            String selectUserExclusions = " SELECT e.tables, e.value FROM exclusion e LEFT JOIN userExclusionMap uEM ON uEM.exclusion = e.id WHERE e.type = 2 AND uEM.user = ? ";
            
            stmt = transconn.prepareStatement(selectUserExclusions);
            stmt.setInt(1, userId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                String selectLocations = " SELECT l.id FROM location l ";
                if (rs.getString(1).equals("county")) {
                    selectLocations += " LEFT JOIN county c ON c.id = l.countyIndex WHERE c.id = ?";
                } else if (rs.getString(1).equals("location")) {
                    selectLocations += " WHERE l.id = ? ";
                }
                stmt = transconn.prepareStatement(selectLocations);
                stmt.setInt(1, Integer.valueOf(rs.getString(2)));
                locationRS = stmt.executeQuery();
                while (locationRS.next()) {
                    userLocationExclusions += ", " + locationRS.getString(1);
                }
            }
            }

            String selectTapCount           = " SELECT li.product, COUNT(l.id) FROM lineSummary lS " +
                                            " LEFT JOIN line li ON li.id = lS.line LEFT JOIN bar b ON b.id = li.bar " +
                                            " LEFT JOIN location l ON l.id = b.location LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                                            " LEFT JOIN groupRegionMap gRM ON gRM.regionMaster = rCM.region" +
                                            " LEFT JOIN region r ON r.regionGroup = gRM.id " +
                                            " LEFT JOIN userRegionMap uRM ON uRM.region = r.id " +
                                            " WHERE lD.active = 1 AND lD.data = 1 AND l.id NOT IN (" + userLocationExclusions + ") AND uRM.user = ? " +
                                            " AND lS.date = SUBDATE(?, INTERVAL 1 DAY) " + conditionString +
                                            " GROUP BY li.product " +
                                            " ORDER BY li.product ";
            
            String selectBevSyncTapCount    = " SELECT li.product, COUNT(l.id) FROM lineSummary lS " +
                                            " LEFT JOIN line li ON li.id = lS.line LEFT JOIN bar b ON b.id = li.bar " +
                                            " LEFT JOIN location l ON l.id = b.location LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE lD.active = 1 AND lD.beerboard=1 AND lD.data = 1   " +
                                            " AND lS.date = SUBDATE(?, INTERVAL 1 DAY) " + specificStates + specificLocation +
                                            " GROUP BY li.product " +
                                            " ORDER BY li.product ";
            
            if(bevSync == 1) {
                stmt = transconn.prepareStatement(selectBevSyncTapCount);
                stmt.setString(1, validatedEndDate.toString());
                
            } else {
            stmt = transconn.prepareStatement(selectTapCount);
            stmt.setInt(1, userId);
            stmt.setString(2, validatedEndDate.toString());
            if (parameter > 0) {
                stmt.setInt(3, parameter);
            }
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element tapCount = toAppend.addElement("tapCount");
                tapCount.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                tapCount.addElement("count").addText(String.valueOf(rs.getInt(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }


    /**  Return a list of all product categories
     */
    private void getGroupExclusions(Element toHandle, Element toAppend) throws HandlerException {

        int groupId = HandlerUtils.getRequiredInteger(toHandle, "groupId");
        int regionGroup = HandlerUtils.getOptionalInteger(toHandle, "regionGroup");
        int sqlParameter = 0;
        String select = null;

        int paramsSet = 0;

        if (groupId >= 0) {
            paramsSet++;
            select = " SELECT e.tables, e.field, e.value FROM exclusion e LEFT JOIN groupExclusionMap gEM ON gEM.exclusion = e.id WHERE gEM.groups=? AND gEM.regionGroup = ?";
            sqlParameter = groupId;
        }
        if (paramsSet != 1) {
            throw new HandlerException("Exactly one of the following must be set: groupId");
        }

        select += " ORDER BY e.name ";

        PreparedStatement stmt = null;
        ResultSet rs = null, rs1 = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, sqlParameter);
            if (regionGroup >= 0) {
                stmt.setInt(2, regionGroup);
            } else {
                stmt.setInt(2, 0);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                stmt = transconn.prepareStatement("SELECT id, name FROM " + rs.getString(1) + " WHERE " + rs.getString(2) + " IN ( " + rs.getString(3) + " ) ");
                rs1 = stmt.executeQuery();
                while (rs1.next()) {
                    Element exc = toAppend.addElement("groupExclusion");
                    exc.addElement("exclusionTable").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    exc.addElement("exclusionId").addText(HandlerUtils.nullToEmpty(rs1.getString(1)));
                    exc.addElement("exclusionName").addText(HandlerUtils.nullToEmpty(rs1.getString(2)));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getGroupExclusions: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getExclusions(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int groupId = HandlerUtils.getOptionalInteger(toHandle, "groupId");
        int regionGroup = HandlerUtils.getOptionalInteger(toHandle, "regionGroup");
        int sqlParameter = 0;
        String select = null, exclusionElement = null;

        int paramsSet = 0;

        if (userId >= 0) {
            paramsSet++;
            select = " SELECT uEM.id, e.id, e.name, e.tables, e.value FROM exclusion e LEFT JOIN userExclusionMap uEM ON uEM.exclusion = e.id WHERE e.type = 2 AND uEM.user=? ";
            sqlParameter = userId;
            exclusionElement = "userExclusionId";
        }

        if (regionId >= 0) {
            paramsSet++;
            select = " SELECT rEM.id, e.id, e.name, e.tables, e.value FROM exclusion e LEFT JOIN regionExclusionMap rEM ON rEM.exclusion = e.id WHERE e.type = 1 AND rEM.region=? ";
            sqlParameter = regionId;
            exclusionElement = "regionExclusionId";
        }

        if (groupId >= 0) {
            paramsSet++;
            select = " SELECT gEM.id, e.id, e.name, e.tables, e.value, gEM.regionGroup FROM exclusion e LEFT JOIN groupExclusionMap gEM ON gEM.exclusion = e.id WHERE gEM.groups=? AND gEM.regionGroup = ?";
            sqlParameter = groupId;
            exclusionElement = "groupExclusionId";
        }

        if (paramsSet != 1) {
            throw new HandlerException("Exactly one of the following must be set: userId regionId groupId");
        }

        select += " ORDER BY e.name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, sqlParameter);
            if (regionGroup >= 0) {
                stmt.setInt(2, regionGroup);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element exc = toAppend.addElement("exclusion");
                exc.addElement(exclusionElement).addText(String.valueOf(rs.getInt(1)));
                exc.addElement("exclusionId").addText(String.valueOf(rs.getInt(2)));
                exc.addElement("exclusionName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                exc.addElement("exclusionTable").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                exc.addElement("exclusionValue").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                if (groupId >= 0) {
                    exc.addElement("regionGroup").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getExclusions: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product segments
     */
    private void getSegment(Element toHandle, Element toAppend) throws HandlerException {

        int productId = HandlerUtils.getOptionalInteger(toHandle, "productId");

        String select = "SELECT s.id, s.name FROM segment s ";

        if (productId > 0) {
            select += " LEFT JOIN product p ON p.segment = s.id WHERE p.id=? ";
        }

        select += " ORDER BY name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            if (productId > 0) {
                stmt.setInt(1, productId);
            }

            rs = stmt.executeQuery();
            while (rs.next()) {
                Element cat = toAppend.addElement("segment");
                cat.addElement("id").addText(String.valueOf(rs.getInt(1)));
                cat.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getSegment: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getManualExclusions(Element toHandle, Element toAppend) throws HandlerException {

        int locationId                      = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String date                         = HandlerUtils.getOptionalString(toHandle, "date");
        
        String select                       = "SELECT eS.id, b.name, eS.date, eD.description FROM exclusionSummary eS LEFT JOIN exclusionDescription eD ON eD.id = eS.exclusion " +
                                            " LEFT JOIN bar b ON b.id = eS.bar WHERE eD.id = 4 AND eS.location = ? ";

        select += " ORDER BY eS.date ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, locationId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element excl = toAppend.addElement("exclusions");
                excl.addElement("id").addText(String.valueOf(rs.getInt(1)));
                excl.addElement("bar").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                excl.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                excl.addElement("description").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getManualExclusions: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**  Return a list of all product categories
     */
    private void getUserLocation(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int countyId = HandlerUtils.getOptionalInteger(toHandle, "countyId");

        String select = "SELECT l.id, CONCAT(SUBSTRING(c.name,1,12),'-',SUBSTRING(l.name,1,12)) Name, co.id, co.name, r.id, r.name FROM customer c " +
                " LEFT JOIN location l ON c.id=l.customer LEFT JOIN locationDetails lD ON lD.location = l.id LEFT JOIN county co ON co.id = l.countyIndex" +
                " LEFT JOIN regionCountyMap rCM ON rCM.county = co.id " +
                " LEFT JOIN groupRegionMap gRM ON gRM.regionMaster = rCM.region" +
                " LEFT JOIN region r ON r.regionGroup = gRM.id " +
                " LEFT JOIN userRegionMap uRM ON uRM.region = r.id " +
                " WHERE lD.active = 1 AND lD.data = 1 AND uRM.user = ? ";
        if (regionId > 0) {
            select += " AND uRM.region = ? ";
        }
        if (countyId > 0) {
            select += " AND rCM.county = ? ";
        }
        select += " ORDER BY Name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            int i = 1;
            stmt = transconn.prepareStatement(select);
            stmt.setInt(i++, userId);
            if (regionId > 0) {
                stmt.setInt(i++, regionId);
            }
            if (countyId > 0) {
                stmt.setInt(i++, countyId);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element uRegion = toAppend.addElement("userLocations");
                uRegion.addElement("id").addText(String.valueOf(rs.getInt(1)));
                uRegion.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                uRegion.addElement("countyId").addText(String.valueOf(rs.getInt(3)));
                uRegion.addElement("countyName").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                uRegion.addElement("regionId").addText(String.valueOf(rs.getInt(5)));
                uRegion.addElement("regionName").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getUserLocation: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getUserPreferences(Element toHandle, Element toAppend) throws HandlerException {

        int user = HandlerUtils.getRequiredInteger(toHandle, "user");
        String select = "SELECT uPM.id, uPM.home, uPM.easternOffset, uPM.unit, uPM.type FROM userPreferenceMap uPM WHERE uPM.user = ? ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, user);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element uPref = toAppend.addElement("userPref");
                uPref.addAttribute("id", HandlerUtils.nullToString(String.valueOf(rs.getInt(1)), "0"));
                uPref.addAttribute("home", HandlerUtils.nullToString(String.valueOf(rs.getInt(2)), "0"));
                uPref.addAttribute("eo", HandlerUtils.nullToString(String.valueOf(rs.getDouble(3)), "0.00"));
                uPref.addAttribute("unit", HandlerUtils.nullToString(String.valueOf(rs.getInt(4)), "0"));
                uPref.addAttribute("type", HandlerUtils.nullToString(String.valueOf(rs.getInt(5)), "0"));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getUserPreferences: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getUserDashboard(Element toHandle, Element toAppend) throws HandlerException {

        int user = HandlerUtils.getRequiredInteger(toHandle, "user");
        String select = "SELECT dC.id, dC.name FROM dashboardComponent dC LEFT JOIN userDashboardExclusionMap uDM ON uDM.dashboardComponent = dC.id WHERE uDM.user = ? ORDER BY dC.id ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, user);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element uDash = toAppend.addElement("userDC");
                uDash.addAttribute("id", HandlerUtils.nullToString(String.valueOf(rs.getInt(1)), "0"));
                uDash.addAttribute("name", HandlerUtils.nullToString(String.valueOf(rs.getString(2)), "UnKnown"));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getUserDashboard: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** RETIRED
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void sendSystemAlerts(Element toHandle, Element toAppend) throws HandlerException {

        int addAlertCount = HandlerUtils.getOptionalInteger(toHandle, "reactivateAlerts");

        String select = "SELECT id, user, emailAddr, location, noPouredAlert, pouredAlertCount FROM emailReports WHERE noPouredAlert = 1 AND time = 0";
        String selectLocations = "SELECT l.name, l.customer, c.name, l.easternOffset, l.type FROM location l left join customer c on c.id = l.customer where l.type=2 AND l.id = ? order by c.name, l.name";
        String selectLastPouredSystemPing = "SELECT DISTINCT s.id, IFNULL(s.lastPoured,'2005-01-01 00:00:00') FROM system s LEFT JOIN line l ON l.system = s.id WHERE l.status = 'RUNNING' AND s.location = ?";

        PreparedStatement stmt = null;
        ResultSet rs = null, rsLocation = null, rsSystem = null;



        try {
            // Resetting the time counter to check for active alerts for the next business day
            if (addAlertCount > 0) {
                stmt = transconn.prepareStatement("UPDATE emailReports SET time = 0 ");
                stmt.executeUpdate();
            }
            int alertId = -1, locationId = -1, customerId = -1, offSet = 0, locationType = 0;
            int hasPoured = -1;
            int pouredCount = -1;
            int pouredUp = -1;

            String emailAddr, userName, locationName, customerName;
            StringBuilder noPouredHeader = new StringBuilder();

            emailAddr = "";
            customerName = "";

            long diff = 1000 * 60 * 60 * 1;

            Calendar buff1 = Calendar.getInstance();
            diff = buff1.getTimeInMillis() - diff;

            /* Retreiving one super user information at a time*/
            stmt = transconn.prepareStatement(select);
            rs = stmt.executeQuery();
            while (rs.next()) {
                HashMap<Integer, String> pouredPingList = new HashMap<Integer, String>();

                alertId = rs.getInt(1);
                userName = rs.getString(2);
                emailAddr = rs.getString(3);
                locationId = rs.getInt(4);
                pouredUp = rs.getInt(5);
                pouredCount = rs.getInt(6);

                stmt = transconn.prepareStatement(selectLastPouredSystemPing);
                stmt.setInt(1, locationId);
                rsSystem = stmt.executeQuery();
                while (rsSystem.next()) {
                    pouredPingList.put(new Integer(rsSystem.getInt(1)), new String(rsSystem.getString(2)));
                }

                stmt = transconn.prepareStatement(selectLocations);
                stmt.setInt(1, locationId);
                rsLocation = stmt.executeQuery();
                if (rsLocation.next()) {
                    locationName = rsLocation.getString(1);
                    customerId = rsLocation.getInt(2);
                    customerName = rsLocation.getString(3);
                    offSet = rsLocation.getInt(4);
                    locationType = rsLocation.getInt(5);
                    //logger.debug("Size of pouredList: " + pouredPingList.size());
                    if ((pouredUp > 0) && (pouredCount < 4)) {
                        for (Integer system : pouredPingList.keySet()) {
                            StringBuilder noPouredList = new StringBuilder();
                            String buff = pouredPingList.get(system);
                            noPouredList.append(getPouredSystemList(system, locationName, customerName, buff, offSet, locationType));
                            if (noPouredList.length() != 0) {
                                // Incrementing pouredcount counter and time flag to stop alerts going out for the day
                                stmt = transconn.prepareStatement("UPDATE emailReports SET pouredAlertCount = ?, time = 1 WHERE id = ?");
                                stmt.setInt(1, pouredCount + 1);
                                stmt.setInt(2, alertId);
                                stmt.executeUpdate();

                                String emailTemplatePath = HandlerUtils.getSetting("email.templatePath");
                                if ((emailTemplatePath == null) || "".equals(emailTemplatePath)) {
                                    emailTemplatePath = ".";
                                }
                                logger.debug("Packaging Email to send Poured Alerts");
                                try {
                                    logger.debug("Loading Template");
                                    TemplatedMessage poEmail =
                                            new TemplatedMessage("Location Status Alert",
                                            emailTemplatePath, "locationStatusAlert");

                                    //logger.debug("Setting Template Fields to "+email+" #"+String.valueOf(purchase));
                                    poEmail.setSender("tech@usbeveragenet.com");
                                    //logger.debug("*");
                                    poEmail.setRecipient(emailAddr);
                                    poEmail.setRecipientBCC("boxalert@usbeveragenet.com");
                                    //logger.debug("*");
                                    poEmail.setField("DATE", Calendar.getInstance().getTime().toString());
                                    poEmail.setField("CUSTOMER", customerName.toString());

                                    if ((noPouredList.length() > 0)) {
                                        hasPoured = 1;
                                        poEmail.setField("NOPOUREDHEADER", noPouredHeader.toString());
                                        poEmail.setField("NOPOURED", noPouredList.toString());
                                    } else {
                                        hasPoured = -1;
                                        poEmail.setField("NOPOUREDHEADER", "");
                                        poEmail.setField("NOPOURED", "");
                                    }
                                    poEmail.setField("NOSOLDHEADER", "");
                                    poEmail.setField("NOSOLD", "");
                                    logger.debug("Sending...");
                                    logger.debug("hasPoured: " + hasPoured);
                                    if (hasPoured > 0) {
                                        poEmail.send();
                                        /*
                                        stmt = transconn.prepareStatement(updateUserAlerts);
                                        stmt.setInt(1, 1);
                                        stmt.setInt(2, alertId);
                                        stmt.executeUpdate();
                                         */
                                        logger.debug("Email sent successfully for " + userName);
                                    } else {
                                        logger.debug("Email was not sent for " + userName);
                                    }
                                } catch (MailException me) {
                                    logger.debug("Error sending purchase message to " + emailAddr + ": " + me.toString());
                                    addErrorDetail(toAppend, "Error sending mail: " + me.toString());
                                }
                            }
                        }
                    } else if (pouredCount > 3) {
                        //Setting time flag so that power-up messages go out
                        stmt = transconn.prepareStatement("UPDATE emailReports SET time = 1 WHERE id = ?");
                        stmt.setInt(1, alertId);
                        stmt.executeUpdate();
                    }

                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
            close(rsLocation);
            close(rsSystem);
        }


    }

    /**  Return a list of all product categories
     */
    private void getUserRegion(Element toHandle, Element toAppend) throws HandlerException {

        int user = HandlerUtils.getOptionalInteger(toHandle, "user");

        String select = "SELECT r.id, r.name, r.regionGroup FROM region r ";
        if (user > 0) {
            select += " LEFT JOIN userRegionMap uRM ON uRM.region = r.id WHERE uRM.user = ? ";
        }
        select += " ORDER BY r.name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            if (user > 0) {
                stmt.setInt(1, user);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element uRegion = toAppend.addElement("userRegion");
                uRegion.addElement("id").addText(String.valueOf(rs.getInt(1)));
                uRegion.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                uRegion.addElement("regionGroup").addText(String.valueOf(rs.getInt(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getUserRegion: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    //NischaySharma_24-Jun-2010_Start

    private void getProductSetsForProduct(Element toHandle, Element toAppend) throws HandlerException {
        String select = " SELECT ps.id, ps.name, ps.productSetType FROM productSet ps LEFT JOIN " +
                " productSetMap psM ON ps.id = psM.productSet " +
                " WHERE product = ? ";

        int productId = HandlerUtils.getRequiredInteger(toHandle, "productId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, productId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element pSet = toAppend.addElement("productSet");
                pSet.addElement("id").addText(String.valueOf(rs.getInt(1)));
                pSet.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                pSet.addElement("productSetType").addText(String.valueOf(rs.getInt(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductSetProduct: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    //NischaySharma_24-Jun-2010_End

    /**  Return a list of all product categories
     */
    private void getProductSetProduct(Element toHandle, Element toAppend) throws HandlerException {

        String select = "SELECT pSM.id, p.id, p.name, pSM.plu PLU FROM productSet pS LEFT JOIN productSetMap pSM ON pSM.productSet = pS.id " +
                " LEFT JOIN product p ON p.id = pSM.product WHERE p.id IS NOT NULL AND pS.id = ? ORDER BY pS.name, p.name ";

        int productSet = HandlerUtils.getRequiredInteger(toHandle, "productSet");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, productSet);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element pSet = toAppend.addElement("productSetProduct");
                pSet.addElement("productSetMapId").addText(String.valueOf(rs.getInt(1)));
                pSet.addElement("productId").addText(String.valueOf(rs.getInt(2)));
                pSet.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                pSet.addElement("productPlu").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductSetProduct: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getProductSet(Element toHandle, Element toAppend) throws HandlerException {

        String select = "SELECT p.id, p.name FROM productSet p WHERE p.productSetType = ? ORDER BY p.name ";

        int productSetType = HandlerUtils.getRequiredInteger(toHandle, "productSetType");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, productSetType);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element pSet = toAppend.addElement("productSet");
                pSet.addElement("id").addText(String.valueOf(rs.getInt(1)));
                pSet.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductSet: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getRegionMaster(Element toHandle, Element toAppend) throws HandlerException {

        String select = "SELECT rM.id, rM.name, rM.threshold FROM regionMaster rM ORDER BY rM.name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element regionMaster = toAppend.addElement("regionMaster");
                regionMaster.addElement("id").addText(String.valueOf(rs.getInt(1)));
                regionMaster.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                regionMaster.addElement("threshold").addText(String.valueOf(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getRegionMaster: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**  Return a list of all product categories
     */
    private void getProductSetType(Element toHandle, Element toAppend) throws HandlerException {

        String select = "SELECT p.id, p.name FROM productSetType p ORDER BY p.name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element psType = toAppend.addElement("productSetType");
                psType.addElement("id").addText(String.valueOf(rs.getInt(1)));
                psType.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductSetType: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getRegionProductSet(Element toHandle, Element toAppend) throws HandlerException {

        int regionId = HandlerUtils.getRequiredInteger(toHandle, "regionId");


        String select = "SELECT pS.id, pS.name FROM regionProductSet rPS LEFT JOIN productSet pS on pS.id = rPS.productSet " +
                " WHERE rPS.region = ? ORDER BY pS.name";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, regionId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element rProductSet = toAppend.addElement("groupProductSet");
                rProductSet.addElement("id").addText(String.valueOf(rs.getInt(1)));
                rProductSet.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getRegionProductSet: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getGroupProductSet(Element toHandle, Element toAppend) throws HandlerException {

        int groups = HandlerUtils.getRequiredInteger(toHandle, "groupId");

        String select = "SELECT pS.id, pS.name, pS.productSetType FROM groupProductSet gPS LEFT JOIN productSet pS on pS.id = gPS.productSet " +
                " WHERE gPS.groups = ? ORDER BY pS.name";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, groups);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element gProductSet = toAppend.addElement("groupProductSet");
                gProductSet.addElement("id").addText(String.valueOf(rs.getInt(1)));
                gProductSet.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                //NischaySharma_29-Mar-2010_Start
                gProductSet.addElement("productSetType").addText(String.valueOf(rs.getInt(3)));
                //NischaySharma_29-Mar-2010_End
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getGroupProductSet: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getGroupRegion(Element toHandle, Element toAppend) throws HandlerException {

        int groups = HandlerUtils.getRequiredInteger(toHandle, "groupId");

        String select = "SELECT rM.id, rM.name, gRM.id, gRM.threshold FROM regionMaster rM LEFT JOIN groupRegionMap gRM ON gRM.regionMaster = rM.id " +
                " WHERE gRM.groups = ? ORDER BY rM.name";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, groups);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element gRegion = toAppend.addElement("groupRegion");
                gRegion.addElement("id").addText(String.valueOf(rs.getInt(1)));
                gRegion.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                gRegion.addElement("regionGroup").addText(String.valueOf(rs.getInt(3)));
                gRegion.addElement("threshold").addText(String.valueOf(rs.getString(4)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getGroupRegion: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getGroupType(Element toHandle, Element toAppend) throws HandlerException {

        String select = "SELECT g.id, g.name FROM groupType g ORDER BY g.name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element gType = toAppend.addElement("groupType");
                gType.addElement("id").addText(String.valueOf(rs.getInt(1)));
                gType.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getGroupType: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getState(Element toHandle, Element toAppend) throws HandlerException {

        int stateId = HandlerUtils.getOptionalInteger(toHandle, "stateId");
        int stateFIPSSTId = HandlerUtils.getOptionalInteger(toHandle, "stateFIPSSTId");
        int parameter = 0, paramCount = 0;
        String select = "SELECT s.id, s.FIPSST, CONCAT(s.STNAME, ' - ', s.USPSST) State FROM state s ";
        if (stateId > 0) {
            select += " WHERE s.id = ? ";
            parameter = stateId;
            paramCount++;
        } else if (stateFIPSSTId > 0) {
            select += " WHERE s.FIPSST = ? ";
            parameter = stateFIPSSTId;
            paramCount++;
        }
        select += " ORDER BY State ";

        if (paramCount > 1) {
            throw new HandlerException("Only one of the following must " +
                    "be set: stateId OR stateFIPSSTId");
        }
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            if (parameter > 0) {
                stmt.setInt(1, parameter);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element group = toAppend.addElement("state");
                group.addElement("stateId").addText(String.valueOf(rs.getInt(1)));
                group.addElement("stateFIPSSTId").addText(String.valueOf(rs.getInt(2)));
                group.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getState: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getGroups(Element toHandle, Element toAppend) throws HandlerException {

        int groupType = HandlerUtils.getOptionalInteger(toHandle, "groupType");

        String select = "SELECT g.id, g.name, gT.name FROM groups g LEFT JOIN groupType gT ON g.type = gT.id ";
        if (groupType > 0) {
            select += " WHERE gT.id=? ";
        }
        select += " ORDER BY g.name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            if (groupType > 0) {
                stmt.setInt(1, groupType);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element group = toAppend.addElement("groups");
                group.addElement("id").addText(String.valueOf(rs.getInt(1)));
                group.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                group.addElement("groupType").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getGroups: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getCategory(Element toHandle, Element toAppend) throws HandlerException {

        int productId = HandlerUtils.getOptionalInteger(toHandle, "productId");

        String select = "SELECT c.id, c.name, c.description FROM category c ";

        if (productId > 0) {
            select += " LEFT JOIN product p ON p.category = c.id WHERE p.id=? ";
        }

        select += " ORDER BY c.name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            if (productId > 0) {
                stmt.setInt(1, productId);
            }

            rs = stmt.executeQuery();
            while (rs.next()) {
                Element cat = toAppend.addElement("category");
                cat.addElement("id").addText(String.valueOf(rs.getInt(1)));
                cat.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                cat.addElement("description").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getCategory: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getBeverageDetail(Element toHandle, Element toAppend) throws HandlerException {

        String beveragePlu = HandlerUtils.getRequiredString(toHandle, "beveragePlu");
        String beverageName = HandlerUtils.getRequiredString(toHandle, "beverageName");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int beverage = -1;
        double PartOunces = 0;
        double totalOunces = 0;
        String part;

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String selectBeverageInfo = "SELECT id, name FROM beverage WHERE plu = ? AND location = ?";

        String selectIngredient = "SELECT i.id, i.ounces, i.product FROM ingredient i WHERE i.beverage = ?";

        String selectPartSize = "SELECT ROUND(SUM(i.ounces)/COUNT(i.id),2), MIN(i.ounces) FROM ingredient i WHERE i.beverage = ?";

        String selectBeverages = "SELECT b.id, SUM(i.ounces), b.plu FROM ingredient i left join beverage b on b.id = i.beverage where b.name = ? and b.location = ? group by b.id order by b.id ;";

        try {
            stmt = transconn.prepareStatement(selectBeverageInfo);
            stmt.setString(1, beveragePlu);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                beverage = rs.getInt(1);
                toAppend.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

            stmt = transconn.prepareStatement(selectPartSize);
            stmt.setInt(1, beverage);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                PartOunces = rs.getDouble(1);
                totalOunces =
                        rs.getDouble(2);
            }

            stmt = transconn.prepareStatement(selectIngredient);
            stmt.setInt(1, beverage);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                part = String.valueOf(Double.parseDouble(rs.getString(2)) / totalOunces);
                Element line = toAppend.addElement("ingredient");
                line.addElement("id").addText(rs.getString(1));
                line.addElement("part").addText(part);
                line.addElement("product").addText(rs.getString(3));
            }

            stmt = transconn.prepareStatement(selectBeverages);
            stmt.setString(1, beverageName);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Element line = toAppend.addElement("beverage");
                line.addElement("id").addText(rs.getString(1));
                line.addElement("size").addText(rs.getString(2));
                line.addElement("plu").addText(rs.getString(3));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getProductDetail(Element toHandle, Element toAppend) throws HandlerException {

        int product = HandlerUtils.getRequiredInteger(toHandle, "productId");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String selectProductInfo = "SELECT name FROM product WHERE id=?";
        String selectLines = "SELECT bar.name, system.systemId, line.lineIndex FROM line " +
                "LEFT JOIN bar ON line.bar = bar.id " +
                "LEFT JOIN system on line.system = system.id " +
                "WHERE line.product=? AND bar.location=? AND line.status <> 'RETIRED' ";
        String selectBevs = "SELECT beverage.name, beverage.plu, ingredient.ounces " +
                "FROM beverage LEFT join ingredient " +
                "  ON ingredient.beverage = beverage.id " +
                "WHERE ingredient.product=? AND beverage.location=?";

        try {
            stmt = transconn.prepareStatement(selectProductInfo);
            stmt.setInt(1, product);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }

            stmt = transconn.prepareStatement(selectLines);
            stmt.setInt(1, product);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();

            while (rs.next()) {
                Element line = toAppend.addElement("line");
                line.addElement("bar").addText(rs.getString(1));
                line.addElement("system").addText(rs.getString(2));
                line.addElement("index").addText(rs.getString(3));
            }

            stmt = transconn.prepareStatement(selectBevs);
            stmt.setInt(1, product);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();

            while (rs.next()) {
                Element bev = toAppend.addElement("beverage");
                bev.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                bev.addElement("plu").addText(rs.getString(2));
                bev.addElement("ounces").addText(rs.getString(3));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getProductRequestsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element ProductE1 = toAppend.addElement("request");
            int colCount = 1;

            ProductE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("comment").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("userName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("userId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("locationId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("requestId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
        }

    }

    /** Retrieve a list of Product Requests
     *  Takes optional paramters for user ID and location ID.  If they are both
     *    provided, the disjunction (OR) of the two will be returned.
     *  Also takes a boolean parameter "showAll" which default to false.
     *    When false, it will only return OPEN requests
     *    Otherwise, it will return all requests except DELETED requests. Deleted
     *    requests will never be returned by this method.
     */
    private void getProductRequests(Element toHandle, Element toAppend) throws HandlerException {
        int user = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        boolean showAll = HandlerUtils.getOptionalBoolean(toHandle, "showAll", false);

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String where = " WHERE ";
        if (user > 0 && location > 0) {
            where += " (pr.location=? OR pr.user=?) AND ";
        } else if (user > 0) {
            where += " user=? AND ";
        } else if (location > 0) {
            where += " location=? AND ";
        }

        where += " pr.status" + (showAll ? "<>'deleted' " : "='open' ");

        String select =
                " SELECT pr.productName, pr.comment, pr.date, user.name, user.id, " +
                "        location.name, location.id, pr.status, pr.id " +
                " FROM productRequest AS pr " +
                " LEFT JOIN user ON pr.user = user.id " +
                " LEFT JOIN location ON pr.location = location.id " +
                where +
                " ORDER BY pr.date ";
        try {
            stmt = transconn.prepareStatement(select);
            if (user > 0 && location > 0) {
                stmt.setInt(1, location);
                stmt.setInt(2, user);
            } else if (user > 0) {
                stmt.setInt(1, user);
            } else if (location > 0) {
                stmt.setInt(1, location);
            }

            rs = stmt.executeQuery();
            getProductRequestsXML(toAppend, rs);

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getSupplierRequestsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element ProductE1 = toAppend.addElement("request");
            int colCount = 1;

            // " SELECT sr.type, sr.supplierName, sr.supplierId, sup.name, " +
            // "   sr.addrStreet, sr.addrCity, sr.addrState, sr.addrZip, " +
            // "   sr.comment, sr.date, user.name, user.id, " +
            // "   location.name, location.id, sr.status, sr.id " +

            ProductE1.addElement("requestType").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("newSupplierName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("existingSupplierId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("existingSupplierName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("addrStreet").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("addrCity").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("addrState").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("addrZip").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("comment").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("userName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("userId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("locationId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("requestId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
        }

    }

    /** Retrieve a list of Supplier Requests
     *  Takes optional parameters for user ID and location ID.  If they are both
     *    provided, the disjunction (OR) of the two will be returned.
     *  Also takes a boolean parameter "showAll" which default to false.
     *    When false, it will only return OPEN requests
     *    Otherwise, it will return all requests except DELETED requests. Deleted
     *    requests will never be returned by this method.
     */
    private void getSupplierRequests(Element toHandle, Element toAppend) throws HandlerException {
        int user = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        boolean showAll = HandlerUtils.getOptionalBoolean(toHandle, "showAll", false);

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String where = " WHERE ";
        if (user > 0 && location > 0) {
            where += " (sr.location=? OR sr.user=?) AND ";
        } else if (user > 0) {
            where += " user=? AND ";
        } else if (location > 0) {
            where += " location=? AND ";
        }

        where += " sr.status" + (showAll ? "<>'deleted' " : "='open' ");

        String select =
                " SELECT sr.type, sr.supplierName, sr.supplierId, sup.name, " +
                "   sr.addrStreet, sr.addrCity, sr.addrState, sr.addrZip, " +
                "   sr.comment, sr.date, user.name, user.id, " +
                "   location.name, location.id, sr.status, sr.id " +
                " FROM supplierRequest AS sr " +
                " LEFT JOIN user ON sr.user = user.id " +
                " LEFT JOIN location ON sr.location = location.id " +
                " LEFT JOIN supplier sup ON sr.supplierId = sup.id " +
                where +
                " ORDER BY sr.date ";
        try {
            stmt = transconn.prepareStatement(select);
            if (user > 0 && location > 0) {
                stmt.setInt(1, location);
                stmt.setInt(2, user);
            } else if (user > 0) {
                stmt.setInt(1, user);
            } else if (location > 0) {
                stmt.setInt(1, location);
            }

            rs = stmt.executeQuery();
            getSupplierRequestsXML(toAppend, rs);

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /**  Get productRequestNotifications for all users or a specific user.
     *   These alerts are for users that want an email notification when there
     *   are new Product Requests - AND - Supplier Requests.
     *
     *   Optional argment: <userId>  If provided, "single user mode" otherwise "all user mode"
     *
     *   All user mode:
     *   returns a set of <email> addresses for all the users that have requested notifications
     *   
     *   Single user mode:
     *   <email> the email address of the user
     *   <notify> 1 or 0, if the user has requested notification
     */
    private void getProductRequestNotifications(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getOptionalInteger(toHandle, "userId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String allUsers = "SELECT DISTINCT email FROM user where notifyOnProductRequest=1";
        String singleUser = "SELECT email,notifyOnProductRequest FROM user WHERE id=? LIMIT 1";

        try {
            if (userId > 0) {
                //single user mode
                stmt = transconn.prepareStatement(singleUser);
                stmt.setInt(1, userId);
                rs =
                        stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    toAppend.addElement("notify").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                } else {
                    // user id not found
                }
            } else {
                stmt = transconn.prepareStatement(allUsers);
                rs =
                        stmt.executeQuery();
                while (rs.next()) {
                    toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                }

            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductRequestNotification: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /**  Get all users who have requested location status updates
     *   
     *   args: none
     *   result:
     *   <email>address1@domain.com</email>
     *   <email>address2@domain.com</email>
     *   <email>...</email>
     *
     */
    private void getLocationStatusNotifications(Element toHandle, Element toAppend) throws HandlerException {

        String allUsers = "SELECT DISTINCT email FROM user where notifyOnLocationStatus=1";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(allUsers);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationStatusNotifications: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /**  Get all products ordered after a cutoff date or within X days (date takes priority
     */
    private void getRecentlyOrderedProducts(Element toHandle, Element toAppend) throws HandlerException {
        String cutoffDate = HandlerUtils.getOptionalString(toHandle, "date");
        int cutoffDays = HandlerUtils.getOptionalInteger(toHandle, "daysOld");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String dateCondition = "";
        if (cutoffDate != null) {
            dateCondition = " AND p.date>?";
        } else if (cutoffDays > 0) {
            dateCondition = " AND TO_DAYS(NOW())-TO_DAYS(p.date) <= ? ";
        }

        String getRecent =
                " SELECT DISTINCT pr.id, pr.name " +
                " FROM purchaseDetail d LEFT JOIN purchase p ON d.purchase=p.id " +
                "   LEFT JOIN product pr ON d.product = pr.id " +
                " WHERE p.location=? " + dateCondition;
        String getOnOrder =
                " SELECT d.product,pr.name,SUM(d.quantity) " +
                " FROM purchase p LEFT JOIN purchaseDetail d ON d.purchase=p.id " +
                " LEFT JOIN product pr ON d.product=pr.id " +
                " WHERE p.location=? AND p.status='OPEN' AND d.product IS NOT NULL " +
                " GROUP BY pr.id ";

        HashMap<Integer, String> productNames = new HashMap<Integer, String>();
        //Set<Integer> recentProducts = new HashSet<Integer>();
        HashMap<Integer, Integer> onOrder = new HashMap<Integer, Integer>();

        try {
            // get recently ordered products
            stmt = transconn.prepareStatement(getRecent);
            stmt.setInt(1, location);
            if (cutoffDate != null) {
                stmt.setString(2, cutoffDate);
            } else if (cutoffDays > 0) {
                stmt.setInt(2, cutoffDays);
            }

            rs = stmt.executeQuery();
            while (rs.next()) {
                Integer productId = new Integer(rs.getInt(1));
                String productName = rs.getString(2);
                productNames.put(productId, productName);
                //recentProducts.add(productId);
            }

// get pending orders
            stmt = transconn.prepareStatement(getOnOrder);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Integer productId = new Integer(rs.getInt(1));
                String productName = rs.getString(2);
                Integer quantity = new Integer(rs.getInt(3));
                productNames.put(productId, productName);
                onOrder.put(productId, quantity);
            }

//build the output XML
            for (Integer pkey : productNames.keySet()) {
                Element prEl = toAppend.addElement("product");
                prEl.addElement("productId").addText(String.valueOf(pkey));
                prEl.addElement("name").addText(String.valueOf(productNames.get(pkey)));
                int orderQty = 0;
                Integer checkQty = onOrder.get(pkey);
                if (checkQty != null) {
                    orderQty = checkQty.intValue();
                }

                prEl.addElement("orderQuantity").addText(String.valueOf(orderQty));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getPurchases(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "location");
        int supplier = HandlerUtils.getOptionalInteger(toHandle, "supplier");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String getPurchase =
                " SELECT purchase.id, purchase.date, purchase.total, purchase.status, supplier.name, supplier.id FROM purchase " +
                " LEFT JOIN supplier ON supplier.id = purchase.supplier " +
                " WHERE purchase.location=? AND purchase.status <> 'CANCELED' ";

        if (supplier > 0) {
            getPurchase +=
                    " AND supplier.id = ? ";
        }

        getPurchase +=
                " ORDER BY purchase.date";
        try {
            stmt = transconn.prepareStatement(getPurchase);
            stmt.setInt(1, location);
            if (supplier > 0) {
                stmt.setInt(2, supplier);
            }

            rs = stmt.executeQuery();

            while (rs.next()) {
                Element pur = toAppend.addElement("purchase");
                pur.addElement("orderNumber").addText(String.valueOf(rs.getInt(1)));
                pur.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                pur.addElement("total").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                pur.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                pur.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                pur.addElement("supplierId").addText(String.valueOf(rs.getInt(6)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /** Send an email of a single purchase order to a single address
     */
    private void emailPurchase(Element toHandle, Element toAppend) throws HandlerException {
        String email = HandlerUtils.getRequiredString(toHandle, "email");
        int purchase = HandlerUtils.getRequiredInteger(toHandle, "orderNumber");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String getPurchase =
                " SELECT supplier,date,total,status FROM purchase WHERE id=? AND location=? ";
        String getLocationDetails =
                " SELECT l.addrStreet, l.addrCity, l.addrState, l.addrZip, l.name, c.name " +
                " FROM location l LEFT JOIN customer c ON l.customer=c.id" +
                " WHERE l.id=?";
        String getDetails =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu FROM " +
                " purchaseDetail pd LEFT JOIN product pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getDetailsMisc =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu FROM " +
                " purchaseDetailMisc pd LEFT JOIN miscProduct pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getAddress =
                " SELECT s.name, sa.addrStreet, sa.addrCity, sa.addrState, sa.addrZip " +
                " FROM location l LEFT JOIN locationSupplier map ON l.id=map.location " +
                " LEFT JOIN supplierAddress sa ON map.address=sa.id " +
                " LEFT JOIN supplier s ON sa.supplier = s.id " +
                " WHERE l.id=? AND s.id=?";
        String getSupplier =
                " SELECT name FROM supplier WHERE id=? ";

        String emailTemplatePath = HandlerUtils.getSetting("email.templatePath");
        if ((emailTemplatePath == null) || "".equals(emailTemplatePath)) {
            emailTemplatePath = ".";
        }

        logger.debug("Packaging Email");

        try {
            logger.debug("Loading Template");
            TemplatedMessage poEmail =
                    new TemplatedMessage("Purchase Order",
                    emailTemplatePath,
                    "orderPrint");

            //logger.debug("Setting Template Fields to "+email+" #"+String.valueOf(purchase));
            poEmail.setSender("mailer@usbeveragenet.com");
            //logger.debug("*");
            poEmail.setRecipient(email);
            //logger.debug("*");
            poEmail.setField("ORDER_NUMBER", String.valueOf(purchase));

            //logger.debug("Connecting to Database");
            stmt =
                    transconn.prepareStatement(getPurchase);
            stmt.setInt(1, purchase);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                int supplier = rs.getInt(1);
                poEmail.setField("DATE", HandlerUtils.nullToEmpty(rs.getString(2)));
                //toAppend.addElement("totalPrice").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                //toAppend.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                //toAppend.addElement("supplierId").addText(String.valueOf(supplier));
                // get the supplier address IF the location has this supplier in its current list, otherwise just grab its name
                stmt =
                        transconn.prepareStatement(getAddress);
                stmt.setInt(1, location);
                stmt.setInt(2, supplier);
                rs =
                        stmt.executeQuery();
                if (rs.next()) {
                    //logger.debug("Setting Full Supplier Address");
                    poEmail.setField("SUPPLIER_NAME", HandlerUtils.nullToEmpty(rs.getString(1)));
                    poEmail.setField("SUPPLIER_ADDRESS1", String.valueOf(rs.getString(2)));
                    StringBuilder addr2 = new StringBuilder();
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(3)));
                    addr2.append(", ");
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(4)));
                    addr2.append(" ");
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(5)));
                    poEmail.setField("SUPPLIER_ADDRESS2", addr2.toString());
                } else {
                    // No supplier address at this location, just grab the name        
                    //logger.debug("Setting Partial Supplier Address");
                    stmt = transconn.prepareStatement(getSupplier);
                    stmt.setInt(1, supplier);
                    rs =
                            stmt.executeQuery();
                    if (rs.next()) {
                        poEmail.setField("SUPPLIER_NAME", HandlerUtils.nullToEmpty(rs.getString(1)));
                        poEmail.setField("SUPPLIER_ADDRESS1", "");
                        poEmail.setField("SUPPLIER_ADDRESS2", "");
                    }

                }

                stmt = transconn.prepareStatement(getLocationDetails);
                stmt.setInt(1, location);
                rs =
                        stmt.executeQuery();
                if (rs.next()) {
                    poEmail.setField("SHIPPING_ADDRESS1", String.valueOf(rs.getString(1)));
                    poEmail.setField("BILLING_ADDRESS1", String.valueOf(rs.getString(1)));
                    StringBuilder addr2 = new StringBuilder();

                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(2)));
                    addr2.append(", ");
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(3)));
                    addr2.append(" ");
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(4)));
                    poEmail.setField("BILLING_ADDRESS2", addr2.toString());
                    poEmail.setField("SHIPPING_ADDRESS2", addr2.toString());
                    poEmail.setField("LOCATION", HandlerUtils.nullToEmpty(rs.getString(5)));
                    poEmail.setField("CUSTOMER", HandlerUtils.nullToEmpty(rs.getString(6)));
                } else {
                    poEmail.setField("BILLING_ADDRESS1", "");
                    poEmail.setField("SHIPPING_ADDRESS1", "");
                    poEmail.setField("BILLING_ADDRESS2", "");
                    poEmail.setField("SHIPPING_ADDRESS2", "");
                }

                stmt = transconn.prepareStatement(getDetails);
                stmt.setInt(1, purchase);
                rs =
                        stmt.executeQuery();
                StringBuilder products = new StringBuilder();
                while (rs.next()) {
                    // logger.debug("Adding Draft Row");
                    products.append("<tr><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(4))); // PLU
                    products.append("</td><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Name
                    products.append("</td><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Quantity
                    products.append("</td><td /><td /></tr>");
                }

                poEmail.setField("DRAFT", products.toString());
                stmt =
                        transconn.prepareStatement(getDetailsMisc);
                stmt.setInt(1, purchase);
                rs =
                        stmt.executeQuery();
                products =
                        new StringBuilder();
                while (rs.next()) {
                    // logger.debug("Addng Nondraft Row");
                    products.append("<tr><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(4))); // PLU
                    products.append("</td><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Name
                    products.append("</td><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Quantity
                    products.append("</td><td /><td /></tr>");
                }

                poEmail.setField("NONDRAFT", products.toString());
            }

            logger.debug("Sending...");
            poEmail.send();
            logger.debug("Email sent successfully");

        } catch (SQLException sqle) {
            logger.dbError("Database error in emailPurchase: " + sqle.toString());
            throw new HandlerException(sqle);
        } catch (MailException me) {
            logger.debug("Error sending purchase message to " + email + ": " + me.toString());
            addErrorDetail(toAppend, "Error sending mail: " + me.toString());
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /** This method will return all the users that have requested email notification of
     * low-stock items, along with all the items at their locations that are low.
     * Takes no parameters; will return all users.
     */
    private void getLowStock(Element toHandle, Element toAppend) throws HandlerException {
        // a map from location ids to product-quantity maps
        Map<Integer, Map<Integer, Double>> stockCache = new HashMap<Integer, Map<Integer, Double>>();

        // a map from location ID to location name
        Map<Integer, String> locationNames = new HashMap<Integer, String>();

        // a map from a notification email address to a set of locationIds
        Map<String, Set<Integer>> users = new HashMap<String, Set<Integer>>();

        String selectUsers = " SELECT user.email, low.location " +
                " FROM lowStockNotification AS low LEFT JOIN user ON low.user=user.id " +
                " WHERE user.email IS NOT NULL AND user.email <>''";
        String selectLowStock = "SELECT product, IF(qtyOnHand < 0, 0.0, qtyOnHand) FROM inventory " +
                " WHERE location=? AND qtyOnHand < minimumQty";
        String selectName = "SELECT name FROM location WHERE id=? ";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        ProductMap prodMap = new ProductMap(transconn);
        try {
            // 1. for each user, determine which locations he is checking stock on
            stmt = transconn.prepareStatement(selectUsers);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                String email = rs.getString(1);
                Integer locId = new Integer(rs.getInt(2));
                Set<Integer> locs = users.get(email);
                if (locs == null) {
                    locs = new HashSet<Integer>();
                    users.put(email, locs);
                    logger.debug("Creating new email: " + email);
                }

                if (!locs.contains(locId)) {
                    locs.add(locId);
                    logger.debug("Adding loc# " + locId + "  for email " + email);
                }

            }

            // 2. Create the notification element for each email address (user)
            Set<String> keys = users.keySet();
            for (String address : keys) {
                logger.debug("Creating notification for " + address);
                Set<Integer> locs = users.get(address);
                Element notification = null;
                //add the low-stock at each location
                for (Integer loc : locs) {
                    //lookup the low-stock for this location
                    Map<Integer, Double> lowStock = stockCache.get(loc);
                    if (lowStock == null) { //we need to go to the database
                        lowStock = new HashMap<Integer, Double>();
                        stmt =
                                transconn.prepareStatement(selectLowStock);
                        stmt.setInt(1, loc.intValue());
                        rs =
                                stmt.executeQuery();
                        while (rs.next()) {
                            Integer product = new Integer(rs.getInt(1));
                            Double quantity = new Double(rs.getDouble(2));
                            lowStock.put(product, quantity);
                        }

                        stockCache.put(loc, lowStock);
                        logger.debug("Created new lowStock for loc#" + loc.toString() + ": " + lowStock.size() + " item(s)");
                    } else {
                        logger.debug("Retrieved cached lowStock for loc#" + loc.toString());
                    }
// now we have a non-null lowStock from db or cache

                    Element locationEl = null;
                    Set<Integer> prodKeys = lowStock.keySet();
                    for (Integer prod : prodKeys) {
                        //we may need to initialize the notification element
                        if (notification == null) {
                            notification = toAppend.addElement("notification");
                            notification.addElement("email").addText(address);
                        }
//we may need to initialize the location element

                        if (locationEl == null) {
                            locationEl = notification.addElement("location");
                            locationEl.addElement("locationId").addText(loc.toString());
                            String name = locationNames.get(loc);
                            if (name == null) {
                                stmt = transconn.prepareStatement(selectName);
                                stmt.setInt(1, loc.intValue());
                                rs =
                                        stmt.executeQuery();
                                if (rs.next()) {
                                    name = rs.getString(1);
                                    locationNames.put(loc, name);
                                    logger.debug("Put " + name + " in cache");
                                } else {
                                    name = "Unknown Location";
                                    logger.generalWarning("Unknown location in getLowStock: " + loc.toString());
                                }

                            } else {
                                logger.debug("Retrieved " + name + " from cache");
                            }

                            locationEl.addElement("locationName").addText(name);
                        }

                        Element prodEl = locationEl.addElement("product");
                        prodEl.addElement("productId").addText(prod.toString());
                        prodEl.addElement("productName").addText(prodMap.getProduct(prod));
                        prodEl.addElement("quantity").addText(lowStock.get(prod).toString());
                    }

                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getLowStock: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /** Returns a list of the locations for which a user has requested low-stock notifications
     *  Will also return that users email address, and if he has location-status updates enabled
     */
    private void getLowStockAlerts(Element toHandle, Element toAppend) throws HandlerException {
        int user = HandlerUtils.getRequiredInteger(toHandle, "userId");
        String selectAlerts = "SELECT location FROM lowStockNotification WHERE user=?";
        String selectEmail = "SELECT email,notifyOnLocationStatus FROM user WHERE id=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(selectEmail);
            stmt.setInt(1, user);
            rs =
                    stmt.executeQuery();
            String email = "";
            if (rs.next()) {
                email = rs.getString(1);
            }

            toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(email));
            toAppend.addElement("notifyStatus").addText(String.valueOf(rs.getInt(2)));
            stmt =
                    transconn.prepareStatement(selectAlerts);
            stmt.setInt(1, user);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                toAppend.addElement("location").addText(String.valueOf(rs.getInt(1)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private StringBuilder getPouredSystemList(int system, String locationName, String customerName, String buff, int offSet, int locationType) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;
        String selectBar = " SELECT DISTINCT b.name FROM line l LEFT JOIN bar b ON b.id = l.bar WHERE l.status = 'RUNNING' AND l.system = ?;";

        Calendar lastPouredTime = Calendar.getInstance();

        StringBuilder noPouredList = new StringBuilder();

        long diff = 1000 * 60 * 60 * 1;
        Calendar buff1 = Calendar.getInstance();
        diff = buff1.getTimeInMillis() - diff;
        String barNames = "";
        try {
            lastPouredTime.set(Calendar.YEAR, Integer.parseInt(buff.substring(0, 4)));
            lastPouredTime.set(Calendar.MONTH, Integer.parseInt(buff.substring(5, 7)) - 1);
            lastPouredTime.set(Calendar.DAY_OF_MONTH, Integer.parseInt(buff.substring(8, 10)));
            lastPouredTime.set(Calendar.HOUR_OF_DAY, Integer.parseInt(buff.substring(11, 13)));
            lastPouredTime.set(Calendar.MINUTE, Integer.parseInt(buff.substring(14, 16)));
            lastPouredTime.set(Calendar.SECOND, Integer.parseInt(buff.substring(17)));
            if (diff > lastPouredTime.getTimeInMillis()) {

                switch (locationType) {
                    case 1:
                        barNames = "Bars ";
                        break;
                    case 2:
                        barNames = "Stands ";
                        break;
                    default:
                        barNames = "Bars ";
                        break;
                }

                stmt = transconn.prepareStatement(selectBar);
                stmt.setInt(1, system);
                rs = stmt.executeQuery();
                int i = 1;
                while (rs.next()) {
                    if (i == 1) {
                        barNames = rs.getString(1);
                        i++;
                    } else {
                        barNames += ", " + rs.getString(1);
                    }
                }
                lastPouredTime.add(Calendar.HOUR_OF_DAY, offSet);
                noPouredList.append("<tr align=justify><td colspan=4>Your bevBox at ");
                noPouredList.append(HandlerUtils.nullToEmpty(locationName)); // Location Name
                noPouredList.append(" has <strong>not communicated draft beer pour data</strong> for ");
                noPouredList.append(HandlerUtils.nullToEmpty(barNames)); // Bar/Stand Names
                noPouredList.append(" for over an hour.</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4>Last check-in at <strong>");
                noPouredList.append(HandlerUtils.nullToEmpty((lastPouredTime.getTime().toString()).substring(0, 20))); // Last Poured Reading
                noPouredList.append("</strong></td></tr>");
                noPouredList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4>Please try unplugging the power from the bevBox and plug it back in. This will reset the bevBox. You should also ensure the Ethernet cable is plugged in properly (Green light will be on where the Ethernet cable plugs into bevBox)</td></tr>");
                noPouredList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4>Thank You,</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4>US Beverage Net Support</td></tr>");
                noPouredList.append("<tr align=center valign=middle><td height=35 colspan=4>&nbsp;</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4><strong>This email was automatically generated; please do not reply.</strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
            }
        } catch (Exception e) {
            logger.dbError("Error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(stmt);
            close(rs);
        }
        return noPouredList;
    }

    /** Creates a list of all the lines cleaned at a particular location on a particular day
     *  This list will include the name of the user that did the cleaning, the line that was cleaned, 
     *  and the time.  
     *  <locationId>
     *  <reportDate>
     *
     *  returns
     *
     *  <cleaning>
     *    <user>Joe Smith
     *    <lineProduct>Bass Ale
     *    <timestamp>2007-03-01 12:54
     *    <systemId>1  (0 indexed)
     *    <lineNumber>1 (1 indexed)
     *      
     */
    private void getLineCleaningHistory(Element toHandle, Element toAppend) throws HandlerException {
        int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        DateParameter reportDate = new DateParameter(HandlerUtils.getRequiredString(toHandle, "reportDate"));

        String query =
                " SELECT u.name, pr.name, h.timestamp, s.systemId, l.lineIndex, rr.startDate, rr.endDate, rr.value " +
                " FROM task t LEFT JOIN userHistory h ON t.id=h.task " +
                " LEFT JOIN user u ON h.user=u.id " +
                " LEFT JOIN line l ON h.target=l.id " +
                " LEFT JOIN removedReading rr ON rr.line = l.id " +
                " LEFT JOIN product pr ON l.product=pr.id " +
                " LEFT JOIN system s ON l.system=s.id " +
                " WHERE t.id=43 AND h.location=? " +
                " AND HOUR(h.timestamp) = HOUR(rr.date) " +
                " AND h.timestamp BETWEEN ? AND ? AND rr.date BETWEEN ? AND ?";


        if (!reportDate.isValid()) {
            logger.debug("Aborted getLineCleaningHistory, invalid date '" + reportDate + "'");
            addErrorDetail(toAppend, "Invalid Date");
        } else {
            String startDate = reportDate.toString() + " 00:00";
            String endDate = reportDate.toString() + " 23:59";

            PreparedStatement stmt = null;
            ResultSet rs = null;

            try {
                stmt = transconn.prepareStatement(query);
                stmt.setInt(1, locationId);
                stmt.setString(2, startDate);
                stmt.setString(3, endDate);
                stmt.setString(4, startDate);
                stmt.setString(5, endDate);
                rs =
                        stmt.executeQuery();
                while (rs.next()) {
                    int i = 1;
                    Element el = toAppend.addElement("cleaning");
                    el.addElement("user").addText(HandlerUtils.nullToString(rs.getString(i++), "Unknown User"));
                    el.addElement("lineProduct").addText(HandlerUtils.nullToString(rs.getString(i++), "Unknown Product"));
                    el.addElement("timestamp").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    el.addElement("systemId").addText(String.valueOf(rs.getInt(i++)));
                    el.addElement("lineNumber").addText(String.valueOf(1 + rs.getInt(i++)));
                    el.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    el.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    el.addElement("qty").addText(String.valueOf(rs.getDouble(i++)));

                }

            } catch (SQLException sqle) {
                logger.dbError("Database error in getLineCleaningHistory: " + sqle.toString());
                throw new HandlerException(sqle);
            } finally {
                close(stmt);
                close(rs);
            }

        }
    }

    /** By line id or location */
    private void getLastReading(Element toHandle, Element toAppend) throws HandlerException {
        int line = HandlerUtils.getOptionalInteger(toHandle, "lineId");
        int location = HandlerUtils.getOptionalInteger(toHandle, "location");
        int paramCount = 0;
        if (line > 0) {
            paramCount++;
        }

        if (location > 0) {
            paramCount++;
        }

        if (paramCount > 1) {
            throw new HandlerException("Passed too many parameters to getLastReading");
        } else if (paramCount == 0) {
            throw new HandlerException("Passed too few paramters to getLastReading");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String byLine = "SELECT date FROM readingNew WHERE line = ? AND type = 0 ORDER BY date DESC LIMIT 1";
        String byLocation = "SELECT readingNew.date FROM system " +
                " LEFT JOIN line ON line.system = system.id " +
                " LEFT JOIN readingNew ON readingNew.line = line.id " +
                " WHERE system.location=? AND readingNew.type = 0 ORDER BY readingNew.date DESC LIMIT 1";

        String powerupByLine =
                " SELECT lo.picoPowerup FROM location lo " +
                " LEFT JOIN system s ON s.location=lo.id " +
                " LEFT JOIN line ln ON ln.system=s.id " +
                " WHERE ln.id=?";
        String locationQuick = "SELECT lastPoured,picoPowerup FROM location WHERE id=?";


        try {

            if (location > 0) {
                stmt = transconn.prepareStatement(locationQuick);
                stmt.setInt(1, location);
                rs =
                        stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    toAppend.addElement("powerup").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                }

            } else {
                stmt = transconn.prepareStatement(byLine);
                stmt.setInt(1, line);
                rs =
                        stmt.executeQuery();
                while (rs.next()) {
                    toAppend.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                }

                stmt = transconn.prepareStatement(powerupByLine);
                stmt.setInt(1, line);
                rs =
                        stmt.executeQuery();
                while (rs.next()) {
                    toAppend.addElement("powerup").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /** By location */
    private void getGatewayInfo(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "location");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String sql = "SELECT lastSold, processorName, processorVersion, gatewayVersion " +
                "FROM location WHERE id=?";

        try {
            stmt = transconn.prepareStatement(sql);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("lastSold").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("processorName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("processorVersion").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                toAppend.addElement("gatewayVersion").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** Get the details of a purchase number, and lookup the supplier address that this location uses
     *  <orderNumber> 0000
     *  <locationId> 000
     *
     *  returns:
     *
     *  <date>
     *  <totalPrice>
     *  <status>
     *  <supplierId>
     *  <supplierName>
     *  <supplierAddress> 1|0   //if the suppler address is set up
     *  OPT<supplierStreet>
     *  OPT<supplierCity>
     *  OPT<supplierState>
     *  OPT<supplierZip>
     *  <product >
     *      <name>
     *      <productId>
     *      <quantity>
     *      <plu>
     *  </product>
     *  <product>...</>
     *  <product>...</>
     */
    private void getPurchaseDetail(Element toHandle, Element toAppend) throws HandlerException {
        int purchase = HandlerUtils.getRequiredInteger(toHandle, "orderNumber");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String getPurchase =
                " SELECT supplier,date,total,status FROM purchase WHERE id=? AND location=? ";
        String getDetails =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu FROM " +
                " purchaseDetail pd LEFT JOIN product pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getDetailsMisc =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu FROM " +
                " purchaseDetailMisc pd LEFT JOIN miscProduct pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getAddress =
                " SELECT s.name, sa.addrStreet, sa.addrCity, sa.addrState, sa.addrZip " +
                " FROM location l LEFT JOIN locationSupplier map ON l.id=map.location " +
                " LEFT JOIN supplierAddress sa ON map.address=sa.id " +
                " LEFT JOIN supplier s ON sa.supplier = s.id " +
                " WHERE l.id=? AND s.id=?";
        String getSupplier =
                " SELECT name FROM supplier WHERE id=? ";

        try {
            stmt = transconn.prepareStatement(getPurchase);
            stmt.setInt(1, purchase);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                int supplier = rs.getInt(1);
                toAppend.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("totalPrice").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                toAppend.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                toAppend.addElement("supplierId").addText(String.valueOf(supplier));
                // get the supplier address IF the location has this supplier in its current list, otherwise just grab its name
                stmt =
                        transconn.prepareStatement(getAddress);
                stmt.setInt(1, location);
                stmt.setInt(2, supplier);
                rs =
                        stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("supplierAddress").addText(String.valueOf(1));
                    toAppend.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    toAppend.addElement("supplierStreet").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    toAppend.addElement("supplierCity").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    toAppend.addElement("supplierState").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                    toAppend.addElement("supplierZip").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                } else {
                    // No supplier address at this location, just grab the name
                    toAppend.addElement("supplierAddress").addText(String.valueOf(0));
                    stmt =
                            transconn.prepareStatement(getSupplier);
                    stmt.setInt(1, supplier);
                    rs =
                            stmt.executeQuery();
                    if (rs.next()) {
                        toAppend.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    }

                }
                stmt = transconn.prepareStatement(getDetails);
                stmt.setInt(1, purchase);
                rs =
                        stmt.executeQuery();
                while (rs.next()) {
                    Element product = toAppend.addElement("product");
                    product.addElement("productId").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    product.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    product.addElement("quantity").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    product.addElement("plu").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                }

                stmt = transconn.prepareStatement(getDetailsMisc);
                stmt.setInt(1, purchase);
                rs =
                        stmt.executeQuery();
                while (rs.next()) {
                    Element product = toAppend.addElement("miscProduct");
                    product.addElement("productId").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    product.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    product.addElement("quantity").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    product.addElement("plu").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getPurchaseDetail: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /**
     * The folowing code is to fetch the inventory items for each location when a single beverage is selected 
     *---- SR
     */
    private void getInventoryXML(Element toAppend, ResultSet rs, boolean getDetails, boolean isCustomer) throws SQLException {
        while (rs.next()) {
            Element InventoryE1 = toAppend.addElement("inventoryItem");
            InventoryE1.addElement("inventoryId").addText(String.valueOf(rs.getInt(1)));
            InventoryE1.addElement("productId").addText(String.valueOf(rs.getInt(2)));
            InventoryE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            InventoryE1.addElement("locationId").addText(String.valueOf(rs.getInt(4)));
            InventoryE1.addElement("qtyOnHand").addText(String.valueOf(rs.getDouble(5)));
            InventoryE1.addElement("minimumQty").addText(String.valueOf(rs.getDouble(6)));
            InventoryE1.addElement("pluCode").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
            InventoryE1.addElement("qtyToOrder").addText(String.valueOf(rs.getInt(8)));
            InventoryE1.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
            InventoryE1.addElement("supplierId").addText(String.valueOf(rs.getInt(10)));
            InventoryE1.addElement("kegSize").addText(String.valueOf(rs.getInt(11)));
            InventoryE1.addElement("brixWater").addText(String.valueOf(rs.getInt(12)));
            InventoryE1.addElement("brixSyrup").addText(String.valueOf(rs.getInt(13)));
            InventoryE1.addElement("prodType").addText(String.valueOf(rs.getInt(14)));
            InventoryE1.addElement("bottleSizeId").addText(String.valueOf(rs.getInt(15)));
            InventoryE1.addElement("bottleSizeName").addText(HandlerUtils.nullToEmpty(rs.getString(16)));
            InventoryE1.addElement("coolerId").addText(HandlerUtils.nullToEmpty(rs.getString(17)));
            InventoryE1.addElement("cooler").addText(HandlerUtils.nullToEmpty(rs.getString(18)));
            InventoryE1.addElement("kegLineId").addText(HandlerUtils.nullToEmpty(rs.getString(19)));
            InventoryE1.addElement("kegLine").addText(HandlerUtils.nullToEmpty(rs.getString(20)));
            InventoryE1.addElement("segment").addText(HandlerUtils.nullToEmpty(rs.getString(21)));
            InventoryE1.addElement("category").addText(HandlerUtils.nullToEmpty(rs.getString(22)));
        }

    }

    private void getInventory(Element toHandle, Element toAppend) throws HandlerException {

        int supplierId                      = HandlerUtils.getOptionalInteger(toHandle, "supplierId");
        int refLocationId                   = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int refCustomerId                   = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int userId                          = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "location");
        int zoneId                          = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int barId                           = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int stationId                       = HandlerUtils.getOptionalInteger(toHandle, "stationId");
        int coolerId                        = HandlerUtils.getOptionalInteger(toHandle, "coolerId");
        int regionId                        = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int prodType                        = HandlerUtils.getRequiredInteger(toHandle, "prodID");
        boolean getActive                   = HandlerUtils.getOptionalBoolean(toHandle, "getActive");
        boolean getDetails                  = HandlerUtils.getOptionalBoolean(toHandle, "getDetails");

        String isActive                     = getActive ? " AND i.isActive = 1 " : " ";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        
        String select                       = "SELECT i.id, i.product, p.name, " +
                                            " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                                            " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType," +
                                            " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category " +
                                            " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product LEFT JOIN location l ON i.location = l.id " +
                                            " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id " +
                                            " LEFT JOIN kegLine AS k ON k.id = i.kegLine " +
                                            " LEFT JOIN cooler AS c ON k.cooler = c.id ";

        try {
            if (refCustomerId >= 0) {
                if (!checkForeignKey("customer", "id", refCustomerId)) {
                    throw new HandlerException("Foreign Key Not found : customer " + refCustomerId);
                }
                String selectByCustomerId   = select + " WHERE l.customer = ? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByCustomerId);
                stmt.setInt(1, refCustomerId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getInventoryXML(toAppend, rs, getDetails, true);
            } else if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " + refLocationId);
                }
                String selectByLocationId   = select + " WHERE i.location = ? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getInventoryXML(toAppend, rs, getDetails, false);
            } else if (userId >= 0) {
                if (!checkForeignKey("user", "id", userId)) {
                    throw new HandlerException("Foreign Key Not found : user " + userId);
                }
                String selectByLocationId   = select + " LEFT JOIN userMap uM ON uM.location = i.location WHERE uM.user = ? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, userId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getInventoryXML(toAppend, rs, getDetails, true);
            } else if (coolerId >= 0) {
                if (!checkForeignKey("cooler", "id", coolerId)) {
                    throw new HandlerException("Foreign Key Not found : cooler " + coolerId);
                }
                String selectByCoolerId     = select + " WHERE k.cooler = ? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByCoolerId);
                stmt.setInt(1, coolerId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getInventoryXML(toAppend, rs, getDetails, true);
            } else if (zoneId >= 0) {
                if (!checkForeignKey("zone", "id", zoneId)) {
                    throw new HandlerException("Foreign Key Not found : zone " + zoneId);
                }
                String selectByZoneId       = select + " WHERE i.location = ? AND c.zone=? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByZoneId);
                stmt.setInt(1, locationId);
                stmt.setInt(2, zoneId);
                stmt.setInt(3, prodType);
                rs                          = stmt.executeQuery();
                getInventoryXML(toAppend, rs, getDetails, true);
            } else if (barId >= 0) {
                if (!checkForeignKey("bar", "id", barId)) {
                    throw new HandlerException("Foreign Key Not found : bar " + barId);
                }
                String selectByBarId        = select + " LEFT JOIN bar ba ON ba.cooler = c.id WHERE i.location = ? AND ba.id = ? AND p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByBarId);
                stmt.setInt(1, locationId);
                stmt.setInt(2, barId);
                stmt.setInt(3, prodType);
                rs                          = stmt.executeQuery();
                getInventoryXML(toAppend, rs, getDetails, true);
            } else if (stationId >= 0) {
                if (!checkForeignKey("station", "id", stationId)) {
                    throw new HandlerException("Foreign Key Not found : station " + stationId);
                }
                String selectByStationId    = select + " LEFT JOIN bar ba ON ba.cooler = c.id LEFT JOIN station s ON s.bar = ba.id " +
                                            " WHERE i.location = ? AND s.id = ? AND p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByStationId);
                stmt.setInt(1, locationId);
                stmt.setInt(2, stationId);
                stmt.setInt(3, prodType);
                rs                          = stmt.executeQuery();
                getInventoryXML(toAppend, rs, getDetails, true);
            } else if (supplierId >= 0) {
                if (!checkForeignKey("supplier", "id", supplierId)) {
                    throw new HandlerException("Foreign Key Not found : supplier " + supplierId);
                }
                String selectBySupplierId   = select + " WHERE sup.id = ? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectBySupplierId);
                stmt.setInt(1, supplierId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getInventoryXML(toAppend, rs, getDetails, true);
            } else if (regionId >= 0) {
                if (!checkForeignKey("region", "id", regionId)) {
                    throw new HandlerException("Foreign Key Not found : region " + regionId);
                }int j = 0;
                String userLocationRequired = " ";
                Iterator i = toHandle.elementIterator("reqLocations");
                while (i.hasNext()) {
                    Element el = (Element) i.next();
                    if (j == 0) {
                        userLocationRequired += " AND l.id IN (" + String.valueOf(HandlerUtils.getRequiredInteger(el, "locationId"));
                        j++;
                    } else {
                        userLocationRequired += ", " + String.valueOf(HandlerUtils.getRequiredInteger(el, "locationId"));
                    }
                }
                if (j > 0) {
                    userLocationRequired += ") ";
                }

                String selectByRegionId     = select + " LEFT JOIN location l ON l.id = i.location LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                                            " LEFT JOIN groupRegionMap gRM ON gRM.regionMaster = rCM.region LEFT JOIN region r ON r.regionGroup = gRM.id " +
                                            " WHERE r.id = ? AND p.pType = ? " + isActive + userLocationRequired;
                stmt                        = transconn.prepareStatement(selectByRegionId);
                stmt.setInt(1, regionId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getInventoryXML(toAppend, rs, getDetails, true);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**
     * The folowing code is to fetch the inventory items for each location when a single beverage is selected 
     *---- SR
     */
    private void getReportInventoryXML(Element toAppend, ResultSet rs, boolean getDetails, boolean isCustomer) throws SQLException {
        while (rs.next()) {
            int colCount                    = 1;
            Element InventoryE1             = toAppend.addElement("inventoryItem");
            InventoryE1.addElement("inventoryId").addText(String.valueOf(rs.getInt(colCount++)));
            InventoryE1.addElement("productId").addText(String.valueOf(rs.getInt(colCount++)));
            InventoryE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            InventoryE1.addElement("prodType").addText(String.valueOf(rs.getInt(colCount++)));
            InventoryE1.addElement("locationId").addText(String.valueOf(rs.getInt(colCount++)));
            InventoryE1.addElement("qtyOnHand").addText(String.valueOf(rs.getDouble(colCount++)));
            InventoryE1.addElement("minimumQty").addText(String.valueOf(rs.getDouble(colCount++)));
            InventoryE1.addElement("qtyToOrder").addText(String.valueOf(rs.getInt(colCount++)));
            InventoryE1.addElement("kegSize").addText(String.valueOf(rs.getInt(colCount++)));
            InventoryE1.addElement("segment").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            InventoryE1.addElement("category").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            if (getDetails) {
                InventoryE1.addElement("description").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                InventoryE1.addElement("bbtvCategory").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            }
        }

    }

    private void getReportInventory(Element toHandle, Element toAppend) throws HandlerException {

        int supplierId                      = HandlerUtils.getOptionalInteger(toHandle, "supplierId");
        int refLocationId                   = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int refCustomerId                   = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int userId                          = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "location");
        int zoneId                          = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int barId                           = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int stationId                       = HandlerUtils.getOptionalInteger(toHandle, "stationId");
        int coolerId                        = HandlerUtils.getOptionalInteger(toHandle, "coolerId");
        int regionId                        = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int prodType                        = HandlerUtils.getRequiredInteger(toHandle, "prodID");
        boolean getActive                   = HandlerUtils.getOptionalBoolean(toHandle, "getActive");
        boolean getDetails                  = HandlerUtils.getOptionalBoolean(toHandle, "getDetails");

        String isActive                     = getActive ? " AND i.isActive = 1 " : " ";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        
        String select                       = "SELECT i.id, i.product, p.name, p.pType, i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), " +
                                            " i.minimumQty, i.qtyToHave, i.kegSize, p.segment, p.category, sPS.name, pD.category FROM product AS p " +
                                            " LEFT JOIN productDescription pD ON pD.product = p.id LEFT JOIN productSetMap sPSM ON sPSM.product = pD.product " +
                                            " LEFT JOIN productSet sPS ON sPS.id = sPSM.productSet " +
                                            " LEFT JOIN inventory AS i ON p.id = i.product LEFT JOIN location l ON i.location = l.id ";

        try {
            if (refCustomerId >= 0) {
                if (!checkForeignKey("customer", "id", refCustomerId)) {
                    throw new HandlerException("Foreign Key Not found : customer " + refCustomerId);
                }
                String selectByCustomerId   = select + " WHERE sPS.productSetType = 9 AND l.customer = ? and p.pType = ? " ;
                if(regionId > 0) {
                    selectByCustomerId      +=" AND l.region ="+String.valueOf(regionId);
                }
                selectByCustomerId          += isActive;
                stmt                        = transconn.prepareStatement(selectByCustomerId);
                stmt.setInt(1, refCustomerId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getReportInventoryXML(toAppend, rs, getDetails, true);
            } else if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " + refLocationId);
                }
                String selectByLocationId   = select + " WHERE sPS.productSetType = 9 AND i.location = ? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getReportInventoryXML(toAppend, rs, getDetails, false);
            } else if (userId >= 0) {
                if (!checkForeignKey("user", "id", userId)) {
                    throw new HandlerException("Foreign Key Not found : user " + userId);
                }
                String selectByLocationId   = select + " LEFT JOIN userMap uM ON uM.location = i.location WHERE sPS.productSetType = 9 AND uM.user = ? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, userId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getReportInventoryXML(toAppend, rs, getDetails, true);
            } else if (coolerId >= 0) {
                if (!checkForeignKey("cooler", "id", coolerId)) {
                    throw new HandlerException("Foreign Key Not found : cooler " + coolerId);
                }
                String selectByCoolerId     = select + " LEFT JOIN kegLine AS k ON k.id = i.kegLine WHERE sPS.productSetType = 9 AND k.cooler = ? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByCoolerId);
                stmt.setInt(1, coolerId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getReportInventoryXML(toAppend, rs, getDetails, true);
            } else if (zoneId >= 0) {
                if (!checkForeignKey("zone", "id", zoneId)) {
                    throw new HandlerException("Foreign Key Not found : zone " + zoneId);
                }
                String selectByZoneId       = select + " LEFT JOIN kegLine AS k ON k.id = i.kegLine LEFT JOIN cooler AS c ON k.cooler = c.id " +
                                            " WHERE sPS.productSetType = 9 AND i.location = ? AND c.zone=? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByZoneId);
                stmt.setInt(1, locationId);
                stmt.setInt(2, zoneId);
                stmt.setInt(3, prodType);
                rs                          = stmt.executeQuery();
                getReportInventoryXML(toAppend, rs, getDetails, true);
            } else if (barId >= 0) {
                if (!checkForeignKey("bar", "id", barId)) {
                    throw new HandlerException("Foreign Key Not found : bar " + barId);
                }
                String selectByBarId        = select + " LEFT JOIN kegLine AS k ON k.id = i.kegLine LEFT JOIN cooler AS c ON k.cooler = c.id " +
                                            " LEFT JOIN bar ba ON ba.cooler = c.id WHERE sPS.productSetType = 9 AND i.location = ? AND ba.id = ? AND p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByBarId);
                stmt.setInt(1, locationId);
                stmt.setInt(2, barId);
                stmt.setInt(3, prodType);
                rs                          = stmt.executeQuery();
                getReportInventoryXML(toAppend, rs, getDetails, true);
            } else if (stationId >= 0) {
                if (!checkForeignKey("station", "id", stationId)) {
                    throw new HandlerException("Foreign Key Not found : station " + stationId);
                }
                String selectByStationId    = select + " LEFT JOIN kegLine AS k ON k.id = i.kegLine LEFT JOIN cooler AS c ON k.cooler = c.id " +
                                            " LEFT JOIN bar ba ON ba.cooler = c.id LEFT JOIN station s ON s.bar = ba.id " +
                                            " WHERE sPS.productSetType = 9 AND i.location = ? AND s.id = ? AND p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectByStationId);
                stmt.setInt(1, locationId);
                stmt.setInt(2, stationId);
                stmt.setInt(3, prodType);
                rs                          = stmt.executeQuery();
                getReportInventoryXML(toAppend, rs, getDetails, true);
            } else if (supplierId >= 0) {
                if (!checkForeignKey("supplier", "id", supplierId)) {
                    throw new HandlerException("Foreign Key Not found : supplier " + supplierId);
                }
                String selectBySupplierId   = select + " LEFT JOIN supplier AS sup ON i.supplier = sup.id WHERE sPS.productSetType = 9 AND sup.id = ? and p.pType = ? " + isActive;
                stmt                        = transconn.prepareStatement(selectBySupplierId);
                stmt.setInt(1, supplierId);
                stmt.setInt(2, prodType);
                rs                          = stmt.executeQuery();
                getReportInventoryXML(toAppend, rs, getDetails, true);
            } 

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getLine(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getRequiredInteger(toHandle, "lineId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            String selectByLineId = "SELECT l.id, l.lineIndex, l.product, " +
                    "p.name, l.system, l.bar, l.ouncesPoured, l.unit, l.status, " +
                    "l.statusChange, -1 FROM line AS l LEFT JOIN product AS p " +
                    "ON p.id = l.product WHERE l.id = ?";
            stmt =
                    transconn.prepareStatement(selectByLineId);
            stmt.setInt(1, id);
            rs =
                    stmt.executeQuery();
            getLineXML(toAppend, rs);
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getCurrentLines(Element toHandle, Element toAppend) throws HandlerException {

        int lineId                          = HandlerUtils.getOptionalInteger(toHandle, "lineId");
        int systemId                        = HandlerUtils.getOptionalInteger(toHandle, "systemId");
        int zoneId                          = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int barId                           = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int stationId                       = HandlerUtils.getOptionalInteger(toHandle, "stationId");
        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        String getRetiredStr                = HandlerUtils.getOptionalString(toHandle, "getRetired");
        boolean getRetired                  = !("true".equalsIgnoreCase(getRetiredStr));
        
        String startDate                    = HandlerUtils.getOptionalString(toHandle, "startDate");
        String endDate                      = HandlerUtils.getOptionalString(toHandle, "endDate");
        int calibrate                       = HandlerUtils.getOptionalBoolean(toHandle, "calibrate") ?  1 : 0;
        int paramsSet                       = 0, parameter = 0;
        String tableName                    = null;
        String selectLines                  = " SELECT l.id, l.lineIndex, l.product, p.name, l.system, l.bar, l.ouncesPoured, l.unit, l.status, " +
                                            " l.statusChange, s.systemId, l.station, l.kegLine, lo.easternOffset FROM line as l LEFT JOIN product AS p ON p.id = l.product " +
                                            " LEFT JOIN bar b ON b.id = l.bar LEFT JOIN location lo ON lo.id = b.location LEFT JOIN system s ON s.id = l.system ";
        
        String selectLineOunces             ="SELECT SUM(quantity) FROM readingNew WHERE line=? AND date between ? AND ? ;";
        if (lineId >= 0) {
            paramsSet++;
            parameter                       = lineId;
            tableName                       = "line";
            selectLines                     += " WHERE l.id = ? ";
        }

        if (systemId >= 0) {
            paramsSet++;
            parameter                       = systemId;
            tableName                       = "system";
            selectLines                     += " WHERE s.id = ? ";
        }

        if (zoneId >= 0) {
            paramsSet++;
            parameter                       = zoneId;
            tableName                       = "zone";
            selectLines                     += " WHERE b.zone = ? ";
        }

        if (barId >= 0) {
            paramsSet++;
            parameter                       = barId;
            tableName                       = "bar";
            selectLines                     += " WHERE b.id = ? ";
        }

        if (stationId >= 0) {
            paramsSet++;
            parameter                       = stationId;
            tableName                       = "station";
            selectLines                     += " WHERE l.station = ? ";
        }

        if (locationId >= 0) {
            paramsSet++;
            parameter                       = locationId;
            tableName                       = "location";
            selectLines                     += " WHERE lo.id = ? ";
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one of the following parameters can be set for getCurrentLines: lineId systemId barId locationId");
        }

        PreparedStatement stmt              = null;
        ResultSet rs                        = null,rsDetails = null;

        try {
            if (!checkForeignKey(tableName, "id", parameter)) { throw new HandlerException("Foreign Key Not found : " + tableName + "-" + parameter); }
            selectLines                     += (getRetired ? "" : " AND l.status <> ?");
            stmt                            = transconn.prepareStatement(selectLines);
            stmt.setInt(1, parameter);
            if (!getRetired) { stmt.setString(2, "RETIRED"); }
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                Element lineE1                  = toAppend.addElement("line");
                lineE1.addElement("lineId").addText(String.valueOf(rs.getInt(1)));
                lineE1.addElement("lineIndex").addText(String.valueOf(rs.getInt(2)));
                lineE1.addElement("productId").addText(String.valueOf(rs.getInt(3)));
                lineE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                lineE1.addElement("systemId").addText(String.valueOf(rs.getInt(5)));
                lineE1.addElement("barId").addText(String.valueOf(rs.getInt(6)));
                lineE1.addElement("ouncesPoured").addText(String.valueOf(rs.getDouble(7)));
                lineE1.addElement("unit").addText(String.valueOf(rs.getDouble(8)));
                lineE1.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
                lineE1.addElement("lastStatusChange").addText(HandlerUtils.nullToEmpty(rs.getString(10)));
                lineE1.addElement("systemIndex").addText(String.valueOf(rs.getInt(11)));
                lineE1.addElement("stationId").addText(String.valueOf(rs.getInt(12)));
                lineE1.addElement("kegLine").addText(String.valueOf(rs.getInt(13)));
                lineE1.addElement("easternOffset").addText(HandlerUtils.nullToEmpty(rs.getString(14)));

                lineId                          = rs.getInt(1);

                if(calibrate > 0) {
                    if(lineId > 0 && startDate!=null && endDate!=null){
                        stmt                            = transconn.prepareStatement(selectLineOunces);
                        stmt.setInt(1, lineId);
                        stmt.setString(2, newDateFormat.format(dateFormat.parse(startDate)));
                        stmt.setString(3, newDateFormat.format(dateFormat.parse(endDate)));
                        rsDetails                              = stmt.executeQuery();
                        if (rsDetails.next()) {                        
                            lineE1.addElement("volume").addText(HandlerUtils.nullToString(rsDetails.getString(1),"0.0"));                            

                        }
                    }

                }
            
        }
            
           
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        }catch(Exception e) {
            logger.debug(e.getMessage());
        } 
        finally {
            close(rsDetails);
            close(rs);
            close(stmt);
        }
    }

    private void getLineXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element lineE1                  = toAppend.addElement("line");
            lineE1.addElement("lineId").addText(String.valueOf(rs.getInt(1)));
            lineE1.addElement("lineIndex").addText(String.valueOf(rs.getInt(2)));
            lineE1.addElement("productId").addText(String.valueOf(rs.getInt(3)));
            lineE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            lineE1.addElement("systemId").addText(String.valueOf(rs.getInt(5)));
            lineE1.addElement("barId").addText(String.valueOf(rs.getInt(6)));
            lineE1.addElement("ouncesPoured").addText(String.valueOf(rs.getDouble(7)));
            lineE1.addElement("unit").addText(String.valueOf(rs.getDouble(8)));
            lineE1.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
            lineE1.addElement("lastStatusChange").addText(HandlerUtils.nullToEmpty(rs.getString(10)));
            lineE1.addElement("systemIndex").addText(String.valueOf(rs.getInt(11)));
            lineE1.addElement("stationId").addText(String.valueOf(rs.getInt(12)));
            lineE1.addElement("kegLine").addText(String.valueOf(rs.getInt(13)));
            lineE1.addElement("easternOffset").addText(HandlerUtils.nullToEmpty(rs.getString(14)));
        }
    }

    private void getLineAssignments(Element toHandle, Element toAppend) throws HandlerException {

        int lineId                          = HandlerUtils.getOptionalInteger(toHandle, "lineId");
        int systemId                        = HandlerUtils.getOptionalInteger(toHandle, "systemId");
        int zoneId                          = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int barId                           = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int stationId                       = HandlerUtils.getOptionalInteger(toHandle, "stationId");
        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int customerId                      = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int regionId                        = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int userId                          = HandlerUtils.getOptionalInteger(toHandle, "userId");
        String getRetiredStr                = HandlerUtils.getOptionalString(toHandle, "getRetired");
        String specificLocationsString      = HandlerUtils.getOptionalString(toHandle, "specificLocations");
        boolean getRetired                  = !("true".equalsIgnoreCase(getRetiredStr));
        int paramsSet                       = 0, parameter = 0;
        String tableName                    = null;

        String selectLines                  = " SELECT l.id, l.station, l.bar, s.systemId, l.lineIndex, l.status, p.id, p.name, p.category, s.location, lo.name, lo.easternOffset " +
                                            " FROM line l LEFT JOIN system s ON s.id = l.system LEFT JOIN product p ON p.id = l.product " +
                                            " LEFT JOIN bar b ON b.id = l.bar LEFT JOIN location lo ON lo.id = s.location ";

        if (lineId >= 0) {
            paramsSet++;
            parameter                       = lineId;
            tableName                       = "line";
            selectLines                     += " WHERE l.product > 0 AND l.id = ? ";
        }
        if (systemId >= 0) {
            paramsSet++;
            parameter                       = systemId;
            tableName                       = "system";
            selectLines                     += " WHERE l.product > 0 AND s.id = ? ";
        }
        if (zoneId >= 0) {
            paramsSet++;
            parameter                       = zoneId;
            tableName                       = "zone";
            selectLines                     += " WHERE l.product > 0 AND b.zone = ? ";
        }
        if (barId >= 0) {
            paramsSet++;
            parameter                       = barId;
            tableName                       = "bar";
            selectLines                     += " WHERE l.product > 0 AND b.id = ? ";
        }
        if (stationId >= 0) {
            paramsSet++;
            parameter                       = stationId;
            tableName                       = "station";
            selectLines                     += " WHERE l.product > 0 AND l.station = ? ";
        }
        if (locationId >= 0) {
            paramsSet++;
            parameter                       = locationId;
            tableName                       = "location";
            selectLines                     += " WHERE l.product > 0 AND lo.id = ? ";
        }
        if (customerId >= 0) {
            paramsSet++;
            parameter                       = customerId;
            tableName                       = "customer";
            selectLines                     += " WHERE l.product > 0 AND lo.customer = ? ";
            if(regionId > 0) {
                selectLines                     += "  AND lo.region =  "+String.valueOf(regionId);
            }
        }
        if (userId >= 0) {
            paramsSet++;
            parameter                       = userId;
            tableName                       = "user";
            selectLines                     += " WHERE l.product > 0 AND lo.id IN (" + specificLocationsString + ")";
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one of the following parameters can be set for getLineAssignments: lineId systemId barId customerId locationId");
        }
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            if (!checkForeignKey(tableName, "id", parameter)) { throw new HandlerException("Foreign Key Not found : " + tableName + "-"+ parameter); }
            selectLines                     += (getRetired ? "" : " AND l.status <> ?");
            int colCount                    = 1;
            stmt                            = transconn.prepareStatement(selectLines);
            if (userId < 0) {
                stmt.setInt(colCount++, parameter);
            }
            if (!getRetired) { stmt.setString(colCount++, "RETIRED"); }
            rs                              = stmt.executeQuery();
            getLineAssignmentsXML(toAppend, rs);
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getLineAssignmentsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            int colCount                    = 1;
            Element lineE1                  = toAppend.addElement("line");
            lineE1.addElement("lineId").addText(String.valueOf(rs.getInt(colCount++)));
            lineE1.addElement("stationId").addText(String.valueOf(rs.getInt(colCount++)));
            lineE1.addElement("barId").addText(String.valueOf(rs.getInt(colCount++)));
            lineE1.addElement("systemIndex").addText(String.valueOf(rs.getInt(colCount++)));
            lineE1.addElement("lineIndex").addText(String.valueOf(rs.getInt(colCount++)));
            lineE1.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            lineE1.addElement("productId").addText(String.valueOf(rs.getInt(colCount++)));
            lineE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            lineE1.addElement("productCategory").addText(String.valueOf(rs.getInt(colCount++)));
            lineE1.addElement("locationId").addText(String.valueOf(rs.getInt(colCount++)));
            lineE1.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            lineE1.addElement("easternOffset").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
        }
    }

    /** Takes a list of products, presumably for placing an order, and adds the quicksell id.
     * If the product does not have a quicksell id, it will not be returned.  Optionally,
     * quantities may be passed along and will be returned along with the quicksell result
     *
     * @deprecated Quicksell ID is no longer used
     */
    private void lookupQuicksell(Element toHandle, Element toAppend)
            throws HandlerException {
        String select = "SELECT qid FROM product WHERE id=?";
        PreparedStatement stmt = null;
        ResultSet rs = null;

        Iterator i = toHandle.elementIterator("product");
        try {
            while (i.hasNext()) {
                Element item = (Element) i.next();
                stmt =
                        transconn.prepareStatement(select);
                int usbnId = HandlerUtils.getRequiredInteger(item, "id");
                stmt.setInt(1, usbnId);
                rs =
                        stmt.executeQuery();
                if (rs.next()) {
                    int quicksellId = rs.getInt(1);
                    if (quicksellId > 0) {
                        Element append = toAppend.addElement("product");
                        append.addElement("quicksellId").addText(String.valueOf(quicksellId));
                        append.addElement("usbnId").addText(String.valueOf(usbnId));
                        int qty = HandlerUtils.getOptionalInteger(item, "quantity");
                        if (qty > 0) {
                            append.addElement("quantity").addText(String.valueOf(qty));
                        }

                        String price = HandlerUtils.getOptionalString(item, "price");
                        if (price != null && !price.equals("")) {
                            append.addElement("price").addText(price);
                        }

                        String plu = HandlerUtils.getOptionalString(item, "plu");
                        if (plu != null && !plu.equals("")) {
                            append.addElement("plu").addText(plu);
                        }

                    }
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Obtain a list of the user-defined beverage sizes for a location
     *
     *  required arguments:
     *  <locationId>
     *
     *  returns:
     *  <size>
     *    <id>int</id>
     *    <name>String</name>
     *    <ounces>00.0</ounces>
     *  </size>
     *  <size>...</size>
     *
     */
    private void getBeverageSizes(Element toHandle, Element toAppend)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        String select = "SELECT id,name,ounces FROM beverageSize WHERE location=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Element size = toAppend.addElement("size");
                size.addElement("id").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                size.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                size.addElement("ounces").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getBeverageSizes: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /**  Gets all beverages at a location
     *  This method now has an optional 'barId' param 
     *  If this is set, then only beverage matching this bar will be returned.  If this
     *  field is NOT set, then all beverages will be returned, regardless if they
     *  are associated with a specific bar or null
     *
     *  BarId 'b' supplied   =  Only beverages of bar 'b'
     *  BarId 'b' null       =  All beverages, including bar=null and bar='x'
     */
    private void getBeverages(Element toHandle, Element toAppend)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int barId = HandlerUtils.getOptionalInteger(toHandle, "barId");

        String selectBeverages = "SELECT name,plu,id,simple FROM beverage WHERE location=? " + (barId > 0 ? " AND bar=?" : "");
        String selectIngredients = "SELECT product.name, product.id, ingredient.ounces " +
                "FROM ingredient LEFT JOIN product on ingredient.product = product.id " +
                "WHERE ingredient.beverage=?";


        PreparedStatement stmt = null;
        ResultSet bev = null;
        ResultSet ing = null;

        try {
            stmt = transconn.prepareStatement(selectBeverages);
            stmt.setInt(1, location);
            if (barId > 0) {
                stmt.setInt(2, barId);
            }

            bev = stmt.executeQuery();
            while (bev.next()) {
                Element beverage = toAppend.addElement("beverage");
                beverage.addElement("name").addText(HandlerUtils.nullToEmpty(bev.getString(1)));
                beverage.addElement("plu").addText(HandlerUtils.nullToEmpty(bev.getString(2)));
                beverage.addElement("simple").addText(HandlerUtils.nullToEmpty(bev.getString(4)));
                stmt =
                        transconn.prepareStatement(selectIngredients);
                stmt.setInt(1, bev.getInt(3));
                ing =
                        stmt.executeQuery();
                while (ing.next()) {
                    Element ingredient = beverage.addElement("ingredient");
                    ingredient.addElement("name").addText(HandlerUtils.nullToEmpty(ing.getString(1)));
                    ingredient.addElement("id").addText(HandlerUtils.nullToEmpty(ing.getString(2)));
                    ingredient.addElement("ounces").addText(HandlerUtils.nullToEmpty(ing.getString(3)));

                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(ing);
            close(bev);
            close(stmt);
        }

    }

    /**  
     *   1. Suppliers:  How many suppliers are associated with this location
     *          warnings:   A. products in inventory that reference a supplier that doesn't exist
     *                      B. Addresses that have been deemed inactive
     *   2. Inventory:  How many products in inventory
     *          warnings:   A. Active lines that reference products not in inv
     *                      B. Beverages reference products not in inv
     *   3. Draft Lines: How many systems / lines
     *          warnings:   A. Lines that are pouring the same product
     *                      B. Products in inv that are not being poured
     *   4. Beverages: How many beverages
     *          warnings:   A. Products in inventory that aren't in beverages
     *
     *  Warning fall into three severity categories.
     *  Warning 1 - Mild, doesn't need to be corrected, could be correct anyways.
     *      Example:  Two lines are pouring the same product
     *  Warning 2 - Normal, indicates an inconsistency, should be corrected, but won't cause any problems.
     *      Example:  Beverages containing products not in inventory.
     *  Warning 3 - Severe, should be correct immediately.  May cause further problems if unchecked
     *      Example:  Draft line pouring a product not in inventory.
     */
    private void getSetupInfo(Element toHandle, Element toAppend)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        String supCheck = "SELECT COUNT(DISTINCT id) FROM locationSupplier WHERE location=?";
        String invCheck = "SELECT COUNT(DISTINCT id) FROM inventory WHERE location=?";
        String lineCheck = "SELECT COUNT(DISTINCT line.id), COUNT(DISTINCT system.id) FROM line " +
                " LEFT JOIN system ON line.system = system.id " +
                " WHERE system.location=? AND line.status='RUNNING'";
        String beverageCheck = "SELECT COUNT(DISTINCT id) FROM beverage WHERE location=?";
        String nondraftCheck = "SELECT COUNT(DISTINCT id) FROM miscProduct WHERE location=? AND active=1";

        // TODO:  Supplier Warnng Checks!
        // TODO:  Nondraft Warning Checks

        // Checks for BEVERAGES that contain products that AREN'T in INVENTORY (Sev 2)
        //    Recommended fix is to add this product to inventory OR delete the beverage
        String invBevWarning = //(location, location) returns (productId, beverageName)
                " SELECT ing.product, bev.name, bev.id " +
                " FROM ingredient AS ing LEFT JOIN beverage AS bev ON ing.beverage = bev.id" +
                " WHERE bev.location=? AND " +
                " ing.product NOT IN " +
                "   (SELECT inventory.product " +
                "    FROM inventory " +
                "    WHERE inventory.location=? " +
                "   ) ";

        // Checks for running LINES pouring products that AREN'T in INVENTORY (Sev 3)
        // recommended fix is to add the product to inventory
        String invLineWarning = //(location, location) returns (productId)
                " SELECT line.product " +
                " FROM line LEFT JOIN system ON line.system = system.id " +
                " WHERE system.location=? AND line.status='RUNNING' AND " +
                " line.product NOT IN " +
                "   (SELECT inventory.product " +
                "    FROM inventory " +
                "    WHERE inventory.location=? " +
                "   ) ";

        // Checks for draft lines that are pouring the same product (Sev 1)
        // recommended fix: none (S1)
        String lineDuplicateWarning = // (location) returns (productId, lineCount)
                " SELECT line.product, count(*) AS lineCount " +
                " FROM line LEFT JOIN system ON line.system = system.id " +
                " WHERE system.location=? AND line.product >0 AND line.status='RUNNING' " +
                " GROUP BY product HAVING lineCount > 1";

        // Checks for items in inventory that are not being poured.   (Sev 1)
        // recommended fix: none (S1)
        String lineInvWarning = // (location,location) returns (productId)
                " SELECT inv.product " +
                " FROM inventory AS inv " +
                " WHERE inv.location=? AND " +
                " inv.product NOT IN " +
                "   (SELECT line.product " +
                "    FROM line LEFT JOIN system ON line.system = system.id " +
                "    WHERE system.location=? AND line.status <> 'RETIRED' " +
                "   ) ";

        // Checks for INVENTORY items without any BEVERAGES (Sev 1)
        // recommended fix: none (S1)
        String bevInvWarning = // (location,location) returns (productId)
                " SELECT inv.product " +
                " FROM inventory AS inv " +
                " WHERE inv.location=? AND " +
                " inv.product NOT IN " +
                "   (SELECT distinct ing.product " +
                "    FROM ingredient AS ing " +
                "    LEFT JOIN beverage AS bev ON ing.beverage = bev.id " +
                "    WHERE bev.location=?" +
                "   ) ";

        /* Other check ideas:  Lines paused for over X days (3?)
         */


        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {

            //First do the basic counts:

            stmt = transconn.prepareStatement(supCheck);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("suppliers").addText(String.valueOf(rs.getInt(1)));
            }

            stmt = transconn.prepareStatement(invCheck);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("invProducts").addText(String.valueOf(rs.getInt(1)));
            }

            stmt = transconn.prepareStatement(lineCheck);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("draftLines").addText(String.valueOf(rs.getInt(1)));
                toAppend.addElement("systems").addText(String.valueOf(rs.getInt(2)));
            }

            stmt = transconn.prepareStatement(beverageCheck);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("beverages").addText(String.valueOf(rs.getInt(1)));
            }

            stmt = transconn.prepareStatement(nondraftCheck);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("nondraft").addText(String.valueOf(rs.getInt(1)));
            }

//Set up a product map
            ProductMap nameLookup = new ProductMap(transconn);

            //Do warnings
            stmt =
                    transconn.prepareStatement(invBevWarning);
            stmt.setInt(1, location);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("2");
                warnEl.addElement("warningId").addText("10");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                warnEl.addElement("beverageId").addText(String.valueOf(rs.getInt(3)));
                String detail = nameLookup.getProduct(rs.getInt(1)) + " isn't in inventory, but is " +
                        " used in beverage " + rs.getString(2);
                warnEl.addElement("detail").addText(detail);
            }

            logger.debug("invBevWarning check complete");

            stmt =
                    transconn.prepareStatement(invLineWarning);
            stmt.setInt(1, location);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("3");
                warnEl.addElement("warningId").addText("11");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                String detail = nameLookup.getProduct(rs.getInt(1)) + " is on a draft line, but not in inventory";
                warnEl.addElement("detail").addText(detail);
            }

            logger.debug("invLineWarning check complete");

            stmt =
                    transconn.prepareStatement(lineDuplicateWarning);
            stmt.setInt(1, location);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("1");
                warnEl.addElement("warningId").addText("12");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                warnEl.addElement("lineCount").addText(String.valueOf(rs.getInt(2)));
                String detail = rs.getInt(2) + " draft lines are pouring " + nameLookup.getProduct(rs.getInt(1));
                warnEl.addElement("detail").addText(detail);
            }

            logger.debug("lineDuplicateWarning check complete");

            stmt =
                    transconn.prepareStatement(lineInvWarning);
            stmt.setInt(1, location);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("1");
                warnEl.addElement("warningId").addText("13");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                String detail = nameLookup.getProduct(rs.getInt(1)) + " is in inv but has no draft line.";
                warnEl.addElement("detail").addText(detail);
            }

            logger.debug("lineInvWarning check complete");

            stmt =
                    transconn.prepareStatement(bevInvWarning);
            stmt.setInt(1, location);
            stmt.setInt(2, location);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("1");
                warnEl.addElement("warningId").addText("14");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                String detail = nameLookup.getProduct(rs.getInt(1)) + " is in inv but has no associated beverages.";
                warnEl.addElement("detail").addText(detail);
            }

            logger.debug("bevInvWarning check complete");

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** Return all the normal users and their permission level for a specific location's customer.
     *    Only users who are NOT admins or supermanagers will be returned.
     *    For example, if Location 3 belongs to Customer 1, and Loc 3 is passed,
     *    the all the normal users for Customer 1 will be returned, along with their
     *    permission level for Loc 3, including users that have "no access" to Loc 3.
     */
    private void getNormalUsers(Element toHandle, Element toAppend) throws HandlerException {

        int platform = HandlerUtils.getRequiredInteger(toHandle, "platform");

        String getCustomer = "SELECT customer FROM location WHERE id=?";

        String getBevSyncUsers = " SELECT u.id, u.name, u.email, g.name FROM user u LEFT JOIN userGroupMap uGM ON uGM.user=u.id " +
                " LEFT JOIN groups g ON g.id = uGM.groups ";

        String getUsers = " SELECT u.id, u.name, u.email, m.securityLevel " +
                " FROM user u LEFT JOIN userMap m ON m.user=u.id " +
                " WHERE u.isManager=0 AND u.isITAdmin=0 AND u.customer=? AND m.location=? " +
                " UNION " +
                " SELECT u2.id, u2.name, u2.email, 10 " +
                " FROM user u2 " +
                " WHERE u2.isManager=0 AND u2.isITAdmin=0 AND u2.customer=? and u2.id not in " +
                "      (SELECT user FROM userMap WHERE location=?)";

        String getUserAuth = "SELECT emailReports FROM user WHERE id=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        PreparedStatement stmt1 = null;
        ResultSet rs1 = null;
        try {

            switch (platform) {
                case 1:
                    int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");
                    int customerId;
                    stmt = transconn.prepareStatement(getCustomer);
                    stmt.setInt(1, locationId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        customerId = rs.getInt(1);
                        getUsers += " ORDER BY u.name ";
                        stmt = transconn.prepareStatement(getUsers);
                        int index = 0;
                        stmt.setInt(++index, customerId);
                        stmt.setInt(++index, locationId);
                        stmt.setInt(++index, customerId);
                        stmt.setInt(++index, locationId);
                        rs = stmt.executeQuery();
                        while (rs.next()) {
                            index = 0;
                            int userId = rs.getInt(++index);
                            String fullName = rs.getString(++index);
                            String email = rs.getString(++index);
                            int securityLevel = rs.getInt(++index);
                            if (securityLevel < 1) {
                                securityLevel = 10;
                            }
                            stmt1 = transconn.prepareStatement(getUserAuth);
                            stmt1.setInt(1, userId);
                            String userAuth = "";
                            rs1 = stmt1.executeQuery();
                            if (rs1.next()) {
                                userAuth = rs1.getString(1);
                            }
                            Element userEl = toAppend.addElement("user");
                            userEl.addElement("fullName").addText(HandlerUtils.nullToEmpty(fullName));
                            userEl.addElement("userId").addText(String.valueOf(userId));
                            userEl.addElement("email").addText(String.valueOf(email));
                            userEl.addElement("permission").addText(String.valueOf(securityLevel));
                            userEl.addElement("userAuth").addText(String.valueOf(userAuth));
                        }
                    }
                    break;
                case 2:
                    int groupId = HandlerUtils.getOptionalInteger(toHandle, "groupId");
                    if (groupId > 0) {
                        getBevSyncUsers += " WHERE g.id = ? ";
                    }
                    getBevSyncUsers += " ORDER BY u.name ";
                    stmt = transconn.prepareStatement(getBevSyncUsers);
                    if (groupId > 0) {
                        stmt.setInt(1, groupId);
                    }
                    rs = stmt.executeQuery();
                    while (rs.next()) {
                        Element userEl = toAppend.addElement("user");
                        userEl.addElement("userId").addText(String.valueOf(rs.getInt(1)));
                        userEl.addElement("fullName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                        userEl.addElement("email").addText(String.valueOf(rs.getString(3)));
                        userEl.addElement("groupName").addText(String.valueOf(rs.getString(4)));
                    }
                    break;
                case 3:
                    break;
                default:
                    break;
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
            close(rs1);
            close(stmt1);
        }

    }

    /** Return all customer-managers for a specific customer
     */
    private void getAdminUsers(Element toHandle, Element toAppend)
            throws HandlerException {

        int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");

        String getCustomer = " SELECT id,name FROM user WHERE customer=? AND isManager=1 ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(getCustomer);
            stmt.setInt(1, customerId);
            rs =
                    stmt.executeQuery();
            while (rs.next()) {
                Element userEl = toAppend.addElement("user");
                userEl.addElement("userId").addText(String.valueOf(rs.getInt(1)));
                userEl.addElement("fullName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** Returns information about a single user.  The caller must pass their own
     *  userid to verify that they belong to the same customer.
     *
     * This method will return the username, fullname, emailAddress, manager status,
     * and location permissions (if applicable).
     *
     */
    private void getUserDetail(Element toHandle, Element toAppend) throws HandlerException {
        int callerId = getCallerId(toHandle);
        int targetId = HandlerUtils.getRequiredInteger(toHandle, "targetId");

        String getUser =
                " SELECT name, username, email, customer, groupId, isManager, mobile, carrier, unit" +
                " FROM user WHERE id = ?";
        String getMap =
                " SELECT l.name, l.id, m.securityLevel FROM userMap m" +
                " LEFT JOIN location l ON m.location = l.id " +
                " WHERE m.user = ? ORDER BY l.name";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            int callerCust = -1, groupId = -1;

            stmt = transconn.prepareStatement(getUser);
            stmt.setInt(1, callerId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                callerCust = rs.getInt(4);
                groupId = rs.getInt(5);
            }

            stmt = transconn.prepareStatement(getUser);
            stmt.setInt(1, targetId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                String name = rs.getString(1);
                String username = rs.getString(2);
                String email = rs.getString(3);
                int customer = rs.getInt(4);
                int group = rs.getInt(5);
                int isManager = rs.getInt(6);
                String mobile = rs.getString(7);
                String carrier = rs.getString(8);
                int unit = rs.getInt(9);

                //check that the caller should be able to see this info
                if (callerCust == 0 || callerCust == customer || ((groupId > 0) && (groupId == group))) {
                    toAppend.addElement("fullName").addText(HandlerUtils.nullToEmpty(name));
                    toAppend.addElement("username").addText(HandlerUtils.nullToEmpty(username));
                    toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(email));
                    toAppend.addElement("mobile").addText(HandlerUtils.nullToEmpty(mobile));
                    toAppend.addElement("carrier").addText(HandlerUtils.nullToEmpty(carrier));
                    toAppend.addElement("isManager").addText(String.valueOf(isManager));
                    toAppend.addElement("unit").addText(String.valueOf(unit));
                    if (isManager == 0) {
                        stmt = transconn.prepareStatement(getMap);
                        stmt.setInt(1, targetId);
                        rs = stmt.executeQuery();
                        while (rs.next()) {
                            Element permEl = toAppend.addElement("location");
                            permEl.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                            permEl.addElement("locationId").addText(String.valueOf(rs.getInt(2)));
                            permEl.addElement("permission").addText(String.valueOf(rs.getInt(3)));
                        }
                    }
                } else {
                    addErrorDetail(toAppend, "You don't have permission to view this user");
                    logger.portalAccessViolation("Permission problem: Tried to getUserDetail on " + targetId + " by " + callerId);
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**
     * The folowing code is to get user email info for sending email reports - SR
     */
    private void getUserEmailInfo(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        int customerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int barId = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int userId = HandlerUtils.getOptionalInteger(toHandle, "userId");
        double easternOffset = HandlerUtils.getOptionalInteger(toHandle, "offset");
        int paramsSet = 0, bar = 0, location = 0, customer = 0, region = 0;
        ArrayList<Integer> inactiveLocations = new ArrayList<Integer>();
        String select = " SELECT eR.tableId, eR.tableType, eR.id, eR.report, u.id, u.isManager, u.email, eR.tableValues, eR.minAlertThreshold, eR.maxAlertThreshold, " +
                " eR.time, eR.platform, eR.reportFormat FROM emailReport eR LEFT JOIN user u ON eR.user = u.id ";
        String selectInactiveLocations = "SELECT location FROM locationDetails WHERE active = 0";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(selectInactiveLocations);
            rs = stmt.executeQuery();
            while (rs.next()) {
                inactiveLocations.add(rs.getInt(1));
            }

            if (customerId > 0) {
                //NischaySharma_12-Jul-2010_Start
                select += " WHERE eR.tableId = 1 AND eR.tableId = ? AND u.id IS NOT NULL ORDER BY eR.report, eR.user ";
                stmt = transconn.prepareStatement(select);
                stmt.setInt(1, customerId);
                paramsSet++;
            } else if (locationId > 0) {
                select += " WHERE eR.tableId = 2 AND eR.tableId = ? AND u.id IS NOT NULL ORDER BY eR.report, eR.user ";
                stmt = transconn.prepareStatement(select);
                stmt.setInt(1, locationId);
                paramsSet++;
            } else if (barId > 0) {
                select += " WHERE eR.tableId = 3 AND eR.tableId = ? AND u.id IS NOT NULL ORDER BY eR.report, eR.user ";
                stmt = transconn.prepareStatement(select);
                stmt.setInt(1, barId);
                paramsSet++;
            } else if (userId > 0) {
                select += " WHERE eR.user = ? AND u.id IS NOT NULL ORDER BY eR.report, eR.user ";
                stmt = transconn.prepareStatement(select);
                stmt.setInt(1, userId);
                paramsSet++;
            } else if (easternOffset > 0.00) {
                select += " LEFT JOIN location l ON l.id = eR.tableId " +
                        " WHERE eR.tableId = 2 AND l.easternOffset = ? AND u.id IS NOT NULL ORDER BY eR.report, eR.user ";
                //NischaySharma_12-Jul-2010_End
                stmt = transconn.prepareStatement(select);
                stmt.setDouble(1, easternOffset);
                paramsSet++;
            } else {
                select += " WHERE u.id IS NOT NULL ";
                stmt = transconn.prepareStatement(select);
            }

            if (paramsSet > 1) {
                throw new HandlerException("Only one parameter can be set for getUserEmailInfo.");
            }

            rs = stmt.executeQuery();
            while (rs.next()) {
                int colCount = 1;
                int tableId = rs.getInt(colCount++);
                int tableType = rs.getInt(colCount++);
                if ((tableType==2) && inactiveLocations.contains(tableId)) { continue; }
                Element userReportEl = toAppend.addElement("userReportInfo");
                userReportEl.addElement("reportId").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("report").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("user").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("isManager").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("emailAddr").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                switch (tableType) {
                    case 1:
                        region = 0;
                        bar = 0;
                        location = 0;
                        customer = tableId;
                        break;
                    case 2:
                        region = 0;
                        bar = 0;
                        location = tableId;
                        customer = CustomerMap.staticLookupByLocation(location, transconn);
                        break;
                    case 3:
                        region = 0;
                        bar = tableId;
                        location = LocationMap.staticLookupByBar(bar, transconn);
                        customer = CustomerMap.staticLookupByLocation(location, transconn);
                        break;
                    case 13:
                        region = tableId;
                        bar = 0;
                        location = 0;
                        customer = 0;
                        break;
                    default:
                        region = 0;
                        bar = 0;
                        location = 0;
                        customer = 0;
                        break;
                }
                userReportEl.addElement("bar").addText(String.valueOf(bar));
                userReportEl.addElement("location").addText(String.valueOf(location));
                userReportEl.addElement("customer").addText(String.valueOf(customer));
                userReportEl.addElement("region").addText(String.valueOf(region));
                userReportEl.addElement("tableValues").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                userReportEl.addElement("minAlertThreshold").addText(String.valueOf(rs.getDouble(colCount++)));
                userReportEl.addElement("maxAlertThreshold").addText(String.valueOf(rs.getDouble(colCount++)));
                userReportEl.addElement("customTime").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("platform").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("reportFormat").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }
    
    
    private void getUserEmailDetails(Element toHandle, Element toAppend) throws HandlerException {

        int callerId                        = getCallerId(toHandle);
        int reportId                        = HandlerUtils.getRequiredInteger(toHandle, "reportId");
        int paramsSet                       = 0, bar = 0, location = 0, customer = 0, region = 0;
        ArrayList<Integer> inactiveLocations 
                                            = new ArrayList<Integer>();
        String select                       = " SELECT eR.tableId, eR.tableType, eR.id, eR.report, u.id, u.isManager, u.email, eR.tableValues, eR.minAlertThreshold, eR.maxAlertThreshold, " +
                                              " eR.time, eR.platform, eR.reportFormat FROM emailReport eR LEFT JOIN user u ON eR.user = u.id ";
        String selectInactiveLocations      = "SELECT location FROM locationDetails WHERE active = 0";

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            stmt                            = transconn.prepareStatement(selectInactiveLocations);
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                inactiveLocations.add(rs.getInt(1));
            }

            if (reportId > 0) {
                select                      += " WHERE eR.report = ?  AND u.id IS NOT NULL ORDER BY eR.report, eR.user ";
                
                stmt                        = transconn.prepareStatement(select);
                stmt.setInt(1, reportId);
                paramsSet++;
            } else {
                select                      += " WHERE u.id IS NOT NULL ";
                stmt                        = transconn.prepareStatement(select);
            }

            if (paramsSet > 1) {
                throw new HandlerException("Only one parameter can be set for getUserEmailInfo.");
            }

            rs = stmt.executeQuery();
            while (rs.next()) {
                int colCount                = 1;
                int tableId                 = rs.getInt(colCount++);
                int tableType               = rs.getInt(colCount++);
                if ((tableType==2) && inactiveLocations.contains(tableId)) { continue; }
                Element userReportEl        = toAppend.addElement("userReportDetails");
                userReportEl.addElement("reportId").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("report").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("user").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("isManager").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("emailAddr").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                switch (tableType) {
                    case 1:
                        region              = 0;
                        bar                 = 0;
                        location            = 0;
                        customer            = tableId;
                        break;
                    case 2:
                        region              = 0;
                        bar                 = 0;
                        location            = tableId;
                        customer            = CustomerMap.staticLookupByLocation(location, transconn);
                        break;
                    case 3:
                        region              = 0;
                        bar                 = tableId;
                        location            = LocationMap.staticLookupByBar(bar, transconn);
                        customer            = CustomerMap.staticLookupByLocation(location, transconn);
                        break;
                    case 13:
                        region              = tableId;
                        bar                 = 0;
                        location            = 0;
                        customer            = 0;
                        break;
                    default:
                        region              = 0;
                        bar                 = 0;
                        location            = 0;
                        customer            = 0;
                        break;
                }
                userReportEl.addElement("bar").addText(String.valueOf(bar));
                userReportEl.addElement("location").addText(String.valueOf(location));
                userReportEl.addElement("customer").addText(String.valueOf(customer));
                userReportEl.addElement("region").addText(String.valueOf(region));
                userReportEl.addElement("tableValues").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                userReportEl.addElement("minAlertThreshold").addText(String.valueOf(rs.getDouble(colCount++)));
                userReportEl.addElement("maxAlertThreshold").addText(String.valueOf(rs.getDouble(colCount++)));
                userReportEl.addElement("customTime").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("platform").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("reportFormat").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }
    

    /** Returns information about a single user.  The caller must pass their own
     *  userid to verify that they belong to the same customer.
     *
     * This method will return the username, fullname, emailAddress, manager status,
     * and location permissions (if applicable).
     *
     */
    private void getSupplierUserDetail(Element toHandle, Element toAppend) throws HandlerException {
        int callerId = getCallerId(toHandle);
        int targetId = HandlerUtils.getRequiredInteger(toHandle, "targetId");

        String getSupplierUser =
                " SELECT name, username, email, supplier, isCorporate, isRegional, mobile, carrier" +
                " FROM supplierUser WHERE id = ?";
        String getSupplierUserMap =
                " SELECT l.name, l.id, m.securityLevel FROM supplierUserMap m" +
                " LEFT JOIN location l ON m.location = l.id " +
                " WHERE m.user = ?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            int callerSupplier = -1;

            stmt =
                    transconn.prepareStatement(getSupplierUser);
            stmt.setInt(1, callerId);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                callerSupplier = rs.getInt(4);
            }

            stmt = transconn.prepareStatement(getSupplierUser);
            stmt.setInt(1, targetId);
            rs =
                    stmt.executeQuery();
            if (rs.next()) {
                String name = rs.getString(1);
                String username = rs.getString(2);
                String email = rs.getString(3);
                int supplier = rs.getInt(4);
                int isCorporate = rs.getInt(5);
                int isRegional = rs.getInt(6);
                String mobile = rs.getString(7);
                String carrier = rs.getString(8);

                //check that the caller should be able to see this info
                if (callerSupplier == 0 || callerSupplier == supplier) {
                    toAppend.addElement("fullName").addText(HandlerUtils.nullToEmpty(name));
                    toAppend.addElement("username").addText(HandlerUtils.nullToEmpty(username));
                    toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(email));
                    toAppend.addElement("mobile").addText(HandlerUtils.nullToEmpty(mobile));
                    toAppend.addElement("carrier").addText(HandlerUtils.nullToEmpty(carrier));
                    toAppend.addElement("isCorporate").addText(String.valueOf(isCorporate));
                    if (isCorporate == 0) {
                        stmt = transconn.prepareStatement(getSupplierUserMap);
                        stmt.setInt(1, targetId);
                        rs =
                                stmt.executeQuery();
                        while (rs.next()) {
                            Element permEl = toAppend.addElement("location");
                            permEl.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                            permEl.addElement("locationId").addText(String.valueOf(rs.getInt(2)));
                            permEl.addElement("permission").addText(String.valueOf(rs.getInt(3)));
                        }

                    }
                } else {
                    addErrorDetail(toAppend, "You don't have permission to view this user");
                    logger.portalAccessViolation("Permission problem: Tried to getUserDetail on " + targetId + " by " + callerId);
                }

            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** @deprecated use getNormalUsers or getAdminUsers instead
     */
    private void getUsers(Element toHandle, Element toAppend)
            throws HandlerException {

        String select = "SELECT user.name, user.username, userMap.customer, " +
                "   userMap.securityLevel, customer.name " +
                " FROM user left join userMap on userMap.user=user.id " +
                " LEFT JOIN customer ON customer.id = userMap.customer " +
                " ORDER BY user.username ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {

            stmt = transconn.prepareStatement(select);
            rs =
                    stmt.executeQuery();
            String currentUser = "";
            Element userEl = null;
            while (rs.next()) {
                String fullName = rs.getString(1);
                String username = rs.getString(2);
                int customerId = rs.getInt(3);
                int securityLevel = rs.getInt(4);
                String customerName = rs.getString(5);

                if (currentUser != username || userEl == null) {
                    userEl = toAppend.addElement("user");
                    userEl.addElement("username").addText(username);
                    userEl.addElement("fullName").addText(fullName);
                    currentUser =
                            username;
                }

                Element custEl = userEl.addElement("customer");
                custEl.addElement("customerId").addText(String.valueOf(customerId));
                custEl.addElement("customerName").addText(HandlerUtils.nullToEmpty(customerName));
                custEl.addElement("securityLevel").addText(String.valueOf(securityLevel));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**     Web manager security levels:
     *  All users are associated with a customer
     *
     *  Each user has a Manager flag.
     *  A manager can access every location for that customer.  They can also set
     *  up subordinate accounts for their customer, and set other permissions.
     *
     * If a user is not a manager, his permissions are defined individually for
     * each location.  The possible location-level permissions are:
     *      No-access
     *      Read-only
     *      Supervisor
     *
     *  No-access:  This location isn't available at all to this user
     *  Read-only:  This user can view reports and inventory information, but can't make any changes
     *  Supervisor: This user can make changes, including inventory and draft lines.  He can
     *      also manage read-only accounts at the location.  He can see a list of all non-
     *      manager accounts across ALL locations for this customer, and give or remove
     *      read-only access to his location.
     *
     * As far as the web manager is concerned, it loads one location at a time, and needs to know
     * what permissions a user has at that location.  The web manager actually has a fourth permission,
     * called admin.  Admin is a special permission level for super users that are assoicated with
     * customer 0, the super-customer.    Admins can access all customers, and can set up new
     * customers and new locations.  So, this method needs to return a list of locations and permissions
     * that this user has.
     *
     * By convention, the usbn database uses the followng numbers for permissions:
     *    1 : admin
     *    3 : super-manager (customer level)
     *    5 : manager
     *    7 : read-only
     * See also: net.terakeet.usbn.WebPermssion
     */
    private void authUser(Element toHandle, Element toAppend) throws HandlerException {

        final int HQ_CUSTID                 = 10;
        final int ROOT_CUSTOMER             = 0;
        //final String ADMIN_SECURITY_STRING = "1";
        //final String SUPERVISOR_SECURITY_STRING = "3";

        int platform                        = HandlerUtils.getRequiredInteger(toHandle, "platform");
        String username                     = HandlerUtils.getRequiredString(toHandle, "username");
        String password                     = HandlerUtils.getRequiredString(toHandle, "password");

        String checkBevSyncRoot             = "SELECT u.id, uPM.easternOffset, uPM.threshold, uPM.emailType, u.customer, uGP.groups FROM user u " +
                                            " LEFT JOIN userPreferenceMap uPM ON uPM.user = u.id LEFT JOIN userGroupMap uGP on uGP.user = u.id " +
                                            " WHERE u.username = ? AND u.password = ? AND u.platform IN (?,1,3)";

        String checkRoot                    = "SELECT u.id, u.isManager, isITAdmin, u.lastCustomer, u.customer, u.groupId FROM user u " +
                                            " WHERE u.username = ? AND u.password = ? AND u.platform IN (?,3)";

        String checkBOSSRoot                = "SELECT u.id, uPM.easternOffset, uPM.threshold, uPM.emailType, u.customer FROM user u " +
                                            " LEFT JOIN userPreferenceMap uPM ON uPM.user = u.id  " +
                                            " WHERE u.customer = 0 AND u.username = ? AND u.password = ?";

        String selectNormal                 = "SELECT l.id, l.name, l.type, c.id, c.name, c.type, l.easternOffset, l.volAdjustment, lD.beerboard, m.securityLevel,l.region" +
                                            " FROM userMap m " +
                                            " LEFT JOIN location l ON m.location = l.id LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " LEFT JOIN customer c ON l.customer = c.id " +
                                            " WHERE m.user=? AND lD.active = 1 " +
                                            " ORDER BY m.securityLevel ASC, l.name ASC";

        String selectRoot                   = "SELECT l.id, l.name, l.type, c.id, c.name, c.type, l.easternOffset, l.volAdjustment, lD.beerboard,l.region" +
                                            " FROM customer c " +
                                            " LEFT JOIN location l ON l.customer = c.id LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE c.id=? AND lD.active = 1 " +
                                            " ORDER BY l.name ASC ";

        int userId                          = -1;
        String platformName                 = null;

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {

            switch (platform) {
                case 0:
                    platformName            = "bevBOSS";
                    // we need to know if the user has Admin access
                    stmt                    = transconn.prepareStatement(checkBOSSRoot);
                    stmt.setString(1, username);
                    stmt.setString(2, password);
                    rs                      = stmt.executeQuery();
                    if (rs != null && rs.next()) {
                        String logMessage   = "Granting Admin access to " + username + " for " + platformName;
                        logger.portalDetail(userId, "login", 0, logMessage, transconn);
                        int rsIndex         = 1;
                        userId              = rs.getInt(rsIndex++);
                        toAppend.addElement("userId").addText(String.valueOf(userId));
                        toAppend.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                        toAppend.addElement("threshold").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                        toAppend.addElement("emailType").addText(String.valueOf(rs.getInt(rsIndex++)));
                        toAppend.addElement("securityLevel").addText("1");
                        toAppend.addElement("productType").addText("1");
                        toAppend.addElement("groupId").addText("0");
                    }
                    break;
                case 1:
                    platformName            = "bevManager";
                    // we need to know if the user has Admin access
                    stmt                    = transconn.prepareStatement(checkRoot);
                    stmt.setString(1, username);
                    stmt.setString(2, password);
                    stmt.setInt(3, platform);
                    rs                      = stmt.executeQuery();
                    int isManager           = -1, isITAdmin = -1, customerToLoad = 0, associatedCustomer = -1, groupId = -1;
                    boolean isSuperAdmin    = false;
                    if (rs != null && rs.next()) {
                        int rsIndex         = 1;
                        userId              = rs.getInt(rsIndex++);
                        isManager           = rs.getInt(rsIndex++);
                        isITAdmin           = rs.getInt(rsIndex++);
                        customerToLoad      = rs.getInt(rsIndex++);
                        associatedCustomer  = rs.getInt(rsIndex++);
                        groupId             = rs.getInt(rsIndex++);
                        if (associatedCustomer == ROOT_CUSTOMER) {
                            if (customerToLoad <= 0) {
                                customerToLoad
                                            = HQ_CUSTID;
                            }
                            isSuperAdmin    = true;
                        } else {
                            customerToLoad = associatedCustomer;
                            isSuperAdmin    = false;
                        }
                        toAppend.addElement("userId").addText(String.valueOf(userId));
                        toAppend.addElement("groupId").addText(String.valueOf(groupId));
                    }
                    if (isManager > 0) {
                        // the user is an Admin (root)
                        String logMessage   = "Granting " + (isSuperAdmin ? "Admin" : "Super-manager") + " access to " + username + " for " + platformName;
                        logger.portalDetail(userId, "login", 0, logMessage, transconn);
                        getRegionSet(customerToLoad,toAppend);
                        stmt                = transconn.prepareStatement(selectRoot);
                        stmt.setInt(1, customerToLoad);
                        rs                  = stmt.executeQuery();
                        while (rs != null && rs.next()) {
                            int rsIndex     = 1;
                            Element locEl   = toAppend.addElement("location");
                            locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("beerboard").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("regionId").addText(String.valueOf(rs.getInt(rsIndex++)));
                            WebPermission perm
                                            = isSuperAdmin ? WebPermission.instanceOfUsbnAdmin() : WebPermission.instanceOfCustomerAdmin();
                            locEl.addElement("securityLevel").addText(String.valueOf(perm.getLevel()));

                        }
                    } else if (isITAdmin > 0) {
                        // the user is an Admin (root)
                        String logMessage   = "Granting " + (isSuperAdmin ? "Admin" : "Super-manager") + " access to " + username + " for " + platformName;
                        logger.portalDetail(userId, "login", 0, logMessage, transconn);
                        getRegionSet(customerToLoad,toAppend);
                        stmt                = transconn.prepareStatement(selectRoot);
                        stmt.setInt(1, customerToLoad);
                        rs                  = stmt.executeQuery();
                        while (rs != null && rs.next()) {
                            int rsIndex     = 1;
                            Element locEl   = toAppend.addElement("location");
                            locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("beerboard").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("region").addText(String.valueOf(rs.getInt(rsIndex++)));
                            WebPermission perm
                                            = isSuperAdmin ? WebPermission.instanceOfUsbnAdmin() : WebPermission.instanceOfITAdmin();
                            locEl.addElement("securityLevel").addText(String.valueOf(perm.getLevel()));

                        }
                    } else if (userId >= 0) {
                        // the user is not an Admin(root)
                        String logMessage   = "Granting map-level access to " + username + " for " + platformName;
                        logger.portalDetail(userId, "login", 0, logMessage, transconn);
                        getRegionSet(customerToLoad,toAppend);
                        stmt                = transconn.prepareStatement(selectNormal);
                        stmt.setInt(1, userId);
                        rs                  = stmt.executeQuery();
                        while (rs != null && rs.next()) {
                            int rsIndex     = 1;
                            Element locEl   = toAppend.addElement("location");
                            locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                            locEl.addElement("beerboard").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("securityLevel").addText(String.valueOf(rs.getInt(rsIndex++)));
                            locEl.addElement("region").addText(String.valueOf(rs.getInt(rsIndex++)));
                        }
                    } else {
                        logger.portalAction("Authentication failed to " + username + " for " + platformName);
                        // authentication failed
                    }
                    break;
                case 2:
                    platformName            = "bevSync";
                    
                    // we need to know if the user has Admin access
                    stmt                    = transconn.prepareStatement(checkBevSyncRoot);
                    stmt.setString(1, username);
                    stmt.setString(2, password);
                    stmt.setInt(3, platform);
                    rs                      = stmt.executeQuery();
                    if (rs != null && rs.next()) {
                        int rsIndex         = 1;
                        userId              = rs.getInt(rsIndex++);
                        toAppend.addElement("userId").addText(String.valueOf(userId));
                        toAppend.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                        toAppend.addElement("threshold").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                        toAppend.addElement("emailType").addText(String.valueOf(rsIndex++));
                        if (rs.getInt(rsIndex++) == ROOT_CUSTOMER) {
                            toAppend.addElement("securityLevel").addText("1");
                            String logMessage
                                            = "Granting Admin access to " + username + " for " + platformName;
                            logger.portalDetail(userId, "login", 0, logMessage, transconn);
                        } else {
                            toAppend.addElement("securityLevel").addText("3");
                            String logMessage
                                            = "Granting map-level access to " + username + " for " + platformName;
                            logger.portalDetail(userId, "login", 0, logMessage, transconn);
                        }
                        toAppend.addElement("productType").addText("1");
                        toAppend.addElement("groupId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    } else {
                        stmt                    = transconn.prepareStatement("SELECT id,customer, securityLevel FROM bevSyncUser WHERE username = ? AND password = ?");
                        stmt.setString(1, username);
                        stmt.setString(2, password);
                         rs                      = stmt.executeQuery();
                         int bevSyncCustomer     = 0;
                         if (rs != null && rs.next()) {
                               toAppend.addElement("userId").addText(String.valueOf(rs.getInt(1)));
                               toAppend.addElement("customerId").addText(String.valueOf(rs.getInt(2)));
                               bevSyncCustomer = rs.getInt(2);                               
                               toAppend.addElement("securityLevel").addText(String.valueOf(rs.getInt(3)));
                               toAppend.addElement("groupId").addText(String.valueOf(0));
                             
                         }
                        
                    }
                    break;
                default:
                    break;
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    
    

    /**     Web manager security levels:
     *  All users are associated with a customer
     *
     *  Each user has a Manager flag.
     *  A manager can access every location for that customer.  They can also set
     *  up subordinate accounts for their customer, and set other permissions.
     *
     * If a user is not a manager, his permissions are defined individually for
     * each location.  The possible location-level permissions are:
     *      No-access
     *      Read-only
     *      Supervisor
     *
     *  No-access:  This location isn't available at all to this user
     *  Read-only:  This user can view reports and inventory information, but can't make any changes
     *  Supervisor: This user can make changes, including inventory and draft lines.  He can
     *      also manage read-only accounts at the location.  He can see a list of all non-
     *      manager accounts across ALL locations for this customer, and give or remove
     *      read-only access to his location.
     *
     * As far as the web manager is concerned, it loads one location at a time, and needs to know
     * what permissions a user has at that location.  The web manager actually has a fourth permission,
     * called admin.  Admin is a special permission level for super users that are assoicated with
     * customer 0, the super-customer.    Admins can access all customers, and can set up new
     * customers and new locations.  So, this method needs to return a list of locations and permissions
     * that this user has.
     *
     * By convention, the usbn database uses the followng numbers for permissions:
     *    1 : admin
     *    3 : super-manager (customer level)
     *    5 : manager
     *    7 : read-only
     * See also: net.terakeet.usbn.WebPermssion
     */
    private void authSupplierUser(Element toHandle, Element toAppend)
            throws HandlerException {

        final int HQ_SUPPLIERID = 86;
        final int ROOT_SUPPLIER = 0;
        //final String ADMIN_SECURITY_STRING = "1";
        //final String SUPERVISOR_SECURITY_STRING = "3";

        String username = HandlerUtils.getRequiredString(toHandle, "username");
        String password = HandlerUtils.getRequiredString(toHandle, "password");

        String checkRoot = "SELECT su.id, su.isCorporate, su.isRegional, su.supplier, s.name FROM supplierUser su " +
                " LEFT JOIN supplier s ON s.id = su.supplier WHERE su.username = ? AND su.password = ? ";

        String selectNormal = "SELECT l.id, l.name, l.type, c.id, c.name, c.type, l.easternOffset, m.securityLevel" +
                " FROM SupplierUserMap m " +
                " LEFT JOIN location l ON m.location = l.id " +
                " LEFT JOIN customer c ON l.customer = c.id " +
                " WHERE m.user=? " +
                " ORDER BY m.securityLevel ASC, l.name ASC";

        String selectRoot = "SELECT l.id, l.name, l.type, c.id, c.name, c.type, l.easternOffset" +
                " FROM location l LEFT JOIN locationSupplier map ON map.location = l.id " +
                " LEFT JOIN supplierAddress a ON map.address = a.id LEFT JOIN supplier s ON a.supplier=s.id " +
                " LEFT JOIN customer c ON l.customer = c.id " +
                " WHERE s.id=? " +
                " ORDER BY l.name ASC ";


        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            // we need to know if the user has Admin access
            stmt = transconn.prepareStatement(checkRoot);
            stmt.setString(1, username);
            stmt.setString(2, password);
            rs =
                    stmt.executeQuery();

            int isCorporate = -1;
            int isRegional = -1;
            int userId = -1;
            int supplierToLoad = 0;
            String supplierName;

            boolean isSuperAdmin = false;
            if (rs != null && rs.next()) {
                int rsIndex = 1;
                userId =
                        rs.getInt(rsIndex++);
                isCorporate =
                        rs.getInt(rsIndex++);
                isRegional =
                        rs.getInt(rsIndex++);
                supplierToLoad =
                        rs.getInt(rsIndex++);
                supplierName =
                        rs.getString(rsIndex++);
                if (supplierToLoad == ROOT_SUPPLIER) {
                    if (supplierToLoad <= 0) {
                        supplierToLoad = HQ_SUPPLIERID;
                    }

                    isSuperAdmin = true;
                } else {
                    isSuperAdmin = false;
                }

                toAppend.addElement("userId").addText(String.valueOf(userId));
                Element suppEl = toAppend.addElement("supplier");
                suppEl.addElement("supplierId").addText(String.valueOf(supplierToLoad));
                suppEl.addElement("supplierName").addText(HandlerUtils.nullToEmpty((supplierName)));
            }

            if (isSuperAdmin) {
                // the user is an Admin (root)
                String logMessage = "Granting USBN Super-Admin access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, transconn);
                stmt =
                        transconn.prepareStatement(selectRoot);
                stmt.setInt(1, supplierToLoad);
                rs =
                        stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    WebPermission perm = isSuperAdmin ? WebPermission.instanceOfUsbnAdmin() : WebPermission.instanceOfCustomerAdmin();
                    locEl.addElement("securityLevel").addText(String.valueOf(perm.getLevel()));

                }

            } else if (isCorporate > 0) {
                // the user is an Admin (root)
                String logMessage = "Granting Supplier Admin access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, transconn);
                stmt =
                        transconn.prepareStatement(selectRoot);
                stmt.setInt(1, supplierToLoad);
                rs =
                        stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    WebPermission perm = isSuperAdmin ? WebPermission.instanceOfUsbnAdmin() : WebPermission.instanceOfCustomerAdmin();
                    locEl.addElement("securityLevel").addText(String.valueOf(perm.getLevel()));

                }

            } else if (isRegional >= 0) {
                // the user is not an Admin(root)
                String logMessage = "Granting Supplier Regional Admin access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, transconn);
                stmt =
                        transconn.prepareStatement(selectNormal);
                stmt.setInt(1, userId);
                rs =
                        stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("securityLevel").addText(String.valueOf(rs.getInt(rsIndex++)));

                }

            } else {
                logger.portalAction("Authentication failed for " + username);
                // authentication failed
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**     Web manager security levels:
     *  All users are associated with a customer
     *
     *  Each user has a Manager flag.
     *  A manager can access every location for that customer.  They can also set
     *  up subordinate accounts for their customer, and set other permissions.
     *
     * If a user is not a manager, his permissions are defined individually for
     * each location.  The possible location-level permissions are:
     *      No-access
     *      Read-only
     *      Supervisor
     *
     *  No-access:  This location isn't available at all to this user
     *  Read-only:  This user can view reports and inventory information, but can't make any changes
     *  Supervisor: This user can make changes, including inventory and draft lines.  He can
     *      also manage read-only accounts at the location.  He can see a list of all non-
     *      manager accounts across ALL locations for this customer, and give or remove
     *      read-only access to his location.
     *
     * As far as the web manager is concerned, it loads one location at a time, and needs to know
     * what permissions a user has at that location.  The web manager actually has a fourth permission,
     * called admin.  Admin is a special permission level for super users that are assoicated with
     * customer 0, the super-customer.    Admins can access all customers, and can set up new
     * customers and new locations.  So, this method needs to return a list of locations and permissions
     * that this user has.
     *
     * By convention, the usbn database uses the followng numbers for permissions:
     *    1 : admin
     *    3 : super-manager (customer level)
     *    5 : manager
     *    7 : read-only
     * See also: net.terakeet.usbn.WebPermssion
     */
    private void authBevSyncUser(Element toHandle, Element toAppend)
            throws HandlerException {

        String username = HandlerUtils.getRequiredString(toHandle, "username");
        String password = HandlerUtils.getRequiredString(toHandle, "password");

        String checkRoot = "SELECT su.id, su.isCorporate, su.isRegional, " +
                " uPM.easternOffset, uPM.threshold, uPM.emailType FROM supplierUser su " +
                " LEFT JOIN userPreferenceMap uPM ON uPM.user = su.id " +
                " WHERE su.username = ? AND su.password = ? ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            // we need to know if the user has Admin access
            stmt = transconn.prepareStatement(checkRoot);
            stmt.setString(1, username);
            stmt.setString(2, password);
            rs =
                    stmt.executeQuery();

            int isCorporate = -1;
            int isRegional = -1;
            int userId = -1;
            boolean isSuperAdmin = false;
            if (rs != null && rs.next()) {
                int rsIndex = 1;
                userId =
                        rs.getInt(rsIndex++);
                isCorporate =
                        rs.getInt(rsIndex++);
                isRegional =
                        rs.getInt(rsIndex++);
                toAppend.addElement("userId").addText(String.valueOf(userId));
                toAppend.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                toAppend.addElement("threshold").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                toAppend.addElement("emailType").addText(String.valueOf(rsIndex++));
                toAppend.addElement("securityLevel").addText("3");
                toAppend.addElement("productType").addText("1");
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** Retrieves a location list for the specified customer.
     *  Requires an admin user.
     */
    private void adminChangeCustomer(Element toHandle, Element toAppend) throws HandlerException {

        final int ROOT_CUSTOMER             = 0;
        final String ADMIN_SECURITY_STRING  = "1";

        int userId                          = HandlerUtils.getRequiredInteger(toHandle, "userId");
        int custId                          = HandlerUtils.getRequiredInteger(toHandle, "customerId");

        String checkAdmin                   = "SELECT customer, groupId, isManager FROM user WHERE id = ?";
        String checkCustomerGroup           = "SELECT id FROM customerGroupMap WHERE customer = ? AND groupId = ? ";

        String updateLastCustomer           = "UPDATE user SET lastCustomer = ? WHERE id = ?";
        String selectAdmin                  = "SELECT l.id, l.name, l.type, c.id, c.name, c.type, l.easternOffset, l.volAdjustment, lD.beerboard,l.region " +
                                            " FROM customer c " +
                                            " LEFT JOIN location l ON l.customer = c.id LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            "  WHERE lD.active = 1 AND c.id = ? " +
                                            " ORDER BY l.name ";
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            boolean validCustomer           = true;
            // we need to know if the user id has Admin access
            stmt                            = transconn.prepareStatement(checkAdmin);
            stmt.setInt(1, userId);
            rs                              = stmt.executeQuery();
            int rootCust                    = -1, groupId = -1, isAdmin = -1;
            if (rs != null && rs.next()) {
                rootCust                    = rs.getInt(1);
                groupId                     = rs.getInt(2);
                isAdmin                     = rs.getInt(3);
            }

            if (rootCust != custId) {
                validCustomer               = false;
            }

            if ((!validCustomer) && (groupId > 0)) {
                stmt                        = transconn.prepareStatement(checkCustomerGroup);
                stmt.setInt(1, custId);
                stmt.setInt(2, groupId);
                rs                          = stmt.executeQuery();
                if (rs.next()) {
                    validCustomer           = true;
                }
            }

            if (rootCust == ROOT_CUSTOMER) {
                validCustomer               = true;
            }

            // we need to know if the user id has Multi Customer access
            stmt                            = transconn.prepareStatement(checkCustomerGroup);
            stmt.setInt(1, rootCust);
            stmt.setInt(2, groupId);
            rs                              = stmt.executeQuery();
            if (validCustomer && (rootCust == ROOT_CUSTOMER || (rs != null && rs.next()))) {
                // the user is an SuperUser or Multi Customer User
                logger.debug("Granting " + (groupId > 1 ? "SuperUser" : "Mutli Customer")  + " access - switching to customer " + custId);
                logger.portalAction((groupId > 1 ? "SuperUser #" : "Mutli Customer #") + userId + " switching to customer " + custId);
                getRegionSet(custId,toAppend);
                stmt                        = transconn.prepareStatement(selectAdmin);
                stmt.setInt(1, custId);
                rs                          = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex             = 1;
                    Element locEl           = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("beerboard").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("regionId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("securityLevel").addText(ADMIN_SECURITY_STRING);
                }

                stmt                        = transconn.prepareStatement(updateLastCustomer);
                stmt.setInt(1, custId);
                stmt.setInt(2, userId);
                stmt.executeUpdate();
            } else if (rootCust == custId) {

                String selectNormal         = "SELECT l.id, l.name, l.type, c.id, c.name, c.type, l.easternOffset, l.volAdjustment, lD.beerboard, l.region " +
                                            " FROM userMap m " +
                                            " LEFT JOIN location l ON m.location = l.id LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " LEFT JOIN customer c ON l.customer = c.id " +
                                            " WHERE m.user=? AND lD.active = 1 " +
                                            " ORDER BY m.securityLevel ASC, l.name ASC";
                String selectRoot           = "SELECT l.id, l.name, l.type, c.id, c.name, c.type, l.easternOffset, l.volAdjustment, lD.beerboard, l.region " +
                                            " FROM customer c " +
                                            " LEFT JOIN location l ON l.customer = c.id LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE c.id=? AND lD.active = 1 " +
                                            " ORDER BY l.name ASC ";
                
                if (isAdmin == 1) {
                    stmt                    = transconn.prepareStatement(selectRoot);
                    stmt.setInt(1, rootCust);
                } else {
                    stmt                    = transconn.prepareStatement(selectNormal);
                    stmt.setInt(1, userId);
                }
                rs                          = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex             = 1;
                    Element locEl           = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("beerboard").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("regionId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("securityLevel").addText(ADMIN_SECURITY_STRING);
                }
            } else {
                logger.portalAccessViolation("User #" + userId + " tried to switch to C#" + custId + ", FAILED");
                // user is not an admin
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    
    
    private void getRegionSet(int customer, Element toAppend) throws HandlerException {
        String selectRegion                 = "Select DISTINCT r.id,r.name,r.customer FROM regionSet r LEFT JOIN location l ON l.region=r.id WHERE l.region > 0 AND r.customer=? ORDER BY r.name;";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        
         try {
             stmt                           = transconn.prepareStatement(selectRegion);
             stmt.setInt(1, customer);
             rs                             = stmt.executeQuery();
             Element regEl              = toAppend.addElement("region");
             regEl.addElement("regionId").addText(String.valueOf(0));
             regEl.addElement("regionName").addText(HandlerUtils.nullToEmpty("ALL"));
             while (rs != null && rs.next()) {
                 int rsIndex                = 1;
                 Element locEl              = toAppend.addElement("region");
                 locEl.addElement("regionId").addText(String.valueOf(rs.getInt(rsIndex++)));
                 locEl.addElement("regionName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
             }
         } catch (SQLException sqle) {
             logger.dbError("Database error: " + sqle.getMessage());
             throw new HandlerException(sqle);
         } finally {
             close(rs);
             close(stmt);
        }
                
    }

    /**  Retrieves a client key for a location ID and a vendor ID.  This method may only be called by clients that
     * possess an admin key for for location 0.
     */
    private void getClientKey(Element toHandle, Element toAppend, SecureSession ss)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int vendor = HandlerUtils.getRequiredInteger(toHandle, "vendorId");
        int user = HandlerUtils.getRequiredInteger(toHandle, "userId");
        logger.portalAction("Client Key request by user " + user + " for location " + location + ", vendor " + vendor);
        if (ss.getLocation() == 0 && ss.getSecurityLevel().canAdmin()) {
            String key = ClientKeyManager.createClientKey(location, vendor, 100);
            toAppend.addElement("clientKey").addText(HandlerUtils.nullToEmpty(key));
            logger.portalDetail(user, "clientKey", location, " Client Key generated and returned", transconn);
        } else {
            logger.portalAccessViolation("Attempted to get a Client Key for L" + location + " V" + vendor + " with a " +
                    "key that authenticated for L:" + ss.getLocation() + " SL:" + ss.getSecurityLevel().toString());
        }

    }

    private void getDbHealth(Element toHandle, Element toAppend)
            throws HandlerException {
        logger.dbAction("DB Health Check");
        toAppend.addElement("publicUsers").addText(String.valueOf(transconn.getUsers()));
        logger.dbAction("DB Health Check getting DCM Report: ");
        logger.dbAction("DB Health Check Report {" + DatabaseConnectionManager.report() + "}");
        logger.dbAction("DB Health Check Complete");
    }

    /**
     * Get all misc products from one location, or optionally from one supplier
     */
    private void getMiscProducts(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int supplier = HandlerUtils.getOptionalInteger(toHandle, "supplierId");
        boolean getInactive = HandlerUtils.getOptionalBoolean(toHandle, "getInactive");

        int callerId = getCallerId(toHandle);

        String sql = "SELECT id, name, plu, supplier, active FROM miscProduct WHERE location=? " +
                (!getInactive ? " AND active=1" : "");
        String sqlSupplier = "SELECT id, name, plu, supplier, active FROM miscProduct WHERE location=? AND supplier=? " +
                (!getInactive ? " AND active=1" : "");
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (-1 == supplier || -999 == supplier) {
                stmt = transconn.prepareStatement(sql);
                stmt.setInt(1, location);
            } else {
                stmt = transconn.prepareStatement(sqlSupplier);
                stmt.setInt(1, location);
                stmt.setInt(2, supplier);
            }

            rs = stmt.executeQuery();
            while (rs.next()) {
                Element mpEl = toAppend.addElement("product");
                int colCount = 1;

                mpEl.addElement("id").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                mpEl.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                mpEl.addElement("plu").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                mpEl.addElement("supplier").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                mpEl.addElement("active").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));

                logger.portalDetail("Get misc products according to specific location and supplier (optional)");
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /**
     * The purchase summary method returns a list of all the products ordered 
     * and received over a certain period, and the quantity that they were ordered.
     */
    private void getPurchaseSummary(Element toHandle, Element toAppend) throws HandlerException {
        int locationId = HandlerUtils.getRequiredInteger(toHandle, "location");
        String startDate = HandlerUtils.getRequiredString(toHandle, "startDate");
        String endDate = HandlerUtils.getRequiredString(toHandle, "endDate");
        int supplierId = HandlerUtils.getOptionalInteger(toHandle, "supplier");

        String selectProduct = "SELECT pr.name, SUM(pd.quantity) FROM purchase pu LEFT JOIN purchaseDetail pd ON pu.id = pd.purchase" +
                " LEFT JOIN product pr ON pd.product = pr.id WHERE pu.location = ? AND pu.status = 'RECEIVED' AND " +
                (supplierId > 0 ? " pu.supplier=? AND " : "") + " (pu.receivedDate BETWEEN ? AND ?) GROUP BY pd.product";
        String selectMiscProduct = "SELECT pr.name, SUM(pd.quantity) FROM purchase pu LEFT JOIN purchaseDetailMisc pd ON pu.id = pd.purchase" +
                " LEFT JOIN miscProduct pr ON pd.product = pr.id WHERE pu.location = ? AND pu.status = 'RECEIVED' AND " +
                (supplierId > 0 ? " pu.supplier=? AND " : "") + " (pu.receivedDate BETWEEN ? AND ?) GROUP BY pd.product";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        ResultSet rsMisc = null;

        int paramIndex = 1;

        try {
            // get all products in the purchases;
            stmt = transconn.prepareStatement(selectProduct);
            stmt.setInt(paramIndex++, locationId);
            if (supplierId > 0) {
                stmt.setInt(paramIndex++, supplierId);
            }

            stmt.setString(paramIndex++, startDate);
            stmt.setString(paramIndex++, endDate);
            rs =
                    stmt.executeQuery();

            // get all miscProducts in the purchases;
            paramIndex =
                    1;
            stmt =
                    transconn.prepareStatement(selectMiscProduct);
            stmt.setInt(paramIndex++, locationId);
            if (supplierId > 0) {
                stmt.setInt(paramIndex++, supplierId);
            }

            stmt.setString(paramIndex++, startDate);
            stmt.setString(paramIndex++, endDate);
            rsMisc =
                    stmt.executeQuery();

            while (rs.next()) {
                Element el = toAppend.addElement("product");
                int colCount = 1;

                el.addElement("name").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("quantity").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                el.addElement("misc").addText(HandlerUtils.nullToEmpty("0"));
            }

            while (rsMisc.next()) {
                Element el = toAppend.addElement("product");
                int colCount = 1;

                el.addElement("name").addText(HandlerUtils.nullToEmpty(String.valueOf(rsMisc.getString(colCount++))));
                el.addElement("quantity").addText(HandlerUtils.nullToEmpty(String.valueOf(rsMisc.getInt(colCount++))));
                el.addElement("misc").addText(HandlerUtils.nullToEmpty("1"));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(rsMisc);
            close(stmt);
        }

    }

    private void getSystemTemperature(Element toHandle, Element toAppend) throws HandlerException {
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String startDate                    = HandlerUtils.getRequiredTimestamp(toHandle, "startDate").toString();
        String endDate                      = HandlerUtils.getRequiredTimestamp(toHandle, "endDate").toString();
        int cooler                          = HandlerUtils.getOptionalInteger(toHandle, "coolerId");

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {

            HashMap<Integer, DateSet> dateSets
                                            = new DateSet().getDateSets(startDate, endDate);
            for (Integer i : dateSets.keySet()) {

                String selectSystemTemp     = " SELECT l.name, c.id, c.name, cT.value, date_format(ADDDATE(cT.date, INTERVAL l.easternOffset HOUR), '%l:%i %p') " +
                                            " FROM coolerTemperature" + dateSets.get(i).getStartYear()  + " cT " +
                                            " LEFT JOIN cooler c ON c.id = cT.cooler LEFT JOIN location l ON l.id = c.location " +
                                            " WHERE cT.date BETWEEN ? AND ? AND l.id = ? ";
                if (cooler > 0) {
                    selectSystemTemp        += " AND c.id = ?";
                }

                selectSystemTemp            += " ORDER BY l.name, c.name, cT.date";

                logger.debug("Retreiving temperature from coolerTemperature" + dateSets.get(i).getStartYear() + " for " +  dateSets.get(i).getStartDate() + " to " + dateSets.get(i).getEndDate());
                stmt                        = transconn.prepareStatement(selectSystemTemp);
                stmt.setString(1, dateSets.get(i).getStartDate());
                stmt.setString(2, dateSets.get(i).getEndDate());
                stmt.setInt(3, location);
                if (cooler > 0) {
                    stmt.setInt(4, cooler);
                }
                rs                          = stmt.executeQuery();
                while (rs.next()) {
                    int colCount = 1;
                    Element el              = toAppend.addElement("temperatureData");
                    el.addElement("location").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                    el.addElement("coolerId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                    el.addElement("cooler").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                    el.addElement("temp").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getDouble(colCount++))));
                    el.addElement("time").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
    ///SundarRavindran-02-Jun-2009_End
    ///SundarRavindran-02-Jun-2009_Start: 
    ///This handler will report the brix value of the location by dat

    private void getBrix(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int prodType = HandlerUtils.getOptionalInteger(toHandle, "prodID");
        String startDate = HandlerUtils.getRequiredTimestamp(toHandle, "startDate").toString();
        String endDate = HandlerUtils.getRequiredTimestamp(toHandle, "endDate").toString();

        String selectBrixValues = " SELECT p.id, p.name, l.id, l.lineIndex, ROUND(bR.value,2), date_format(bR.date, '%l:%i %p') " +
                " FROM brixRatio bR LEFT JOIN line l ON l.id = bR.line " +
                " LEFT JOIN bar b ON b.id = l.bar " +
                " LEFT JOIN product p ON p.id = l.product " +
                " WHERE l.status = 'RUNNING' " +
                " AND bR.date BETWEEN ? AND ? AND b.location = ? ";
        if (prodType > 0) {
            selectBrixValues += " AND p.pType = ? ";
        }

        selectBrixValues += " ORDER BY bR.line, bR.date;";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(selectBrixValues);
            stmt.setString(1, startDate);
            stmt.setString(2, endDate);
            stmt.setInt(3, location);
            if (prodType > 0) {
                stmt.setInt(4, prodType);
            }

            rs = stmt.executeQuery();

            while (rs.next()) {
                int colCount = 1;
                Element el = toAppend.addElement("brixData");
                el.addElement("productId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("product").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("lineId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                el.addElement("lineIndex").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("brix").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getDouble(colCount++))));
                el.addElement("time").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
    ///SundarRavindran_02-Jun-2009_End

    /**  Retrieves a client key for a location ID and a vendor ID.  This method may only be called by clients that
     * possess an admin key for for location 0.
     */
    private void checkEventTime(Element toHandle, Element toAppend) throws HandlerException {

        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String today = HandlerUtils.getRequiredString(toHandle, "todayDate");

        String selectEventTime = "SELECT preOpen, eventEnd FROM eventHours WHERE location = ? AND date = ?";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        java.util.Date currentTime = new Date(Calendar.getInstance().getTimeInMillis());
        java.util.Date preOpen = new Date(Calendar.getInstance().getTimeInMillis());
        java.util.Date eventEnd = new Date(Calendar.getInstance().getTimeInMillis());


        try {

            stmt = transconn.prepareStatement(selectEventTime);
            stmt.setInt(1, location);
            stmt.setString(2, today);
            rs =
                    stmt.executeQuery();

            if (rs.next()) {
                preOpen = rs.getTimestamp(1);
                eventEnd =
                        rs.getTimestamp(2);

                if ((currentTime.after(preOpen)) && (currentTime.before(eventEnd))) {
                    toAppend.addElement("isGameTime").addText("1");
                } else {
                    toAppend.addElement("isGameTime").addText("0");
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getLocationsMasterData(Element toHandle, Element toAppend) throws HandlerException {

        int customerId                      = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int userId                          = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int regionId                        = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        String select                       = "SELECT l.id, l.name, l.easternOffset, l.latitude, l.longitude, l.zoomLevel FROM location l  ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        int paramCount = 0;
        if (customerId > 0) {
            paramCount++;
        }
        if (locationId > 0) {
            paramCount++;
        }
        if (userId > 0) {
            paramCount++;
        }
        if (paramCount > 1 || paramCount == 0) {
            throw new HandlerException("Only one parameter can be set for getLocationsMasterData: customerId or locationId or userId.");
        }
        try {
            if (customerId > 0) {
                select += " WHERE l.customer = ?  ";
                if(regionId > 0) {
                    select                  += "  AND l.region =  "+String.valueOf(regionId);
                }
                select                      +=" ORDER BY l.name";
                stmt = transconn.prepareStatement(select);
                stmt.setInt(1, customerId);
                rs = stmt.executeQuery();
            } else if (locationId > 0) {
                select += " WHERE l.id = ? ORDER BY l.name ";
                stmt = transconn.prepareStatement(select);
                stmt.setInt(1, locationId);
                rs = stmt.executeQuery();
            } else if (userId > 0) {
                select += " LEFT JOIN userMap uM ON uM.location = l.id WHERE uM.user = ? ORDER BY l.name ";
                stmt = transconn.prepareStatement(select);
                stmt.setInt(1, userId);
                rs = stmt.executeQuery();
            }
            if (null != rs) {
                while (rs.next()) {
                    Element location = toAppend.addElement("location");
                    location.addAttribute("locationId", rs.getString(1));
                    location.addText(rs.getString(2));
                    location.addAttribute("offset", rs.getString(3));
                    location.addAttribute("latitude", rs.getString(4));
                    location.addAttribute("longitude", rs.getString(5));
                    location.addAttribute("zoomLevel", rs.getString(6));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    //NischaySharma_13-Oct-2009_Start
    private void getCostCentersXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element costCenter = toAppend.addElement("costCenter");
            costCenter.addElement("id").addText(String.valueOf(rs.getInt(1)));
            costCenter.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            costCenter.addElement("ccID").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(3))));
            costCenter.addElement("locationId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(4))));
            costCenter.addElement("zoneId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(5))));
            costCenter.addElement("barId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(6))));
            costCenter.addElement("stationId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(7))));
        }

    }

    private void getCostCenters(Element toHandle, Element toAppend) throws HandlerException {

        int customerId                      = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int barId                           = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int zoneId                          = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int standId                         = HandlerUtils.getOptionalInteger(toHandle, "standId");
        int stationId                       = HandlerUtils.getOptionalInteger(toHandle, "stationId");
        int userId                          = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int regionId                        = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        String specificLocationsString      = HandlerUtils.getOptionalString(toHandle, "specificLocations");

        int paramsSet = 0;
        
        if (customerId >= 0) {
            paramsSet++;
        }
        
        if (locationId >= 0) {
            paramsSet++;
        }

        if (barId >= 0) {
            paramsSet++;
        }

        if (zoneId >= 0) {
            paramsSet++;
        }

        if (standId >= 0) {
            paramsSet++;
        }

        if (stationId >= 0) {
            paramsSet++;
        }

        if (userId >= 0) {
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getCostCenters i.e. customerId or locationId or barId or zoneId or standId or stationId or userId.");
        }

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        String select                       = " SELECT c.id, c.name, c.ccID, c.location, c.zone, c.bar, c.station FROM costCenter c ";
        int criteria                        = 0;
        try {
            if (customerId >= 0) {
                if (!checkForeignKey("customer", "id", customerId)) {
                    throw new HandlerException("Foreign Key Not found : customer " + customerId);
                }
                select                      += " LEFT JOIN location l ON l.id = c.location WHERE l.customer = ? ";
                if(regionId > 0) {
                    select                  += "  AND l.region =  "+String.valueOf(regionId);
                }
                criteria                    = customerId;
            } else if (locationId >= 0) {
                if (!checkForeignKey("location", "id", locationId)) {
                    throw new HandlerException("Foreign Key Not found : location " + locationId);
                }
                select                      += " WHERE c.location = ? ";
                criteria                    = locationId;
            } else if (barId >= 0) {
                if (!checkForeignKey("bar", "id", barId)) {
                    throw new HandlerException("Foreign Key Not found : bar " + barId);
                }
                select                      += " WHERE c.bar = ? ";
                criteria                    = barId;
            } else if (standId >= 0) {
                if (!checkForeignKey("bar", "id", barId)) {
                    throw new HandlerException("Foreign Key Not found : bar " + standId);
                }
                select                      += " WHERE c.bar = ? ";
                criteria                    = standId;
            } else if (zoneId >= 0) {
                if (!checkForeignKey("zone", "id", zoneId)) {
                    throw new HandlerException("Foreign Key Not found : zone " + zoneId);
                }
                select                      += " WHERE c.zone = ? ";
                criteria                    = zoneId;
            } else if (stationId >= 0) {
                if (!checkForeignKey("station", "id", stationId)) {
                    throw new HandlerException("Foreign Key Not found : station " + stationId);
                }
                select                      += " WHERE c.station = ? ";
                criteria                    = stationId;
            } else if (userId >= 0) {
                if (!checkForeignKey("user", "id", userId)) {
                    throw new HandlerException("Foreign Key Not found : user " + userId);
                }
                select                      += " WHERE c.location IN ("+ specificLocationsString + ")";
                criteria                    = -1;
            }
            stmt                            = transconn.prepareStatement(select);
            if (criteria > 0) {
                stmt.setInt(1, criteria);
            }
            rs                              = stmt.executeQuery();
            getCostCentersXML(toAppend, rs);
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    //NischaySharma_13-Oct-2009_End

    //NischaySharma_05-Mar-2010_Start:  Added new handler to fetch product types for a location
    private void getProductTypes(Element toHandle, Element toAppend) throws HandlerException {

        int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        String selectProductType = "SELECT DISTINCT p.pType, pt.name FROM inventory i " +
                " LEFT JOIN location l ON l.id = i.location " +
                " LEFT JOIN product p ON p.id = i.product " +
                " LEFT JOIN productType pt ON p.pType = pt.id " +
                " WHERE l.id = ? ORDER BY p.pType; ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(selectProductType);
            stmt.setInt(1, locationId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element product = toAppend.addElement("product").addText(rs.getString(2));
                product.addAttribute("id", rs.getString(1));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    //NischaySharma_05-Mar-2010_End

    private void getUserAlertType(Element toHandle, Element toAppend) throws HandlerException {

        String selectAlerts                 = "SELECT id, name, timing, description FROM userAlertType WHERE isActive = 1";
        int type                            = HandlerUtils.getOptionalInteger(toHandle, "type");
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        if (type >= 0) {selectAlerts += " AND type = ?"; }
        try {
            stmt = transconn.prepareStatement(selectAlerts);
            if (type >= 0) { stmt.setInt(1, type); }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element userAlertType = toAppend.addElement("userAlertTypes");
                userAlertType.addElement("id").addText(String.valueOf(rs.getInt(1)));
                userAlertType.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                userAlertType.addElement("timing").addText(String.valueOf(rs.getTimestamp(3)));
                userAlertType.addElement("description").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getUserAlertType: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getUserAlerts(Element toHandle, Element toAppend) throws HandlerException {

        String selectUserAlerts             = " SELECT uA.id, uA.alert, uA.tableId, uA.tableType, uA.time FROM userAlerts uA WHERE uA.user=? ";
        int user                            = HandlerUtils.getRequiredInteger(toHandle, "user");
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        ResultSet innerrs                   = null;
        Element reportTime                  = null;
        SimpleDateFormat f                  = new SimpleDateFormat("HH:mm:ss");

        try {
            logger.portalAction("getUserAlerts");
            stmt                            = transconn.prepareStatement(selectUserAlerts);
            stmt.setInt(1, user);
            rs                              = stmt.executeQuery();
            int colCount = 1;
            while (rs.next()) {
                colCount                    = 1;
                Element emailReports        = toAppend.addElement("userAlerts");
                int alertId                 = rs.getInt(colCount++);
                int alert                   = rs.getInt(colCount++);
                int tableId                 = rs.getInt(colCount++);
                int tableType               = rs.getInt(colCount++);
                int time                    = rs.getInt(colCount++);
                emailReports.addElement("id").addText(String.valueOf(alertId));
                emailReports.addElement("alert").addText(String.valueOf(alert));
                emailReports.addElement("tableId").addText(String.valueOf(tableId));
                emailReports.addElement("tableType").addText(String.valueOf(tableType));
                emailReports.addElement("alertDescription").addText(HandlerUtils.nullToEmpty(getAlertDescription(tableId, tableType)));
                emailReports.addElement("timeI").addText(String.valueOf(time));
                if (time > 0) {
                    String selectUserReportsTimes
                                            = " SELECT uATT.time, uATT.day FROM userAlertsTimeTable uATT WHERE uATT.id=?; ";
                    stmt                    = transconn.prepareStatement(selectUserReportsTimes);
                    stmt.setInt(1, time);
                    innerrs                 = stmt.executeQuery();
                    if (innerrs.next()) {
                        reportTime          = emailReports.addElement("reportTime");
                        String alertTime    = innerrs.getString(1);
                        java.util.Date d    = f.parse(alertTime);
                        java.util.Date date = new java.util.Date(d.getTime() + getAlertOffsetInMillis(tableId, tableType));
                        reportTime.addElement("time").addText(HandlerUtils.nullToEmpty(dateToString(date)));
                        reportTime.addElement("day").addText(String.valueOf(innerrs.getInt(2)));
                    }
                } else {
                    reportTime              = emailReports.addElement("reportTime");
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getUserAlerts: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } catch (Exception e) {
            logger.dbError("Parse error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getSuperUserAlerts(Element toHandle, Element toAppend) throws HandlerException {

        String selectUserAlerts             = " SELECT sUA.id, sUA.alert, sUA.time FROM superUserAlerts sUA WHERE sUA.user=? ";
        int user                            = HandlerUtils.getRequiredInteger(toHandle, "user");
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        ResultSet innerrs                   = null;
        Element reportTime                  = null;
        SimpleDateFormat f                  = new SimpleDateFormat("HH:mm:ss");

        try {
            logger.portalAction("getSuperUserAlerts");
            stmt                            = transconn.prepareStatement(selectUserAlerts);
            stmt.setInt(1, user);
            rs                              = stmt.executeQuery();
            int colCount = 1;
            while (rs.next()) {
                colCount                    = 1;
                Element emailReports        = toAppend.addElement("superUserAlerts");
                int alertId                 = rs.getInt(colCount++);
                int alert                   = rs.getInt(colCount++);
                int time                    = rs.getInt(colCount++);
                emailReports.addElement("id").addText(String.valueOf(alertId));
                emailReports.addElement("alert").addText(String.valueOf(alert));
                emailReports.addElement("timeId").addText(String.valueOf(time));
                if (time > 0) {
                    String selectUserReportsTimes
                                            = " SELECT uATT.time, uATT.day FROM userAlertsTimeTable uATT WHERE uATT.id=?; ";
                    stmt                    = transconn.prepareStatement(selectUserReportsTimes);
                    stmt.setInt(1, time);
                    innerrs                 = stmt.executeQuery();
                    if (innerrs.next()) {
                        reportTime          = emailReports.addElement("reportTime");
                        String alertTime    = innerrs.getString(1);
                        java.util.Date date = f.parse(alertTime);
                        reportTime.addElement("time").addText(HandlerUtils.nullToEmpty(dateToString(date)));
                        reportTime.addElement("day").addText(String.valueOf(innerrs.getInt(2)));
                    }
                } else {
                    reportTime              = emailReports.addElement("reportTime");
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getSuperUserAlerts: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } catch (Exception e) {
            logger.dbError("Parse error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private String getSQLQuery (int queryId) {
        String queryString = "";
            switch (queryId)
            {
                case 1:
                    queryString             = " SELECT uA.id, l.name, " +
                                            " GROUP_CONCAT(DISTINCT CONCAT(b.name,' at ',ADDDATE(b.lastPoured, INTERVAL l.easternOffset HOUR)) ORDER BY b.name SEPARATOR ';'), " +
                                            " u.name, u.email, GROUP_CONCAT(DISTINCT b.id ORDER BY b.id SEPARATOR ','), l.id FROM userAlerts uA " +
                                            " LEFT JOIN location l ON l.id = uA.tableId LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " LEFT JOIN bevBox b ON b.location = l.id LEFT JOIN user u ON u.id = uA.user " +
                                            " WHERE uA.alert = 1 AND uA.tableType = 2 AND b.active = 1 AND b.alert = 0 AND b.lastPoured < SUBDATE(NOW(), INTERVAL 1 HOUR) " +
                                            " AND lD.active = 1 AND lD.suspended = 0 GROUP BY uA.id ";
                    break;
                case 2:
                    queryString             = " SELECT uA.id, l.name, ADDDATE(l.lastSold, INTERVAL l.easternOffset HOUR), u.name, u.email, l.id " +
                                            " FROM userAlerts uA LEFT JOIN location l ON l.id = uA.tableId LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " LEFT JOIN customer c ON c.id = l.customer LEFT JOIN user u ON u.id = uA.user " +
                                            " WHERE uA.alert = 2 AND uA.tableType = 2 AND uA.count < 4 AND uA.active = 0 " +
                                            " AND l.lastSold < SUBDATE(NOW(), INTERVAL 1 HOUR) AND lD.active = 1 AND lD.suspended = 0 AND lD.soldUp = 1; ";
                    break;
                case 3:
                    queryString             = " SELECT SUBSTRING(c.name,1,25) Customer, SUBSTRING(lo.name,1,25) Location, b.name Bar, s.systemId System FROM " +
                                            " (SELECT l.system, COUNT(lS.line) count FROM " +
                                            " (SELECT line, SUM(value) value, COUNT(date) dateCount FROM lineSummary " +
                                            " WHERE type = 0 AND date > SUBDATE(?, INTERVAL 4 DAY) AND value = 0 GROUP BY line) AS lS " +
                                            " LEFT JOIN line l ON l.id = lS.line WHERE lS.dateCount = 3 GROUP BY l.system ORDER BY l.system) AS lS " +
                                            " LEFT JOIN " +
                                            " (SELECT l.system, l.bar, COUNT(l.id) count FROM line l WHERE l.status = 'RUNNING' GROUP BY l.system ORDER BY l.system) AS l " +
                                            " ON l.system = lS.system LEFT JOIN bar b ON b.id = l.bar " +
                                            " LEFT JOIN system s ON s.id = lS.system LEFT JOIN location lo ON lo.id = s.location " +
                                            " LEFT JOIN locationDetails lD ON lD.location = lo.id LEFT JOIN customer c ON c.id = lo.customer " +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND lo.type = 1 AND lS.count = l.count ORDER BY Customer, Location, System; ";
                    break;
                case 4:
                    queryString             = " SELECT SUBSTRING(c.name,1,25), SUBSTRING(lo.name,1,25), b.name, s.systemId, l.lineIndex + 1, p.name " +
                                            " FROM (SELECT line, SUM(value) value, COUNT(date) dateCount FROM lineSummary WHERE type = 0 AND date > SUBDATE(?, INTERVAL 4 DAY) " +
                                            " GROUP BY line) AS lS  LEFT JOIN line l ON l.id = lS.line LEFT JOIN system s ON s.id = l.system LEFT JOIN bar b ON b.id = l.bar " +
                                            " LEFT JOIN location lo ON lo.id = b.location LEFT JOIN locationDetails lD ON lD.location = lo.id " +
                                            " LEFT JOIN customer c ON c.id = lo.customer LEFT JOIN product p ON p.id = l.product" +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND lo.type = 1 AND lS.dateCount = 3 " +
                                            " ORDER BY c.name, lo.name, b.name, s.systemId, l.lineIndex; ";
                    break;
                case 7:
                    queryString             = " SELECT uA.id, uA.tableType, uA.tableId, u.name, u.email, u.isManager, u.id FROM userAlerts uA " +
                                            " LEFT JOIN user u ON u.id = uA.user LEFT JOIN userAlertsTimeTable uATT ON uATT.id = uA.time " +
                                            " WHERE uA.alert = 7 AND uA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, '08:00:00');";
                    break;
                case 8:
                    queryString             = " SELECT uA.id, l.name Location, ADDDATE(lCL.startTime, INTERVAL l.easternOffset HOUR), ADDDATE(lCL.endTime, INTERVAL l.easternOffset HOUR), " +
                                            " u.name, u.email FROM userAlerts uA LEFT JOIN user u ON u.id = uA.user " +
                                            " LEFT JOIN location l ON l.id = uA.tableId LEFT JOIN lineCleaningLog lCL ON lCL.location = l.id " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE uA.alert = 8 AND uA.tableType = 2 AND uA.active = 0 " +
                                            " AND lCL.date = LEFT(SUBDATE(?,INTERVAL 1 DAY),11) " +
                                            " AND lD.active = 1 AND lD.suspended = 0 AND lD.pouredUp = 1 AND l.type = 1 " +
                                            " GROUP BY l.id ORDER BY l.name;";
                    break;
                case 9:
                    queryString             = " SELECT l.Cust, l.Loc, l.Version, l.Ping, l.LID FROM " +
                                            " (SELECT l.id LID, c.name Cust, l.name Loc, ADDDATE(l.lastPoured, INTERVAL l.easternOffset HOUR) Ping, " +
                                            " ADDDATE(l.picoPowerup, INTERVAL l.easternOffset HOUR) Power, l.picoVersion Version FROM location l " +
                                            " LEFT JOIN customer c ON c.id = l.customer LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND l.type = 1 AND lD.pouredUp = 1) AS l " +
                                            " LEFT JOIN " +
                                            " (SELECT l.id LID FROM openHoursSummary oHS LEFT JOIN location l ON l.id = oHS.location " +
                                            " WHERE oHS.date = LEFT(SUBDATE(?,INTERVAL 1 DAY),11) AND oHS.value > 0 GROUP BY oHS.location) AS p " +
                                            " ON p.LID = l.LID WHERE p.LID IS NULL ORDER BY l.Cust, l.Loc; ";
                    break;
                case 10:
                    queryString             = " SELECT l.Cust, l.Loc, l.POS POS, l.Ping, l.LID FROM " +
                                            " (SELECT l.id LID, c.name Cust, l.name Loc, l.processorName POS, ADDDATE(l.lastSold, INTERVAL l.easternOffset HOUR) Ping " +
                                            " FROM location l LEFT JOIN customer c ON c.id = l.customer LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND l.type = 1 AND lD.soldUp = 1) AS l " +
                                            " LEFT JOIN " +
                                            " (SELECT l.id LID FROM openHoursSoldSummary oHSS LEFT JOIN location l ON l.id = oHSS.location " +
                                            " WHERE oHSS.date = LEFT(SUBDATE(?,INTERVAL 1 DAY),11) AND oHSS.value > 0 GROUP BY oHSS.location) AS s " +
                                            " ON s.LID = l.LID WHERE s.LID IS NULL ORDER BY l.Cust, l.Loc; ";
                    break;
                case 11:
                    queryString             = " SELECT c.name Customer, l.name Location, ROUND(SUM(pOHS.value),2) Poured, l.id FROM preOpenHoursSummary pOHS " +
                                            " LEFT JOIN location l ON l.id = pOHS.location LEFT JOIN customer c ON c.id = l.customer " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE pOHS.date = LEFT(?,11) AND lD.active = 1 AND lD.suspended = 0 AND lD.pouredUp = 1 AND l.type = 1 " +
                                            " GROUP BY c.id, l.id ORDER BY c.name, l.name; ";
                    break;
                case 12:
                    queryString             = " SELECT c.name Customer, l.name Location, ROUND(SUM(aHS.value),2) Poured, l.id FROM afterHoursSummary aHS " +
                                            " LEFT JOIN location l ON l.id = aHS.location LEFT JOIN customer c ON c.id = l.customer " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE aHS.date = LEFT(SUBDATE(?,INTERVAL 1 DAY),11) AND lD.active = 1 AND lD.suspended = 0 AND lD.pouredUp = 1 AND l.type = 1 " +
                                            " GROUP BY c.id, l.id ORDER BY c.name, l.name; ";
                    break;
                case 13:
                    queryString             = " SELECT c.name Customer, l.name Location, s.systemId System, i.totalMinutes Total, l.id " +
                                            " FROM interruptionLogs i LEFT JOIN location l on l.id = i.location LEFT JOIN customer c ON c.id = l.customer " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id LEFT JOIN system s ON s.location = l.id " +
                                            " WHERE i.startTime > CONCAT(LEFT(SUBDATE(?,1) ,11),' 07:00:00') AND i.totalMinutes > 20 " +
                                            " AND l.type = 1 AND lD.active = 1 AND lD.suspended = 0 AND lD.pouredUp = 1 " +
                                            " GROUP BY l.id, s.id ORDER BY c.name, l.name, s.systemId, i.startTime;";
                    break;
                case 14:
                    queryString             = " SELECT 1 Status, c.name Customer, IF(l.name = b.name, l.name, CONCAT(l.name,' : ',b.name, ' System ', b.startSystem)) Location, " +
                                            " b.version Version, IFNULL(b.lastPoured,'2005-01-01 00:00:00'), l.id FROM location l LEFT JOIN customer c ON c.id = l.customer " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id LEFT JOIN bevBox b ON b.location = l.id" +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND b.lastPoured < SUBDATE(NOW(), INTERVAL 1 HOUR) AND lD.pouredUp = 1 " +
                                            " GROUP BY b.id " +
                                            " UNION " +
                                            " SELECT 2 Status, c.name Customer, l.name Location, l.processorName POS, IFNULL(l.lastSold,'2005-01-01 00:00:00'), l.id " +
                                            " FROM location l LEFT JOIN customer c ON c.id = l.customer LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND l.lastSold < SUBDATE(NOW(), INTERVAL 1 HOUR) AND lD.soldUp = 1 " +
                                            " GROUP BY l.id ORDER BY Status DESC, Customer, Location;";
                    break;
                case 15:
                    queryString             = " SELECT DISTINCT CONCAT(c.name, ' - ', lo.name) Location, CONCAT(s.systemId, ' - ', l.lineIndex + 1) Line, p.name Product, ROUND(r.value,2) Poured " +
                                            " FROM readingNew r LEFT JOIN line l on l.id = r.line " +
                                            " LEFT JOIN bar b on b.id = l.bar LEFT JOIN product p on p.id = l.product LEFT JOIN system s on s.id = l.system LEFT JOIN location lo ON lo.id = b.location " +
                                            " LEFT JOIN customer c ON c.id = lo.customer " +
                                            " WHERE r.value > 350000 AND r.date > SUBDATE(?, INTERVAL 7 HOUR) AND lo.picoVersion IN (3.00, 3.01, 4.00) " +
                                            " GROUP BY s.systemId, l.id " +
                                            " UNION " +
                                            " SELECT DISTINCT CONCAT(c.name, ' - ', lo.name) Location, CONCAT(s.systemId, ' - ', l.lineIndex + 1) Line, p.name Product, ROUND(r.value,2) Poured " +
                                            " FROM readingNew r LEFT JOIN line l on l.id = r.line " +
                                            " LEFT JOIN bar b on b.id = l.bar LEFT JOIN product p on p.id = l.product LEFT JOIN system s on s.id = l.system LEFT JOIN location lo ON lo.id = b.location " +
                                            " LEFT JOIN customer c ON c.id = lo.customer " +
                                            " WHERE r.value > 800000 AND r.date > SUBDATE(?, INTERVAL 7 HOUR) AND lo.picoVersion NOT IN (3.00, 3.01, 4.00) " +
                                            " GROUP BY s.systemId, l.id " +
                                            " UNION " +
                                            " SELECT DISTINCT CONCAT(c.name, ' - ', lo.name) Location, CONCAT(s.systemId, ' - ', l.lineIndex + 1) Line, p.name Product, ROUND(r.value,2) Poured " +
                                            " FROM readingNew r LEFT JOIN line l on l.id = r.line " +
                                            " LEFT JOIN bar b on b.id = l.bar LEFT JOIN product p on p.id = l.product LEFT JOIN system s on s.id = l.system LEFT JOIN location lo ON lo.id = b.location " +
                                            " LEFT JOIN customer c ON c.id = lo.customer " +
                                            " WHERE r.value BETWEEN 214748.35937 AND 214748.35939 AND r.date > SUBDATE(?, INTERVAL 7 HOUR) " +
                                            " GROUP BY s.systemId, l.id ORDER BY Location, Line ";
                    break;
                case 16:
                    queryString             = " SELECT CONCAT(SUBSTRING(Cust,1,30),' - ',SUBSTRING(Loc,1,30)), Poured, Sold, Var, " +
                                            " IF (Var<-40, 4, IF(Var<-10,3,IF(Var<-5,2,IF(Var<0,1,IF(Var=0,5,IF(Var<10,1,4)))))) AS Cat FROM " +
                                            " (SELECT l.Cust, l.Loc, ROUND(IFNULL(tPoured,0),2) Poured, ROUND(IFNULL(tSold,0),2) Sold, " +
                                            " IFNULL(ROUND(((tSold - tPoured)/tPoured)*100,2),0) Var, l.LID FROM " +
                                            " (SELECT l.id LID, c.name Cust, l.name Loc FROM location l LEFT JOIN customer c ON c.id = l.customer " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND l.type = 1 AND (lD.soldUp = 1 OR lD.pouredUp = 1)) AS l " +
                                            " LEFT JOIN " +
                                            " (SELECT l.id LID, SUM(oHS.value) tPoured FROM openHoursSummary oHS LEFT JOIN location l ON l.id = oHS.location " +
                                            " WHERE oHS.date = LEFT(SUBDATE(?,INTERVAL 1 DAY),11) GROUP BY oHS.location) AS p " +
                                            " ON p.LID = l.LID " +
                                            " LEFT JOIN " +
                                            " (SELECT l.id LID, SUM(oHSS.value) tSold FROM openHoursSoldSummary oHSS LEFT JOIN location l ON l.id = oHSS.location " +
                                            " WHERE oHSS.date = LEFT(SUBDATE(?,INTERVAL 1 DAY),11) GROUP BY oHSS.location) AS s " +
                                            " ON s.LID = l.LID) AS V " +
                                            " ORDER BY Cat, Var, Cust, Loc; ";
                    break;
                case 17:
                    queryString             = " SELECT CONCAT(SUBSTRING(l.Cust,1,30),' - ',SUBSTRING(l.Loc,1,30)), ROUND(IFNULL(tPoured,0),2) Poured, ROUND(IFNULL(tSold,0),2) Sold, " +
                                            " IFNULL(ROUND(((tSold - tPoured)/tPoured)*100,2),0) Var " +
                                            " FROM (SELECT l.id LID, c.name Cust, l.name Loc FROM location l LEFT JOIN customer c ON c.id = l.customer " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND l.type = 1 AND (lD.soldUp = 1 OR lD.pouredUp = 1)) AS l " +
                                            " LEFT JOIN " +
                                            " (SELECT l.id LID, SUM(oHS.value) tPoured FROM openHoursSummary oHS LEFT JOIN location l ON l.id = oHS.location " +
                                            " WHERE oHS.date = LEFT(SUBDATE(?,INTERVAL 1 DAY),11) GROUP BY oHS.location) AS p " +
                                            " ON p.LID = l.LID " +
                                            " LEFT JOIN " +
                                            " (SELECT l.id LID, SUM(oHSS.value) tSold FROM openHoursSoldSummary oHSS LEFT JOIN location l ON l.id = oHSS.location " +
                                            " WHERE oHSS.date = LEFT(SUBDATE(?,INTERVAL 1 DAY),11) GROUP BY oHSS.location) AS s " +
                                            " ON s.LID = l.LID ORDER BY l.Cust, l.Loc; ";
                    break;
                case 18:
                    queryString             = "SELECT uS.productName, uS.pluNumber, SUM(uS.quantity) FROM location l LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " LEFT JOIN unknownSales uS ON uS.location = l.id WHERE lD.active = 1 AND lD.suspended = 0 AND lD.soldUp = 1 AND " +
                                            " l.id = ? AND uS.date > SUBDATE(?,INTERVAL 1 DAY) GROUP BY l.id, uS.pluNumber ORDER BY l.name, uS.productNAme, uS.pluNumber; ";
                    break;
                case 19:
                    queryString             = "SELECT CONCAT(SUBSTRING(Customer,1,30),' - ', SUBSTRING(Location,1,30)),Poured, Sold, Var FROM " +
                                            " (SELECT c.name Customer, l.name Location, SUM(t.poured) Poured, SUM(t.sold) Sold, IFNULL(ROUND(((SUM(t.sold)-SUM(t.poured))/SUM(t.poured))*100,2),0) Var " +
                                            " FROM tierSummary t LEFT JOIN location l ON l.id = t.location LEFT JOIN customer c ON c.id = l.customer " +
                                            " WHERE t.date > LEFT(SUBDATE(?,INTERVAL 8 DAY),11) GROUP BY t.location ORDER BY c.name, l.name) as d WHERE Var < -10 AND Var > -40;";
                    break;
                case 20:
                    queryString             = "SELECT uA.id, l.name, " +
                                            " GROUP_CONCAT(DISTINCT CONCAT(b.name,' at ',ADDDATE(b.lastPing, INTERVAL l.easternOffset HOUR)) ORDER BY b.name SEPARATOR ';'), " +
                                            " u.name, u.email, GROUP_CONCAT(DISTINCT b.id ORDER BY b.id SEPARATOR ','), l.id FROM userAlerts uA " +
                                            " LEFT JOIN location l ON l.id = uA.tableId LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " LEFT JOIN beerboard b ON b.location = l.id LEFT JOIN user u ON u.id = uA.user " +
                                            " WHERE uA.alert = 20 AND uA.tableType = 2 AND b.active = 1 AND b.alert = 0 AND b.lastPing < SUBDATE(NOW(), INTERVAL 1 HOUR) " +
                                            " AND lD.active = 1 AND lD.suspended = 0 GROUP BY uA.id ";
                    break;
                case 21:
                    queryString             = "SELECT CONCAT(c.name, ' - ', bUM.name) Loc, bUM.version Version, bUM.lastLogin Login, bUM.lastPing Ping, " +
                                            " IF(bUM.lastPing < ADDDATE(NOW(), INTERVAL -2 HOUR), 2, 1) ALERT, l.id LID FROM location l " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id LEFT JOIN customer c ON c.id = l.customer " +
                                            " LEFT JOIN bbtvUserMac bUM ON bUM.location = l.id " +
                                            " WHERE bUM.id IS NOT NULL AND bUM.version IN ('2.0.2', '2.0.3', '2.0.4', '2.0.5', '2.0.6') AND lD.active = 1 AND lD.suspended = 0 AND l.type = 1 AND lD.beerboard = 1 " +
                                            " ORDER BY ALERT, Loc;";
                    break;
                default:
                    break;
            }
        return queryString;
    }

    private String getSuperUserSQLQuery (int queryId) {
        String queryString = "";
            switch (queryId)
            {
                case 3:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 3 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 4:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 4 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) " +
                                            " AND DAYOFWEEK(NOW()) = IF(IFNULL(uATT.day, 2) < 0, DAYOFWEEK(NOW()), IFNULL(uATT.day+1, 2)); ";
                    break;
                case 9:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 9 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 10:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 10 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 11:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 11 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 12:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 12 AND sUA.active = 0  AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 13:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 13 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 14:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 14 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 15:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 15 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 16:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 16 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 17:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 17 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 19:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 19 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                case 21:
                    queryString             = " SELECT sUA.id, u.name, u.email FROM superUserAlerts sUA LEFT JOIN user u ON u.id = sUA.user " +
                                            " LEFT JOIN userAlertsTimeTable uATT ON uATT.id = sUA.time LEFT JOIN userAlertType uAT ON uAT.id = sUA.alert " +
                                            " WHERE sUA.alert = 21 AND sUA.active = 0 AND TIME(NOW()) > IFNULL(uATT.time, RIGHT(uAT.timing,8)) ";
                    break;
                default:
                    break;
            }
        return queryString;
    }

    public void sendMail(String title, String userName, String emailAddr, String supportEmailAddr, String templateMessageTitle,
            String templateMessage, StringBuilder emailBody, boolean sendBCC) {
        String emailTemplatePath            = HandlerUtils.getSetting("email.templatePath");
        if ((emailTemplatePath == null) || "".equals(emailTemplatePath)) {
            emailTemplatePath               = ".";
        }
        logger.debug("Packaging Email");
        try {
            if ((emailBody != null) && (emailBody.length() > 0)) {
                logger.debug("Loading Template");
                TemplatedMessage poEmail   = new TemplatedMessage(templateMessageTitle, emailTemplatePath, templateMessage);

                poEmail.setSender("tech@usbeveragenet.com");
                poEmail.setRecipient(emailAddr);
                if (sendBCC) {
                    poEmail.setRecipientBCC(supportEmailAddr);
                }
                poEmail.setField("TITLE", title);
                poEmail.setField("BODY", emailBody.toString());
                poEmail.send();
                logger.debug("Email sent successfully for " + userName);
            } 
        } catch (MailException me) {
            logger.dbError("Error sending message to " + emailAddr + ": " + me.toString());
        }
    }

    private void increaseUserAlertCount(int userAlertId) {
        String update                       = "UPDATE userAlerts SET count = count + 1, active = 1 WHERE id = ?";
        PreparedStatement stmt              = null;
        try {
            stmt = transconn.prepareStatement(update);
            stmt.setInt(1, userAlertId);
            stmt.executeUpdate();
        } catch (SQLException sqle) {
            logger.dbError("Database error in increaseUserAlertCount: " + sqle.getMessage());
        } finally {
            close(stmt);
        }
    }

    private void deactivateUserAlert(int userAlertId) {
        String update                       = "UPDATE userAlerts SET active = 1 WHERE id = ?";
        PreparedStatement stmt              = null;
        try {
            stmt = transconn.prepareStatement(update);
            stmt.setInt(1, userAlertId);
            stmt.executeUpdate();
        } catch (SQLException sqle) {
            logger.dbError("Database error in deactivateAlert: " + sqle.getMessage());
        } finally {
            close(stmt);
        }
    }

    private void increaseSuperUserAlertCount(int userAlertId) {
        String update                       = "UPDATE superUserAlerts SET count = count + 1, active = 1 WHERE id = ?";
        PreparedStatement stmt              = null;
        try {
            stmt = transconn.prepareStatement(update);
            stmt.setInt(1, userAlertId);
            stmt.executeUpdate();
        } catch (SQLException sqle) {
            logger.dbError("Database error in increaseSuperUserAlertCount: " + sqle.getMessage());
        } finally {
            close(stmt);
        }
    }

    private void deactivateSuperUserAlert(int userAlertId) {
        String update                       = "UPDATE superUserAlerts SET active = 1 WHERE id = ?";
        PreparedStatement stmt              = null;
        try {
            stmt = transconn.prepareStatement(update);
            stmt.setInt(1, userAlertId);
            stmt.executeUpdate();
        } catch (SQLException sqle) {
            logger.dbError("Database error in deactivateAlert: " + sqle.getMessage());
        } finally {
            close(stmt);
        }
    }

    private void createAlertTicket(int location, int category, int problem, String notes) {
        String createTroubleTicket          = " INSERT INTO ticket (owner, assignedTo, location, category, problem, open, notes) VALUES (?, ?, ?, ?, ?, ?, ?) ";
        String insertTicketUpdates          = " INSERT INTO ticketUpdates (ticket, user) VALUES (?, ?) ";
        String getLastId                    = " SELECT LAST_INSERT_ID()";
        java.util.Date timestamp            = new java.util.Date();
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        try {
            stmt                            = transconn.prepareStatement(createTroubleTicket);
            stmt.setInt(1, 61);
            stmt.setInt(2, 61);
            stmt.setInt(3, location);
            stmt.setInt(4, category);
            stmt.setInt(5, problem);
            stmt.setString(6, newDateFormat.format(timestamp));
            stmt.setString(7, notes);
            stmt.executeUpdate();

            stmt                            = transconn.prepareStatement(getLastId);
            rs                              = stmt.executeQuery();
            if (rs.next()) {
                stmt                        = transconn.prepareStatement(insertTicketUpdates);
                stmt.setInt(1, rs.getInt(1));
                stmt.setInt(2, 61);
                stmt.executeUpdate();
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in deactivateAlert: " + sqle.getMessage());
        } finally {
            close(rs);
            close(stmt);
        }
    }


    /**  Return a list of all product categories
     */
    private void sendUserAlerts(Element toHandle, Element toAppend) throws HandlerException {

        String select                       = "SELECT id, name FROM userAlertType WHERE isActive = 1";
        
        String date                         = HandlerUtils.getOptionalString(toHandle, "date");
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        ResultSet innerRS                   = null;
        ResultSet userRS                    = null;
        String selectSuperUserAlerts        = "";
        boolean createTicket                = true;
        try {
            stmt                            = transconn.prepareStatement(select);
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                int alertType               = rs.getInt(1);
                switch (alertType) {
                    case  1:
                        String selectBevBoxEmail
                                            = getSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectBevBoxEmail);
                        innerRS             = stmt.executeQuery();
                        while (innerRS.next()) {
                            String locationName
                                            = innerRS.getString(2);
                            sendMail("USBN bevBox Alert", innerRS.getString(4), innerRS.getString(5), "support@usbeveragenet.com", "bevBox Alert",
                                    "sendMail", getBevBoxEmail(locationName, innerRS.getString(3)), false);
                            stmt            = transconn.prepareStatement("UPDATE bevBox SET alert = 1, lastPoured=lastPoured WHERE id IN ("  + innerRS.getString(6) + ")");
                            stmt.executeUpdate();
                            
                            int locationId  = -1;
                            if (createTicket || (locationId!= innerRS.getInt(7))) {
                                locationId  = innerRS.getInt(7);
                                //createAlertTicket(locationId, 1, 8, "BevBox(s) at " + locationName + " has not communicated draft beer pour data for over an hour.");
                                createTicket= false;
                            }
                        }
                        break;
                    case  2:
                        String selectGatewayAlert
                                            = getSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectGatewayAlert);
                        innerRS             = stmt.executeQuery();
                        while (innerRS.next()) {
                            String locationName
                                            = innerRS.getString(2);
                            sendMail("USBN Gateway Alert", innerRS.getString(4), innerRS.getString(5), "support@usbeveragenet.com", "Location Status Alert",
                                    "sendMail", getGatewayEmail(locationName, innerRS.getString(3)), false);
                            increaseUserAlertCount(innerRS.getInt(1));

                            int locationId  = -1;
                            if (createTicket || (locationId!= innerRS.getInt(6))) {
                                locationId  = innerRS.getInt(6);
                                //createAlertTicket(locationId, 2, 11, "Gateway at " + locationName + " has not communicated to our servers for over an hour.");
                                createTicket= false;
                            }
                        }
                        break;
                    case  3:
                        String selectSystemAlert
                                            = "";
                        StringBuilder noSystemEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectSystemAlert.length() < 1) {
                                selectSystemAlert
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectSystemAlert);
                                stmt.setString(1, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    noSystemEmail
                                                    = getSystemEmail(innerRS);
                                }
                            }
                            sendMail("USBN System Alert", userRS.getString(2), userRS.getString(3), "support@usbeveragenet.com", "System Alert",
                                "sendMail", noSystemEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case  4:
                        String selectFlowmeterAlert
                                            = "";
                        StringBuilder noFlowmeterListEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectFlowmeterAlert.length() < 1) {
                                selectFlowmeterAlert
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectFlowmeterAlert);
                                stmt.setString(1, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    noFlowmeterListEmail
                                                    = getFlowmeterEmail(innerRS);
                                }
                            }
                            sendMail("USBN Flow Meter Alert", userRS.getString(2), userRS.getString(3), "support@usbeveragenet.com", "Flow Meter Status Alert",
                                "sendMail", noFlowmeterListEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case  5:
                        break;
                    case  6:
                        break;
                    case  7:
                        String selectSupportAlert
                                            = getSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSupportAlert);
                        innerRS             = stmt.executeQuery();
                        while (innerRS.next()) {
                            String locationsString
                                            = "";
                            if (innerRS.getInt(6) < 1) {
                                stmt        = transconn.prepareStatement("SELECT GROUP_CONCAT(location) FROM userMap WHERE user = ?;");
                                stmt.setInt(1, innerRS.getInt(7));
                                userRS      = stmt.executeQuery();
                                if (userRS.next()) {
                                    locationsString
                                            = HandlerUtils.nullToEmpty(userRS.getString(1));
                                    
                                }
                            }
                              
                            StringBuilder locationAlertListEmail
                                            = getLocationAlertEmail(innerRS.getInt(2), innerRS.getInt(3), locationsString);
                            if (locationAlertListEmail.length() != 0) {
                                sendMail("USBN Location Status Alert", HandlerUtils.nullToEmpty(innerRS.getString(4)), HandlerUtils.nullToEmpty(innerRS.getString(5)), "support@usbeveragenet.com", "Location Status Alert",
                                    "sendMail", locationAlertListEmail, false);
                            }
                            deactivateUserAlert(innerRS.getInt(1));
                        }
                        break;
                    case  8:
                        String selectLineCleaningAlert
                                            = getSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectLineCleaningAlert);
                        stmt.setString(1, date);
                        innerRS             = stmt.executeQuery();
                        if (innerRS.next()) {
                            StringBuilder lineCleaningEmail
                                            = getLineCleaningEmail(HandlerUtils.nullToEmpty(innerRS.getString(2)), HandlerUtils.nullToEmpty(innerRS.getString(3)), HandlerUtils.nullToEmpty(innerRS.getString(4)));
                            if (lineCleaningEmail.length() != 0) {
                                sendMail("USBN Line Cleaning Alert", HandlerUtils.nullToEmpty(innerRS.getString(5)), HandlerUtils.nullToEmpty(innerRS.getString(6)), "support@usbeveragenet.com", "Line Cleaning Alert",
                                    "sendMail", lineCleaningEmail, false);
                            }
                            deactivateUserAlert(innerRS.getInt(1));
                        }
                        break;
                    case  9:
                        String selectNoPouredAlert
                                            = "";
                        StringBuilder noPouredListEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectNoPouredAlert.length() < 1) {
                                selectNoPouredAlert
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectNoPouredAlert);
                                stmt.setString(1, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    noPouredListEmail
                                            = getNoPouredEmail(innerRS, date);
                                }
                            }
                            sendMail("USBN No Controller Data", HandlerUtils.nullToEmpty(userRS.getString(2)), HandlerUtils.nullToEmpty(userRS.getString(3)), "support@usbeveragenet.com", "No Controller Data",
                                "sendMail", noPouredListEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case 10:
                        String selectNoSoldAlert
                                            = "";
                        StringBuilder noSoldListEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectNoSoldAlert.length() < 1) {
                                selectNoSoldAlert
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectNoSoldAlert);
                                stmt.setString(1, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    noSoldListEmail
                                            = getNoSoldEmail(innerRS, date);
                                }
                            }
                            sendMail("USBN No Gateway Data", HandlerUtils.nullToEmpty(userRS.getString(2)), HandlerUtils.nullToEmpty(userRS.getString(3)), "support@usbeveragenet.com", "No Gateway Data",
                                "sendMail", noSoldListEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case 11:
                        String selectPreOpenAlert
                                            = "";
                        StringBuilder noPreOpenListEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectPreOpenAlert.length() < 1) {
                                selectPreOpenAlert
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectPreOpenAlert);
                                stmt.setString(1, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    noPreOpenListEmail
                                             = getPreOpenEmail(innerRS, date);
                                }
                            }
                            sendMail("USBN Pre-Open Hours Email", HandlerUtils.nullToEmpty(userRS.getString(2)), HandlerUtils.nullToEmpty(userRS.getString(3)), "support@usbeveragenet.com", "Pre-Open Hours Email",
                                "sendMail", noPreOpenListEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case 12:
                        String selectAfterHoursAlert
                                            = "";
                        StringBuilder afterHoursListEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectAfterHoursAlert.length() < 1) {
                                selectAfterHoursAlert
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectAfterHoursAlert);
                                stmt.setString(1, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    afterHoursListEmail
                                                    = getAfterHoursEmail(innerRS, date);
                                }
                            }
                            sendMail("USBN After Hours Alert", HandlerUtils.nullToEmpty(userRS.getString(2)), HandlerUtils.nullToEmpty(userRS.getString(3)), "support@usbeveragenet.com", "After Hours Alert",
                                "sendMail", afterHoursListEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case 13:
                        String selectInterruptionReport
                                            = "";
                        StringBuilder interruptionReportEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectInterruptionReport.length() < 1) {
                                selectInterruptionReport
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectInterruptionReport);
                                stmt.setString(1, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    interruptionReportEmail
                                            = getInterruptionReportEmail(innerRS, date);
                                }
                            }
                            sendMail("USBN Interruption Report", userRS.getString(2), userRS.getString(3), "support@usbeveragenet.com", "Interruption Report",
                                "sendMail", interruptionReportEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case 14:
                        String selectLocationStatusAlerts
                                            = "";
                        StringBuilder locationStatusAlertEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectLocationStatusAlerts.length() < 1) {
                                selectLocationStatusAlerts
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectLocationStatusAlerts);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    locationStatusAlertEmail
                                            = getLocationStatusAlertEmail(innerRS, date);
                                }
                            }
                            sendMail("USBN Communication Alert", userRS.getString(2), userRS.getString(3), "support@usbeveragenet.com", "Communication Alert",
                                "sendMail", locationStatusAlertEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case 15:
                        String selectLineCounterAlerts
                                            = "";
                        StringBuilder lineCounterAlertEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectLineCounterAlerts.length() < 1) {
                                selectLineCounterAlerts
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectLineCounterAlerts);
                                stmt.setString(1, date);
                                stmt.setString(2, date);
                                stmt.setString(3, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    lineCounterAlertEmail
                                            = getMaxLineCounterAlertEmail(innerRS);
                                }
                            }
                            sendMail("USBN Max Line Counter Alert", HandlerUtils.nullToEmpty(userRS.getString(2)), HandlerUtils.nullToEmpty(userRS.getString(3)), "support@usbeveragenet.com", "Max Line Counter Alert",
                                "sendMail", lineCounterAlertEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case  16:
                        String selectTiers
                                            = "";
                        StringBuilder tierListEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectTiers.length() < 1) {
                                selectTiers
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectTiers);
                                stmt.setString(1, date);
                                stmt.setString(2, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    tierListEmail
                                            = getDailyTierEmail(innerRS);
                                }
                            }
                            sendMail("USBN Daily Tier Report", userRS.getString(2), userRS.getString(3), "support@usbeveragenet.com", "USBN Daily Tier Report for: " + date.substring(0, 10),
                                "sendMail", tierListEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case  17:
                        String selectDailyEmail
                                            = "";
                        StringBuilder dailyEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS         = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectDailyEmail.length() < 1) {
                                selectDailyEmail
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectDailyEmail);
                                stmt.setString(1, date);
                                stmt.setString(2, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    dailyEmail
                                            = getDailyEmail(innerRS);
                                }
                            }
                            sendMail("USBN Daily Report", userRS.getString(2), userRS.getString(3), "support@usbeveragenet.com", "USBN Daily Report for: " + date.substring(0, 10),
                                "sendMail", dailyEmail, false);
                           deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case  18:
                        int locationId      = -1;
                        boolean sendSuperUserCopy
                                            = true;
                        String selectDailyUnknownSalesEmail
                                            = "";
                        String selectUserAlerts
                                            = "SELECT uA.id, l.id, l.name, u.name, u.email FROM userAlerts uA LEFT JOIN location l ON l.id = uA.tableId " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id LEFT JOIN user u ON u.id = uA.user WHERE uA.alert = 18 AND uA.tableType = 2 " +
                                            " AND uA.count < 4 AND uA.active = 0 AND lD.active = 1 AND lD.suspended = 0 AND lD.soldUp = 1;";
                        stmt                = transconn.prepareStatement(selectUserAlerts);
                        userRS              = stmt.executeQuery();
                        while (userRS.next()) {
                        StringBuilder dailyUnknownSalesEmail
                                            = new StringBuilder();
                            if (selectDailyUnknownSalesEmail.length() < 1) {
                                selectDailyUnknownSalesEmail
                                            = getSQLQuery(alertType);
                            }
                            if (locationId == userRS.getInt(2)) {
                                sendSuperUserCopy
                                            = false;
                            } else {
                                sendSuperUserCopy
                                            = true;
                                locationId  = userRS.getInt(2);
                            }
                            stmt            = transconn.prepareStatement(selectDailyUnknownSalesEmail);
                            stmt.setInt(1, locationId);
                            stmt.setString(2, date);
                            innerRS         = stmt.executeQuery();
                            if (innerRS.next()) {
                                dailyUnknownSalesEmail
                                            = getDailyUnknownSalesEmail(innerRS);
                            }
                            if (dailyUnknownSalesEmail.length() != 0) {
                                sendMail("USBN Daily Unaccounted Sales Report", userRS.getString(4), userRS.getString(5), "unknownsales@usbeveragenet.com", "USBN Daily Unaccounted Sales Report - " + userRS.getString(3),
                                    "sendMail", dailyUnknownSalesEmail, sendSuperUserCopy);
                            }
                            deactivateUserAlert(userRS.getInt(1));
                        }
                        break;
                    case  19:
                        Calendar today      = Calendar.getInstance();
                        if (today.get(Calendar.DAY_OF_WEEK) != Calendar.MONDAY) { continue; }
                        String selectThirdTiers
                                            = "";
                        StringBuilder thirdTierListEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS              = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectThirdTiers.length() < 1) {
                                selectThirdTiers
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectThirdTiers);
                                stmt.setString(1, date);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    thirdTierListEmail
                                            = getMonthlyThirdTierEmail(innerRS);
                                }
                            }
                            sendMail("USBN Third Tier Report", userRS.getString(2), userRS.getString(3), "support@usbeveragenet.com", "USBN Third Tier Report for: " + date.substring(0, 10),
                                "sendMail", thirdTierListEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    case  20:
                        String selectBBTVEmail
                                            = getSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectBBTVEmail);
                        innerRS             = stmt.executeQuery();
                        while (innerRS.next()) {
                            String locationName
                                            = innerRS.getString(2);
                            sendMail("USBN BeerBoard TV Alert", innerRS.getString(4), innerRS.getString(5), "support@usbeveragenet.com", "BeerBoard TV Alert",
                                    "sendMail", getBBTVEmail(locationName, innerRS.getString(3)), false);
                            stmt            = transconn.prepareStatement("UPDATE beerboard SET alert = 1, lastPing=lastPing WHERE id IN ("  + innerRS.getString(6) + ")");
                            stmt.executeUpdate();
                        }
                        break;
                    case 21:
                        String selectBBTVStatusAlerts
                                            = "";
                        StringBuilder bbtvStatusAlertEmail
                                            = null;
                        selectSuperUserAlerts
                                            = getSuperUserSQLQuery(alertType);
                        stmt                = transconn.prepareStatement(selectSuperUserAlerts);
                        userRS              = stmt.executeQuery();
                        while (userRS.next()) {
                            if (selectBBTVStatusAlerts.length() < 1) {
                                selectBBTVStatusAlerts
                                            = getSQLQuery(alertType);
                                stmt        = transconn.prepareStatement(selectBBTVStatusAlerts);
                                innerRS     = stmt.executeQuery();
                                if (innerRS.next()) {
                                    bbtvStatusAlertEmail
                                            = getBBTVStatusAlertEmail(innerRS, date);
                                }
                            }
                            sendMail("USBN BBTV Status Alert", userRS.getString(2), userRS.getString(3), "support@usbeveragenet.com", "BBTV Status Alert",
                                "sendMail", bbtvStatusAlertEmail, false);
                            deactivateSuperUserAlert(userRS.getInt(1));
                        }
                        break;
                    default:
                        break;
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in sendUserAlerts: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(userRS);
            close(innerRS);
            close(rs);
            close(stmt);
        }
    }

    private StringBuilder getGatewayEmail(String locationName, String lastSoldTime) throws HandlerException {

        StringBuilder noSoldList = new StringBuilder();

        noSoldList.append("<tr align=justify><td colspan=4>Your USBN POS Gateway at ");
        noSoldList.append(HandlerUtils.nullToEmpty(locationName));
        noSoldList.append(" has <strong>not communicated draft beer sold data</strong> for over an hour. Please try restarting your USBN Gateway. Last report time was: <strong>");
        noSoldList.append(HandlerUtils.nullToEmpty(lastSoldTime)); // Last Sold Reading
        noSoldList.append("</strong></td></tr>");
        noSoldList.append("<tr><td height=20 colspan=4>&nbsp;</td></tr>");
        noSoldList.append("<tr align=left><td colspan=4 style=font-size:medium;><strong>Gateway Restart Instructions</strong></td></tr>");
        noSoldList.append("<tr align=left><td height=20 colspan=4><ol style=list-style-type: disc; margin-top: 0px; margin-bottom: 0px;>");
        noSoldList.append("<li>Go to the POS back office computer</li>");
        noSoldList.append("<li>Click on the start menu</li>");
        noSoldList.append("<li>Click on (ALL) Programs</li>");
        noSoldList.append("<li>Click on US Beverage Net Gateway</li>");
        noSoldList.append("<li>Click on Stop Gateway</li>");
        noSoldList.append("<li>Repeat steps 2 through 4</li>");
        noSoldList.append("<li>Click on Start Gateway</li>");
        noSoldList.append("</ol></td></tr>");
        noSoldList.append("<tr align=justify><td height=20 colspan=4><strong>Note:</strong> If when you click on (All) Programs and US Beverage Net Gateway does NOT exist then you are on the wrong back office computer.  Please check the other computer in the back office.</td></tr>");
        noSoldList.append("<tr><td height=20 colspan=4>&nbsp;</td></tr>");
        noSoldList.append("<tr align=justify><td colspan=4>Thank You,</td></tr>");
        noSoldList.append("<tr align=justify><td colspan=4>US Beverage Net Support</td></tr>");
        noSoldList.append("<tr align=center valign=middle><td height=35 colspan=4>&nbsp;</td></tr>");
        noSoldList.append("<tr align=justify><td colspan=4><strong>This email was automatically generated; please do not reply.</strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");

        return noSoldList;
    }

    private StringBuilder getBevBoxEmail(String locationName, String lastSystemPouredTime) throws HandlerException {

        String[] systemPoureds = lastSystemPouredTime.split(";");
        StringBuilder noPouredList = new StringBuilder();

        noPouredList.append("<tr align=justify><td colspan=4>Your bevBox(s) at ");
        noPouredList.append(HandlerUtils.nullToEmpty(locationName));
        noPouredList.append(" has <strong>not communicated draft beer pour data</strong> for over an hour.</td></tr>");
        noPouredList.append("<tr align=justify><td colspan=4>Last report time was:</td></tr>");
        noPouredList.append("<tr align=left><td height=20 colspan=4><ol style=list-style-type: disc; margin-top: 0px; margin-bottom: 0px;>");
        for (int i=0; i < systemPoureds.length; i++) {
            noPouredList.append("<li>");
            noPouredList.append(systemPoureds[i]);
            noPouredList.append("</li>");
        }
        noPouredList.append("</ol></td></tr>");
        noPouredList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
        noPouredList.append("<tr align=justify><td colspan=4>Please try unplugging the power from the bevBox and plug it back in. This will reset the bevBox. You should also ensure the Ethernet cable and RJ11 cable is plugged in properly (Green light will be on where the Ethernet cable plugs into bevBox and inside the turbine collector)</td></tr>");
        noPouredList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
        noPouredList.append("<tr align=justify><td colspan=4>Thank You,</td></tr>");
        noPouredList.append("<tr align=justify><td colspan=4>US Beverage Net Support</td></tr>");
        noPouredList.append("<tr align=center valign=middle><td height=35 colspan=4>&nbsp;</td></tr>");
        noPouredList.append("<tr align=justify><td colspan=4><strong>This email was automatically generated; please do not reply.</strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");

        return noPouredList;
    }

    private StringBuilder getBBTVEmail(String locationName, String lastBBTVTime) throws HandlerException {

        String[] bbtvTimes                  = lastBBTVTime.split(";");
        StringBuilder noBBTVList            = new StringBuilder();

        noBBTVList.append("<tr align=justify><td colspan=4>Your BeerBoard TV at ");
        noBBTVList.append(HandlerUtils.nullToEmpty(locationName));
        noBBTVList.append(" has <strong>not communicated </strong> for over an hour.</td></tr>");
        noBBTVList.append("<tr align=justify><td colspan=4>Last report time was:</td></tr>");
        noBBTVList.append("<tr align=left><td height=20 colspan=4><ol style=list-style-type: disc; margin-top: 0px; margin-bottom: 0px;>");
        for (int i=0; i < bbtvTimes.length; i++) {
            noBBTVList.append("<li>");
            noBBTVList.append(bbtvTimes[i]);
            noBBTVList.append("</li>");
        }
        noBBTVList.append("</ol></td></tr>");
        noBBTVList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
        noBBTVList.append("<tr align=justify><td colspan=4>Please try logging back into the BeerBoard TV by clicking on the BeerBoard icon in the main screen. </td></tr>");
        noBBTVList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
        noBBTVList.append("<tr align=justify><td colspan=4>Thank You,</td></tr>");
        noBBTVList.append("<tr align=justify><td colspan=4>US Beverage Net Support</td></tr>");
        noBBTVList.append("<tr align=center valign=middle><td height=35 colspan=4>&nbsp;</td></tr>");
        noBBTVList.append("<tr align=justify><td colspan=4><strong>This email was automatically generated; please do not reply.</strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");

        return noBBTVList;
    }

    private StringBuilder getSystemEmail(ResultSet rs) throws HandlerException {

        StringBuilder noSystemList          = new StringBuilder();

        noSystemList.append("<tr style=font-size:small height=30><td style=width=30%>Customer</td>");
        noSystemList.append("<td style=width=30%>Location</td>");
        noSystemList.append("<td style=width=10%>Bar</td>");
        noSystemList.append("<td style=width=8%>System</td></tr>");
        noSystemList.append("");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                noSystemList.append("<tr style=font-size:x-small height=15><td>");
                noSystemList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer Name
                noSystemList.append("</td><td>");
                noSystemList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                noSystemList.append("</td><td>");
                noSystemList.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Bar Name
                noSystemList.append("</td><td align='center'>");
                noSystemList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // System
                noSystemList.append("</td></tr>");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getSystemEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        
        noSystemList.append("<tr valign=bottom style=font-size:x-small height=30><td colspan=4>* Systems that have not reported data in the last 3 days </td></tr>");
        return noSystemList;
    }

    private StringBuilder getFlowmeterEmail(ResultSet rs) throws HandlerException {

        StringBuilder noPouredList = new StringBuilder();

        noPouredList.append("<tr style=font-size:small height=30><td style=width=30%>Customer</td>");
        noPouredList.append("<td style=width=30%>Location</td>");
        noPouredList.append("<td style=width=10%>Bar</td>");
        noPouredList.append("<td style=width=30%>System - Line - Product</td></tr>");
        noPouredList.append("");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                noPouredList.append("<tr style=font-size:x-small height=15><td>");
                noPouredList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer Name
                noPouredList.append("</td><td>");
                noPouredList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                noPouredList.append("</td><td>");
                noPouredList.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Bar Name
                noPouredList.append("</td><td>");
                noPouredList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // System
                noPouredList.append(" - ");
                noPouredList.append(HandlerUtils.nullToEmpty(rs.getString(5))); // Line Index
                noPouredList.append(" - ");
                noPouredList.append(HandlerUtils.nullToEmpty(rs.getString(6))); // Product Name
                noPouredList.append("</td></tr>");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getFlowmeterEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        return noPouredList;
    }

    private StringBuilder getLocationAlertEmail(int tableType, int tableId, String locationString) throws HandlerException {

        StringBuilder locationAlertList     = new StringBuilder();
        StringBuilder tempLocationAlertList = new StringBuilder();
        String condition                    = "";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        if (locationString.length() > 0) {
            tableType                       = 3;
            tableId                         = -1;
        }
        switch(tableType) {
            case 1:
                condition                   = " AND l.customer = ? ";
                break;
            case 2:
                condition                   = " AND l.id = ? ";
                break;
            case 3:
                condition                   = " AND l.id IN (" + locationString + ") ";
                break;
        }
        
        try {
            String pouredQuery              = " SELECT 'No Poured Data', l.Loc, IF(l.Ping < SUBDATE(NOW(), INTERVAL 8 HOUR), 'Restart bevBox', 'Call USBN') FROM " +
                                            " (SELECT l.id LID, l.name Loc, l.lastPoured Ping FROM location l " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND l.type = 1 AND lD.pouredUp = 1 " +  condition + " ) AS l " +
                                            " LEFT JOIN " +
                                            " (SELECT l.id LID FROM pouredSummary pS LEFT JOIN location l ON l.id = pS.location " +
                                            " WHERE pS.date = LEFT(SUBDATE(NOW(),INTERVAL 1 DAY),11) " +  condition + " GROUP BY pS.location) AS p " +
                                            " ON p.LID = l.LID WHERE p.LID IS NULL ORDER BY l.Loc; ";
            
            stmt                            = transconn.prepareStatement(pouredQuery);
            if (tableId > 0) {
                stmt.setInt(1, tableId);
                stmt.setInt(2, tableId);
            }
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                tempLocationAlertList.append("<tr style=font-size:small height=15><td>");
                tempLocationAlertList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Issue
                tempLocationAlertList.append("</td><td>");
                tempLocationAlertList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                tempLocationAlertList.append("</td><td>");
                tempLocationAlertList.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Ping
                tempLocationAlertList.append("</td><td></td></tr>");
            }
            
            String soldQuery                = " SELECT 'No Sold Data', l.Loc, IF(l.Ping < SUBDATE(NOW(), INTERVAL 8 HOUR), 'Restart Gateway', 'Check Sales Export') FROM " +
                                            " (SELECT l.id LID, l.name Loc, l.lastSold Ping FROM location l " +
                                            " LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " WHERE lD.active = 1 AND lD.suspended = 0 AND l.type = 1 AND lD.soldUp = 1 " +  condition + " ) AS l " +
                                            " LEFT JOIN " +
                                            " (SELECT l.id LID FROM soldSummary sS LEFT JOIN location l ON l.id = sS.location " +
                                            " WHERE sS.date = LEFT(SUBDATE(NOW(),INTERVAL 1 DAY),11) " +  condition + " GROUP BY sS.location) AS s " +
                                            " ON s.LID = l.LID WHERE s.LID IS NULL ORDER BY l.Loc; ";

            stmt                            = transconn.prepareStatement(soldQuery);
            if (tableId > 0) {
                stmt.setInt(1, tableId);
                stmt.setInt(2, tableId);
            }
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                tempLocationAlertList.append("<tr style=font-size:small height=15><td>");
                tempLocationAlertList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Issue
                tempLocationAlertList.append("</td><td>");
                tempLocationAlertList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                tempLocationAlertList.append("</td><td>");
                tempLocationAlertList.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Ping
                tempLocationAlertList.append("</td><td></td></tr>");
            }

            String bbtvQuery                = "SELECT 'No BeerBoard Communication', l.name, 'Login into BeerBoard TV' " +
                                            " FROM location l LEFT JOIN locationDetails lD ON lD.location = l.id " +
                                            " LEFT JOIN beerboard b ON b.location = l.id " +
                                            " WHERE b.active = 1 AND b.lastPing < SUBDATE(NOW(), INTERVAL 1 HOUR) " +  condition +
                                            " AND lD.active = 1 AND lD.suspended = 0 ORDER BY l.name; ";

            stmt                            = transconn.prepareStatement(bbtvQuery);
            if (tableId > 0) {
                stmt.setInt(1, tableId);
            }
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                tempLocationAlertList.append("<tr style=font-size:small height=15><td>");
                tempLocationAlertList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Issue
                tempLocationAlertList.append("</td><td>");
                tempLocationAlertList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                tempLocationAlertList.append("</td><td>");
                tempLocationAlertList.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Ping
                tempLocationAlertList.append("</td><td></td></tr>");
            }

            if (tempLocationAlertList.length() != 0) {
                locationAlertList.append("<tr style=font-size:medium height=30><td style=width=10%>Issue</td>");
                locationAlertList.append("<td style=width=30%>Location</td>");
                locationAlertList.append("<td style=width=60%>Resolution*</td>");
                locationAlertList.append("<td></td></tr>");
                locationAlertList.append("");
                locationAlertList.append(tempLocationAlertList);
                locationAlertList.append("<tr valign=bottom style=font-size:x-small height=30><td colspan=4>* Possible resolution to the issue </td></tr>");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationAlertEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
        return locationAlertList;
    }

    private StringBuilder getLineCleaningEmail(String location, String startTime, String endTime) throws HandlerException {

        StringBuilder lineCleaningList          = new StringBuilder();

        lineCleaningList.append("<tr style=font-size:small height=30><td style=width=30%>Location</td>");
        lineCleaningList.append("<td style=width=20%>Start Time</td>");
        lineCleaningList.append("<td style=width=20%>End Time</td>");
        lineCleaningList.append("<td style=width=30%></td></tr>");
        lineCleaningList.append("");
        lineCleaningList.append("<tr style=font-size:x-small height=15><td>");
        lineCleaningList.append(HandlerUtils.nullToEmpty(location)); // Location Name
        lineCleaningList.append("</td><td>");
        lineCleaningList.append(HandlerUtils.nullToEmpty(startTime)); // Start Time
        lineCleaningList.append("</td><td>");
        lineCleaningList.append(HandlerUtils.nullToEmpty(endTime)); // End Time
        lineCleaningList.append("</td><td/></tr>");
        
        return lineCleaningList;
    }

    private StringBuilder getNoPouredEmail(ResultSet rs, String date) throws HandlerException {

        HashSet<Integer> locationSet        = new HashSet<Integer>();
        StringBuilder noPouredListHeader    = new StringBuilder();
        StringBuilder noPouredList          = new StringBuilder();
        StringBuilder tempPouredList        = new StringBuilder();

        noPouredListHeader.append("<tr style=font-size:small height=30><td style=width=30%>Customer</td>");
        noPouredListHeader.append("<td style=width=30%>Location</td>");
        noPouredListHeader.append("<td style=width=20%>Box Version</td>");
        noPouredListHeader.append("<td style=width=20%>Last Ping</td></tr>");
        
        try {
            rs.beforeFirst();
            while (rs.next()) {
                tempPouredList.append("<tr style=font-size:x-small height=15><td>");
                tempPouredList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer Name
                tempPouredList.append("</td><td>");
                tempPouredList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                tempPouredList.append("</td><td>");
                tempPouredList.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Pico Version
                tempPouredList.append("</td><td>");
                tempPouredList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Ping
                tempPouredList.append("</td></tr>");
                locationSet.add(rs.getInt(5));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getNoPouredEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        if (tempPouredList.length() != 0) {
            noPouredList.append(noPouredListHeader);
            noPouredList.append("");
            noPouredList.append(tempPouredList);
        }
        addLocationAlertlogs(9, locationSet, date);
        return noPouredList;
    }

    private StringBuilder getNoSoldEmail(ResultSet rs, String date) throws HandlerException {

        HashSet<Integer> locationSet        = new HashSet<Integer>();
        StringBuilder noSoldListHeader      = new StringBuilder();
        StringBuilder noSoldList            = new StringBuilder();
        StringBuilder tempSoldList          = new StringBuilder();

        noSoldListHeader.append("<tr style=font-size:small height=30><td style=width=30%>Customer</td>");
        noSoldListHeader.append("<td style=width=30%>Location</td>");
        noSoldListHeader.append("<td style=width=20%>POS</td>");
        noSoldListHeader.append("<td style=width=20%>Last Ping</td></tr>");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                tempSoldList.append("<tr style=font-size:x-small height=15><td>");
                tempSoldList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer Name
                tempSoldList.append("</td><td>");
                tempSoldList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                tempSoldList.append("</td><td>");
                tempSoldList.append(HandlerUtils.nullToEmpty(rs.getString(3))); // POS Name
                tempSoldList.append("</td><td>");
                tempSoldList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Ping
                tempSoldList.append("</td></tr>");
                locationSet.add(rs.getInt(5));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getNoSoldEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        if (tempSoldList.length() != 0) {
            noSoldList.append(noSoldListHeader);
            noSoldList.append("");
            noSoldList.append(tempSoldList);
        }
        addLocationAlertlogs(10, locationSet, date);
        return noSoldList;
    }

    private StringBuilder getPreOpenEmail(ResultSet rs, String date) throws HandlerException {

        HashSet<Integer> locationSet        = new HashSet<Integer>();
        StringBuilder preOpenListHeader     = new StringBuilder();
        StringBuilder preOpenList           = new StringBuilder();
        StringBuilder tempPreOpenList       = new StringBuilder();

        preOpenListHeader.append("<tr style=font-size:small height=30><td style=width=30%>Customer</td>");
        preOpenListHeader.append("<td style=width=30%>Location</td>");
        preOpenListHeader.append("<td style=width=20%>Poured</td>");
        preOpenListHeader.append("<td style=width=20%></td></tr>");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                if (rs.getDouble(3) > 100) {
                    tempPreOpenList.append("<tr style=font-size:x-small height=15><td>");
                    tempPreOpenList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer Name
                    tempPreOpenList.append("</td><td>");
                    tempPreOpenList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                    tempPreOpenList.append("</td><td>");
                    tempPreOpenList.append(cf.format(rs.getDouble(3))); // Poured
                    tempPreOpenList.append("</td><td></td></tr>");
                    locationSet.add(rs.getInt(4));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getPreOpenEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        if (tempPreOpenList.length() != 0) {
            preOpenList.append(preOpenListHeader);
            preOpenList.append("");
            preOpenList.append(tempPreOpenList);
        }
        addLocationAlertlogs(11, locationSet, date);
        return preOpenList;
    }

    private StringBuilder getAfterHoursEmail(ResultSet rs, String date) throws HandlerException {

        HashSet<Integer> locationSet        = new HashSet<Integer>();
        StringBuilder afterHoursListHeader  = new StringBuilder();
        StringBuilder afterHoursList        = new StringBuilder();
        StringBuilder tempAfterHoursList    = new StringBuilder();

        afterHoursListHeader.append("<tr style=font-size:small height=30><td style=width=30%>Customer</td>");
        afterHoursListHeader.append("<td style=width=30%>Location</td>");
        afterHoursListHeader.append("<td style=width=20%>Poured</td>");
        afterHoursListHeader.append("<td style=width=20%></td></tr>");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                if (rs.getDouble(3) > 10) {
                    tempAfterHoursList.append("<tr style=font-size:x-small height=15><td>");
                    tempAfterHoursList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer Name
                    tempAfterHoursList.append("</td><td>");
                    tempAfterHoursList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                    tempAfterHoursList.append("</td><td>");
                    tempAfterHoursList.append(cf.format(rs.getDouble(3))); // Poured
                    tempAfterHoursList.append("</td><td></td></tr>");
                    locationSet.add(rs.getInt(4));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getAfterHoursEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        if (tempAfterHoursList.length() != 0) {
            afterHoursList.append(afterHoursListHeader);
            afterHoursList.append("");
            afterHoursList.append(tempAfterHoursList);
        }
        addLocationAlertlogs(12, locationSet, date);
        return afterHoursList;
    }

    private StringBuilder getInterruptionReportEmail(ResultSet rs, String date) throws HandlerException {

        HashSet<Integer> locationSet        = new HashSet<Integer>();
        StringBuilder interruptionReportListHeader
                                            = new StringBuilder();
        StringBuilder interruptionReportList= new StringBuilder();
        StringBuilder tempInterruptionReportList
                                            = new StringBuilder();

        interruptionReportListHeader.append("<tr style=font-size:small height=30><td style=width=30%>Customer</td>");
        interruptionReportListHeader.append("<td style=width=30%>Location</td>");
        interruptionReportListHeader.append("<td style=width=20%>System</td>");
        interruptionReportListHeader.append("<td style=width=20%>Duration*</td></tr>");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                tempInterruptionReportList.append("<tr style=font-size:x-small height=15><td>");
                tempInterruptionReportList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer Name
                tempInterruptionReportList.append("</td><td>");
                tempInterruptionReportList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Location Name
                tempInterruptionReportList.append("</td><td>");
                tempInterruptionReportList.append(HandlerUtils.nullToEmpty(rs.getString(3)));  // System Index
                tempInterruptionReportList.append("</td><td>");
                tempInterruptionReportList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Total Duration
                tempInterruptionReportList.append("</td></tr>");
                locationSet.add(rs.getInt(5));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getInterruptionReportEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        if (tempInterruptionReportList.length() != 0) {
            interruptionReportList.append(interruptionReportListHeader);
            interruptionReportList.append("");
            interruptionReportList.append(tempInterruptionReportList);
        }
        interruptionReportList.append("<tr valign=bottom style=font-size:x-small height=30><td colspan=4>* Duration is in minutes </td></tr>");
        addLocationAlertlogs(13, locationSet, date);
        return interruptionReportList;
    }

    private StringBuilder getLocationStatusAlertEmail(ResultSet rs, String date) throws HandlerException {

        HashSet<Integer> locationSet        = new HashSet<Integer>();
        StringBuilder locationStatusAlertList
                                            = new StringBuilder();

        StringBuilder tempBoxPingList       = new StringBuilder();
        StringBuilder tempGatewayPingList   = new StringBuilder();
        StringBuilder noPouredHeader        = new StringBuilder();
        StringBuilder noSoldHeader          = new StringBuilder();
        
        noSoldHeader.append("<tr align=center valign=middle><td colspan=4 ><strong><span style=text-decoration: underline>No Gateway Communication</span> </strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
        noSoldHeader.append("<tr style=font-size:small height=15><td style=width=30%><strong>Customer Name</strong></td><td style=width=30%><strong>Location Name</strong></td><td style=width=20%><strong>Gateway Type</strong></td><td style=width=20%><strong>Last Reading</strong></td></tr>");
        noPouredHeader.append("<tr align=center><td colspan=4 ><strong><span style=text-decoration: underline>No Controller Communication</span> </strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
        noPouredHeader.append("<tr style=font-size:small height=15><td style=width=30%><strong>Customer Name</strong></td><td style=width=30%><strong>Location Name</strong></td><td style=width=20%><strong>Box Version</strong></td><td style=width=20%><strong>Last Reading</strong></td></tr>");

        try {
            rs.beforeFirst();
            while (rs.next()) {
                switch (rs.getInt(1)) {
                    case 1:
                        tempBoxPingList.append("<tr style=font-size:x-small height=15><td>");
                        tempBoxPingList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Customer Name
                        tempBoxPingList.append("</td><td>");
                        tempBoxPingList.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Location Name
                        tempBoxPingList.append("</td><td>");
                        tempBoxPingList.append(HandlerUtils.nullToEmpty(rs.getString(4)));  // Pico Version
                        tempBoxPingList.append("</td><td>");
                        tempBoxPingList.append(HandlerUtils.nullToEmpty(rs.getString(5))); // Last Ping
                        tempBoxPingList.append("</td></tr>");
                        break;
                    case 2:
                        tempGatewayPingList.append("<tr style=font-size:x-small height=15><td>");
                        tempGatewayPingList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Customer Name
                        tempGatewayPingList.append("</td><td>");
                        tempGatewayPingList.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Location Name
                        tempGatewayPingList.append("</td><td>");
                        tempGatewayPingList.append(HandlerUtils.nullToEmpty(rs.getString(4)));  // Gateway Type
                        tempGatewayPingList.append("</td><td>");
                        tempGatewayPingList.append(HandlerUtils.nullToEmpty(rs.getString(5))); // Last Ping
                        tempGatewayPingList.append("</td></tr>");
                        break;
                    default:
                        break;
                }
                locationSet.add(rs.getInt(6));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationStatusAlertEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }

        if (tempGatewayPingList.length() != 0) {
            locationStatusAlertList.append(noSoldHeader);
            locationStatusAlertList.append("");
            locationStatusAlertList.append(tempGatewayPingList);
        }
        if (locationStatusAlertList.length() != 0) {
            locationStatusAlertList.append("<tr height=30><td colspan=4></td></tr>");
        }

        if (tempBoxPingList.length() != 0) {
            locationStatusAlertList.append(noPouredHeader);
            locationStatusAlertList.append("");
            locationStatusAlertList.append(tempBoxPingList);
        }

        addLocationAlertlogs(14, locationSet, date);
        return locationStatusAlertList;
    }

    private StringBuilder getBBTVStatusAlertEmail(ResultSet rs, String date) throws HandlerException {

        HashSet<Integer> locationSet        = new HashSet<Integer>();
        StringBuilder bbtvStatusAlertList   = new StringBuilder();

        StringBuilder tempActiveList        = new StringBuilder();
        StringBuilder tempInactiveList      = new StringBuilder();
        StringBuilder inactiveHeader        = new StringBuilder();
        StringBuilder activeHeader          = new StringBuilder();

        activeHeader.append("<tr align=center valign=middle><td colspan=4 ><strong><span style=text-decoration: underline>Active BBTV</span> </strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
        activeHeader.append("<tr style=font-size:small height=15><td style=width=30%><strong>Customer</strong></td><td style=width=30%><strong>Version</strong></td><td style=width=20%><strong>Last Login</strong></td><td style=width=20%><strong>Last Ping</strong></td></tr>");
        inactiveHeader.append("<tr align=center><td colspan=4 ><strong><span style=text-decoration: underline>Inactive BBTV</span> </strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
        inactiveHeader.append("<tr style=font-size:small height=15><td style=width=30%><strong>Customer</strong></td><td style=width=30%><strong>Version</strong></td><td style=width=20%><strong>Last Login</strong></td><td style=width=20%><strong>Last Ping</strong></td></tr>");

        try {
            rs.beforeFirst();
            while (rs.next()) {
                switch (rs.getInt(5)) {
                    case 1:
                        tempActiveList.append("<tr style=font-size:x-small height=15><td>");
                        tempActiveList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer
                        tempActiveList.append("</td><td>");
                        tempActiveList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Version
                        tempActiveList.append("</td><td>");
                        tempActiveList.append(HandlerUtils.nullToEmpty(rs.getString(3)));  // Last Login
                        tempActiveList.append("</td><td>");
                        tempActiveList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Last Ping
                        tempActiveList.append("</td></tr>");
                        break;
                    case 2:
                        tempInactiveList.append("<tr style=font-size:x-small height=15><td>");
                        tempInactiveList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer
                        tempInactiveList.append("</td><td>");
                        tempInactiveList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Version
                        tempInactiveList.append("</td><td>");
                        tempInactiveList.append(HandlerUtils.nullToEmpty(rs.getString(3)));  // Last Login
                        tempInactiveList.append("</td><td>");
                        tempInactiveList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Last Ping
                        tempInactiveList.append("</td></tr>");
                        break;
                    default:
                        break;
                }
                locationSet.add(rs.getInt(6));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getBBTVStatusAlertEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }

        if (tempActiveList.length() != 0) {
            bbtvStatusAlertList.append(activeHeader);
            bbtvStatusAlertList.append("");
            bbtvStatusAlertList.append(tempActiveList);
        }
        if (bbtvStatusAlertList.length() != 0) {
            bbtvStatusAlertList.append("<tr height=30><td colspan=4></td></tr>");
        }

        if (tempInactiveList.length() != 0) {
            bbtvStatusAlertList.append(inactiveHeader);
            bbtvStatusAlertList.append("");
            bbtvStatusAlertList.append(tempInactiveList);
        }

        addLocationAlertlogs(21, locationSet, date);
        return bbtvStatusAlertList;
    }

    private StringBuilder getMaxLineCounterAlertEmail(ResultSet rs) throws HandlerException {

        StringBuilder maxLineCounterAlertList
                                            = new StringBuilder();
        maxLineCounterAlertList.append("<tr style=font-size:small height=30><td style=width=50%>Customer - Location</td>");
        maxLineCounterAlertList.append("<td style=width=10%>System - Line</td>");
        maxLineCounterAlertList.append("<td style=width=20%>Product</td>");
        maxLineCounterAlertList.append("<td style=width=20%>Poured*</td></tr>");
        maxLineCounterAlertList.append("");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                maxLineCounterAlertList.append("<tr style=font-size:x-small height=15><td>");
                maxLineCounterAlertList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer - Location Name
                maxLineCounterAlertList.append("</td><td>");
                maxLineCounterAlertList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // System - Line
                maxLineCounterAlertList.append("</td><td>");
                maxLineCounterAlertList.append(HandlerUtils.nullToEmpty(rs.getString(3)));  // Product
                maxLineCounterAlertList.append("</td><td>");
                maxLineCounterAlertList.append(cf.format(rs.getDouble(4))); // Total Poured
                maxLineCounterAlertList.append("</td></tr>");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getMaxLineCounterAlertEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        maxLineCounterAlertList.append("<tr valign=bottom style=font-size:x-small height=30><td colspan=4>* Poured in ounces </td></tr>");
        return maxLineCounterAlertList;
    }

    private StringBuilder getDailyTierEmail(ResultSet rs) throws HandlerException {

        StringBuilder dailyTierListHeader   = new StringBuilder();
        StringBuilder dailyTierCupListHeaderTop
                                            = new StringBuilder();
        StringBuilder dailyTierCupListHeaderBottom
                                            = new StringBuilder();
        StringBuilder tempExceptionsList    = new StringBuilder();
        StringBuilder tempZeroVarList       = new StringBuilder();
        StringBuilder tempTierThreeList     = new StringBuilder();
        StringBuilder tempTierTwoList       = new StringBuilder();
        StringBuilder tempTierOneList       = new StringBuilder();
        StringBuilder dailyTierList         = new StringBuilder();
        Double tier1Count                   = 0.0, tier2Count = 0.0, tier3Count = 0.0, totalTierCount = 0.0;
        double poured                       = 0.0, sold = 0.0, cupsLost = 0.0, cupsSaved = 0.0;
        double totalTier1Poured             = 0.0, totalTier1Sold = 0.0, totalTier1Lost = 0.0, totalTier1Saved = 0.0;
        double totalTier2Poured             = 0.0, totalTier2Sold = 0.0, totalTier2Lost = 0.0, totalTier2Saved = 0.0;
        double totalTier3Poured             = 0.0, totalTier3Sold = 0.0, totalTier3Lost = 0.0, totalTier3Saved = 0.0;

        dailyTierListHeader.append("<tr style=font-size:small height=30 valign=bottom><td style=\"width:70%; border-bottom: dashed 1px black\">Customer - Location</td>");
        dailyTierListHeader.append("<td style=\"width:10%; border-bottom: dashed 1px black\" align=right>Poured</td>");
        dailyTierListHeader.append("<td style=\"width:10%; border-bottom: dashed 1px black\" align=right>Sold</td>");
        dailyTierListHeader.append("<td style=\"width:10%; border-bottom: dashed 1px black\" align=right>Variance</td></tr>");

        dailyTierCupListHeaderTop.append("<tr><td colspan=4 style=\"width:100%;\"><table style=\"width:100%;\">");
        dailyTierCupListHeaderTop.append("<tr style=font-size:small height=30 valign=bottom><td style=\"width:49%; border-bottom: dashed 1px black\">Customer - Location</td>");
        dailyTierCupListHeaderTop.append("<td style=\"width:10%; border-bottom: dashed 1px black\" align=right>Poured</td>");
        dailyTierCupListHeaderTop.append("<td style=\"width:10%; border-bottom: dashed 1px black\" align=right>Sold</td>");
        dailyTierCupListHeaderTop.append("<td style=\"width:10%; border-bottom: dashed 1px black\" align=right>Variance</td>");
        dailyTierCupListHeaderTop.append("<td style=\"width:10%; border-bottom: dashed 1px black\" align=right>Pints Lost</td>");
        dailyTierCupListHeaderTop.append("<td style=\"width:11%; border-bottom: dashed 1px black\" align=right>Pints Saved</td></tr>");
        dailyTierCupListHeaderBottom.append("</table></td></tr>");

        try {
            rs.beforeFirst();
            while (rs.next()) {
                switch(rs.getInt(5)) {
                    case 1:
                        tier1Count++;
                        totalTierCount++;
                        totalTier1Poured    += poured = rs.getDouble(2);
                        totalTier1Sold      += sold = rs.getDouble(3);
                        cupsLost            = (poured - sold)/16;
                        cupsSaved           = ((poured * 0.2)/16) - cupsLost;
                        if (cupsLost < 0 ) { cupsLost = 0;}
                        totalTier1Lost      += cupsLost;
                        totalTier1Saved     += cupsSaved;
                        tempTierOneList.append("<tr style=font-size:x-small height=15><td>");
                        tempTierOneList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer - Location
                        tempTierOneList.append("</td><td align=right>");
                        tempTierOneList.append(cf.format(poured)); // Poured
                        tempTierOneList.append("</td><td align=right>");
                        tempTierOneList.append(cf.format(sold)); // Sold
                        tempTierOneList.append("</td><td align=right>");
                        tempTierOneList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Variance
                        tempTierOneList.append("%</td><td align=right>");
                        tempTierOneList.append(cf.format(cupsLost)); // Cups Lost
                        tempTierOneList.append("</td><td align=right>");
                        tempTierOneList.append(cf.format(cupsSaved)); // Cups Saved
                        tempTierOneList.append("</td></tr>");
                        break;
                    case 2:
                        tier2Count++;
                        totalTierCount++;
                        totalTier2Poured    += poured = rs.getDouble(2);
                        totalTier2Sold      += sold = rs.getDouble(3);
                        cupsLost            = (poured - sold)/16;
                        cupsSaved           = ((poured * 0.2)/16) - cupsLost;
                        totalTier2Lost      += cupsLost;
                        totalTier2Saved     += cupsSaved;
                        tempTierTwoList.append("<tr style=font-size:x-small height=15><td>");
                        tempTierTwoList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer - Location
                        tempTierTwoList.append("</td><td align=right>");
                        tempTierTwoList.append(cf.format(poured)); // Poured
                        tempTierTwoList.append("</td><td align=right>");
                        tempTierTwoList.append(cf.format(sold)); // Sold
                        tempTierTwoList.append("</td><td align=right>");
                        tempTierTwoList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Variance
                        tempTierTwoList.append("%</td><td align=right>");
                        tempTierTwoList.append(cf.format(cupsLost)); // Cups Lost
                        tempTierTwoList.append("</td><td align=right>");
                        tempTierTwoList.append(cf.format(cupsSaved)); // Cups Saved
                        tempTierTwoList.append("</td></tr>");
                        break;
                    case 3:
                        tier3Count++;
                        totalTierCount++;
                        totalTier3Poured    += poured = rs.getDouble(2);
                        totalTier3Sold      += sold = rs.getDouble(3);
                        cupsLost            = (poured - sold)/16;
                        cupsSaved           = ((poured * 0.2)/16) - cupsLost;
                        if (cupsSaved < 0 ) { cupsSaved = 0;}
                        totalTier3Lost      += cupsLost;
                        totalTier3Saved     += cupsSaved;
                        tempTierThreeList.append("<tr style=font-size:x-small height=15><td>");
                        tempTierThreeList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer - Location
                        tempTierThreeList.append("</td><td align=right>");
                        tempTierThreeList.append(cf.format(poured)); // Poured
                        tempTierThreeList.append("</td><td align=right>");
                        tempTierThreeList.append(cf.format(sold)); // Sold
                        tempTierThreeList.append("</td><td align=right>");
                        tempTierThreeList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Variance
                        tempTierThreeList.append("%</td><td align=right>");
                        tempTierThreeList.append(cf.format(cupsLost)); // Cups Lost
                        tempTierThreeList.append("</td><td align=right>");
                        tempTierThreeList.append(cf.format(cupsSaved)); // Cups Saved
                        tempTierThreeList.append("</td></tr>");
                        break;
                    case 4:
                        tempExceptionsList.append("<tr style=font-size:x-small height=15><td>");
                        tempExceptionsList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer - Location
                        tempExceptionsList.append("</td><td align=right>");
                        tempExceptionsList.append(cf.format(rs.getDouble(2))); // Poured
                        tempExceptionsList.append("</td><td align=right>");
                        tempExceptionsList.append(cf.format(rs.getDouble(3))); // Sold
                        tempExceptionsList.append("</td><td align=right>");
                        tempExceptionsList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Variance
                        tempExceptionsList.append("%</td></tr>");
                        break;
                    case 5:
                        tempZeroVarList.append("<tr style=font-size:x-small height=15><td>");
                        tempZeroVarList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer - Location
                        tempZeroVarList.append("</td><td align=right>");
                        tempZeroVarList.append(cf.format(rs.getDouble(2))); // Poured
                        tempZeroVarList.append("</td><td align=right>");
                        tempZeroVarList.append(cf.format(rs.getDouble(3))); // Sold
                        tempZeroVarList.append("</td><td align=right>");
                        tempZeroVarList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Variance
                        tempZeroVarList.append("%</td></tr>");
                        break;
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getDailyTierEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        if (tempExceptionsList.length() != 0) {
            dailyTierList.append("<tr><td colspan=4>Locations with Exceptions</td></tr>");
            dailyTierList.append(dailyTierListHeader);
            dailyTierList.append(tempExceptionsList);
            dailyTierList.append("<tr><td colspan=4 style=\"border-top: dashed 1px black\"></td></tr>");
            dailyTierList.append("<br/>");
        }
        if (tempZeroVarList.length() != 0) {
            dailyTierList.append("<tr><td colspan=4>Locations with Zero Variance</td></tr>");
            dailyTierList.append(dailyTierListHeader);
            dailyTierList.append(tempZeroVarList);
            dailyTierList.append("<tr><td colspan=4 style=\"border-top: dashed 1px black\"></td></tr>");
            dailyTierList.append("<br/>");
        }
        if (tempTierThreeList.length() != 0) {
            dailyTierList.append("<tr><td colspan=4>Tier 3 Locations (Count: " + tier3Count.intValue() + ", Share: " + pf.format((tier3Count/totalTierCount)*100) + "%)");
            dailyTierList.append("</td></tr>");
            dailyTierList.append(dailyTierCupListHeaderTop);
            dailyTierList.append(tempTierThreeList);
            dailyTierList.append("<tr><td colspan=6 style=\"border-top: dashed 1px black\"></td></tr>");
            dailyTierList.append("<tr style=font-size:x-small height=15><td align=center>Total</td><td align=right>");
            dailyTierList.append(cf.format(totalTier3Poured)); // Poured
            dailyTierList.append("</td><td align=right>");
            dailyTierList.append(cf.format(totalTier3Sold)); // Sold
            dailyTierList.append("</td><td align=right>");
            dailyTierList.append(cf.format(((totalTier3Sold-totalTier3Poured)/totalTier3Poured)*100)); // Variance
            dailyTierList.append("%</td><td align=right>");
            dailyTierList.append(cf.format(totalTier3Lost)); // Cups Lost
            dailyTierList.append("</td><td align=right>");
            dailyTierList.append(cf.format(totalTier3Saved)); // Cups Saved
            dailyTierList.append("</td></tr>");
            dailyTierList.append("<tr><td colspan=6 style=\"border-top: dashed 1px black\"></td></tr>");
            dailyTierList.append(dailyTierCupListHeaderBottom);
            dailyTierList.append("<br/>");
        }
        if (tempTierTwoList.length() != 0) {
            dailyTierList.append("<tr><td colspan=4>Tier 2 Locations (Count: " + tier2Count.intValue() + ", Share: " + pf.format((tier2Count/totalTierCount)*100) + "%)");
            dailyTierList.append("</td></tr>");
            dailyTierList.append(dailyTierCupListHeaderTop);
            dailyTierList.append(tempTierTwoList);
            dailyTierList.append("<tr><td colspan=6 style=\"border-top: dashed 1px black\"></td></tr>");
            dailyTierList.append("<tr style=font-size:x-small height=15><td align=center>Total</td><td align=right>");
            dailyTierList.append(cf.format(totalTier2Poured)); // Poured
            dailyTierList.append("</td><td align=right>");
            dailyTierList.append(cf.format(totalTier2Sold)); // Sold
            dailyTierList.append("</td><td align=right>");
            dailyTierList.append(cf.format(((totalTier2Sold-totalTier2Poured)/totalTier2Poured)*100)); // Variance
            dailyTierList.append("%</td><td align=right>");
            dailyTierList.append(cf.format(totalTier2Lost)); // Cups Lost
            dailyTierList.append("</td><td align=right>");
            dailyTierList.append(cf.format(totalTier2Saved)); // Cups Saved
            dailyTierList.append("</td></tr>");
            dailyTierList.append("<tr><td colspan=6 style=\"border-top: dashed 1px black\"></td></tr>");
            dailyTierList.append(dailyTierCupListHeaderBottom);
            dailyTierList.append("<br/>");
        }
        if (tempTierOneList.length() != 0) {
            dailyTierList.append("<tr><td colspan=4>Tier 1 Locations (Count: " + tier1Count.intValue() + ", Share: " + pf.format((tier1Count/totalTierCount)*100) + "%)");
            dailyTierList.append("</td></tr>");
            dailyTierList.append(dailyTierCupListHeaderTop);
            dailyTierList.append(tempTierOneList);
            dailyTierList.append("<tr><td colspan=6 style=\"border-top: dashed 1px black\"></td></tr>");
            dailyTierList.append("<tr style=font-size:x-small height=15><td align=center>Total</td><td align=right>");
            dailyTierList.append(cf.format(totalTier1Poured)); // Poured
            dailyTierList.append("</td><td align=right>");
            dailyTierList.append(cf.format(totalTier1Sold)); // Sold
            dailyTierList.append("</td><td align=right>");
            dailyTierList.append(cf.format(((totalTier1Sold-totalTier1Poured)/totalTier1Poured)*100)); // Variance
            dailyTierList.append("%</td><td align=right>");
            dailyTierList.append(cf.format(totalTier1Lost)); // Cups Lost
            dailyTierList.append("</td><td align=right>");
            dailyTierList.append(cf.format(totalTier1Saved)); // Cups Saved
            dailyTierList.append("</td></tr>");
            dailyTierList.append("<tr><td colspan=6 style=\"border-top: dashed 1px black\"></td></tr>");
            dailyTierList.append(dailyTierCupListHeaderBottom);
            dailyTierList.append("<br/>");
        }
        return dailyTierList;
    }

    private StringBuilder getDailyEmail(ResultSet rs) throws HandlerException {

        StringBuilder dailyVarianceListHeader  = new StringBuilder();
        StringBuilder dailyVarianceList        = new StringBuilder();
        StringBuilder tempDailyVarianceList    = new StringBuilder();

        dailyVarianceListHeader.append("<tr style=font-size:small height=30><td style=width=50%>Customer - Location</td>");
        dailyVarianceListHeader.append("<td style=width=20% align=right>Poured</td>");
        dailyVarianceListHeader.append("<td style=width=20% align=right>Sold</td>");
        dailyVarianceListHeader.append("<td style=width=10% align=right>Variance</td></tr>");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                tempDailyVarianceList.append("<tr style=font-size:x-small height=15><td>");
                tempDailyVarianceList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer - Location
                tempDailyVarianceList.append("</td><td align=right>");
                tempDailyVarianceList.append(cf.format(rs.getDouble(2))); // Poured
                tempDailyVarianceList.append("</td><td align=right>");
                tempDailyVarianceList.append(cf.format(rs.getDouble(3))); // Sold
                tempDailyVarianceList.append("</td><td align=right>");
                tempDailyVarianceList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Variance
                tempDailyVarianceList.append("%</td></tr>");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getDailyEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        if (tempDailyVarianceList.length() != 0) {
            dailyVarianceList.append(dailyVarianceListHeader);
            dailyVarianceList.append("");
            dailyVarianceList.append(tempDailyVarianceList);
        }
        return dailyVarianceList;
    }

    private StringBuilder getDailyUnknownSalesEmail(ResultSet rs) throws HandlerException {

        StringBuilder dailyUnknownSalesHeader  = new StringBuilder();
        StringBuilder dailyUnknownSales        = new StringBuilder();
        StringBuilder tempUnknownSalesList    = new StringBuilder();

        dailyUnknownSalesHeader.append("<tr style=font-size:small height=30><td style=width=50%>Product Name</td>");
        dailyUnknownSalesHeader.append("<td style=width=30% align=right>PLU/Item Number</td>");
        dailyUnknownSalesHeader.append("<td style=width=20% align=right>Quantity Sold</td></tr>");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                tempUnknownSalesList.append("<tr style=font-size:x-small height=15><td>");
                tempUnknownSalesList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Product Name
                tempUnknownSalesList.append("</td><td align=right>");
                tempUnknownSalesList.append(HandlerUtils.nullToEmpty(rs.getString(2))); // PLU/Item Number
                tempUnknownSalesList.append("</td><td align=right>");
                tempUnknownSalesList.append(cf.format(rs.getDouble(3))); // Quantity Sold
                tempUnknownSalesList.append("</td></td></tr>");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getDailyUnknownSalesEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        if (tempUnknownSalesList.length() != 0) {
            dailyUnknownSales.append(dailyUnknownSalesHeader);
            dailyUnknownSales.append("");
            dailyUnknownSales.append(tempUnknownSalesList);
        }
        return dailyUnknownSales;
    }

    private StringBuilder getMonthlyThirdTierEmail(ResultSet rs) throws HandlerException {

        StringBuilder monthlyThirdTierListHeader  = new StringBuilder();
        StringBuilder monthlyThirdTierList        = new StringBuilder();
        StringBuilder tempMonthlyThirdTierList    = new StringBuilder();

        monthlyThirdTierListHeader.append("<tr style=font-size:small height=30><td style=width=30%>Customer - Location</td>");
        monthlyThirdTierListHeader.append("<td style=width=25% align=right>Poured</td>");
        monthlyThirdTierListHeader.append("<td style=width=25% align=right>Sold</td>");
        monthlyThirdTierListHeader.append("<td style=width=20% align=right>Var</td></tr>");
        try {
            rs.beforeFirst();
            while (rs.next()) {
                tempMonthlyThirdTierList.append("<tr style=font-size:x-small height=15><td>");
                tempMonthlyThirdTierList.append(HandlerUtils.nullToEmpty(rs.getString(1))); // Customer - Location
                tempMonthlyThirdTierList.append("</td><td align=right>");
                tempMonthlyThirdTierList.append(cf.format(rs.getDouble(2))); // Poured
                tempMonthlyThirdTierList.append("</td><td align=right>");
                tempMonthlyThirdTierList.append(cf.format(rs.getDouble(3))); // Sold
                tempMonthlyThirdTierList.append("</td><td align=right>");
                tempMonthlyThirdTierList.append(HandlerUtils.nullToEmpty(rs.getString(4))); // Variance
                tempMonthlyThirdTierList.append("%</td></tr>");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getThirdTierEmail: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
        }
        if (tempMonthlyThirdTierList.length() != 0) {
            monthlyThirdTierList.append(monthlyThirdTierListHeader);
            monthlyThirdTierList.append("");
            monthlyThirdTierList.append(tempMonthlyThirdTierList);
        }
        return monthlyThirdTierList;
    }

    public void addLocationAlertlogs(int alertType, HashSet<Integer> locationSet, String date) {
        String insertLocationAlertLog       = "INSERT INTO locationAlertLogs (location, alertType, date) VALUES (?,?,LEFT(?,10));";
        PreparedStatement stmt = null;
        try {
            for (Integer location : locationSet) {
                stmt = transconn.prepareStatement(insertLocationAlertLog);
                stmt.setInt(1, location);
                stmt.setInt(2, alertType);
                stmt.setString(3, date);
                stmt.executeUpdate();
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getAfterHoursEmail: " + sqle.getMessage());
        } finally {
            close(stmt);
        }
    }

    /**  Return a list of all associated suppliers from this location
     */
    private void getLocationDetails(Element toHandle, Element toAppend) throws HandlerException {

        int location                        = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int customer                        = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int parameter                       = 0;
        String select                       = "SELECT l.id, c.name, l.name, lD.active, lD.pouredUp, lD.soldUp, lD.data, lD.billing, lD.cancelled, lD.support, lD.suspended, lD.beerboard " +
                                            " FROM location l LEFT JOIN locationDetails lD ON lD.location = l.id LEFT JOIN customer c ON c.id = l.customer ";
        String selectBBTV                   = "SELECT c.name, l.name, b.name, b.lastPing, b.mac, b.version, b.lastPing + INTERVAL l.easternOffset HOUR FROM beerboard b " +
                                            " LEFT JOIN location l ON l.id = b.location LEFT JOIN locationDetails lD ON lD.location = l.id LEFT JOIN customer c ON c.id = l.customer ";
        String selectBBTVUser               = "SELECT c.name, l.name, b.name, b.lastPing, b.wmac, b.version, b.lastPing + INTERVAL l.easternOffset HOUR FROM bbtvUserMac b " +
                                            " LEFT JOIN location l ON l.id = b.location LEFT JOIN locationDetails lD ON lD.location = l.id LEFT JOIN customer c ON c.id = l.customer ";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {

            if (location > 0) {
                select                      += " WHERE lD.active = 1 AND l.id = ? ";
                selectBBTV                  += " WHERE lD.active = 1 AND b.location = ? ";
                selectBBTVUser              += " WHERE lD.active = 1 AND b.location = ? ";
                parameter                   = location;
            } else if (customer > 0) {
                select                      += " WHERE lD.active = 1 AND l.customer = ? ";
                selectBBTV                  += " WHERE lD.active = 1 AND l.customer = ? ";
                selectBBTVUser              += " WHERE lD.active = 1 AND l.customer = ? ";
                parameter                   = customer;
            } else {
                select                      += " WHERE lD.active = ? ";
                selectBBTV                  += " WHERE lD.active = ? ";
                selectBBTVUser              += " WHERE lD.active = ? ";
                parameter                   = 1;
            }
            select                          += " ORDER BY l.name";
            
            stmt                            = transconn.prepareStatement(select);
            stmt.setInt(1, parameter);
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                int colCount                = 1;
                Element ld                  = toAppend.addElement("locationDetails");
                ld.addElement("locationId").addText(String.valueOf(rs.getInt(colCount++)));
                ld.addElement("customerName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                ld.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                ld.addElement("active").addText(String.valueOf(rs.getInt(colCount++)));
                ld.addElement("pouredUp").addText(String.valueOf(rs.getInt(colCount++)));
                ld.addElement("soldUp").addText(String.valueOf(rs.getInt(colCount++)));
                ld.addElement("data").addText(String.valueOf(rs.getInt(colCount++)));
                ld.addElement("billing").addText(String.valueOf(rs.getInt(colCount++)));
                ld.addElement("cancelled").addText(String.valueOf(rs.getInt(colCount++)));
                ld.addElement("support").addText(String.valueOf(rs.getInt(colCount++)));
                ld.addElement("suspended").addText(String.valueOf(rs.getInt(colCount++)));
                ld.addElement("bbtv").addText(String.valueOf(rs.getInt(colCount++)));
            }
            
            boolean oldBBTVUser             = true;
            stmt                            = transconn.prepareStatement(selectBBTVUser);
            stmt.setInt(1, parameter);
            rs                              = stmt.executeQuery();
            while(rs.next()) {
                oldBBTVUser                 = false;
                Element bbtv = toAppend.addElement("bbtvDetails");
                bbtv.addElement("customerName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                bbtv.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                bbtv.addElement("bbtvName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                bbtv.addElement("lastPoured").addText(HandlerUtils.nullToEmpty((customer > 0) ? (rs.getString(4)) : (rs.getString(7))));
                bbtv.addElement("mac").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                bbtv.addElement("version").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
            }
            
            if (oldBBTVUser) {
                stmt                        = transconn.prepareStatement(selectBBTV);
                stmt.setInt(1, parameter);
                rs                          = stmt.executeQuery();
                while(rs.next()) {
                    Element bbtv = toAppend.addElement("bbtvDetails");
                    bbtv.addElement("customerName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    bbtv.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    bbtv.addElement("bbtvName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    bbtv.addElement("lastPoured").addText(HandlerUtils.nullToEmpty((customer > 0) ? (rs.getString(4)) : (rs.getString(7))));
                    bbtv.addElement("mac").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                    bbtv.addElement("version").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationDetails: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**
     * Deativating all alerts from the night before
     */
    private void getSuspensions(Element toHandle, Element toAppend) throws HandlerException {

        int location                        = HandlerUtils.getOptionalInteger(toHandle, "locationId");

        String selectSuspensions            = "SELECT location, startDate, endDate, description FROM suspensionLogs WHERE active = 1 ";
        if (location > 0) {
            selectSuspensions               += " WHERE location = ? ";
        }

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            stmt                            = transconn.prepareStatement(selectSuspensions);
            if (location > 0) {
                stmt.setInt(1, location);
            }
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                Element lsd = toAppend.addElement("locationSuspensionDetails");
                lsd.addElement("locationId").addText(String.valueOf(rs.getInt(1)));
                lsd.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                lsd.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                lsd.addElement("description").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /**
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - NS
     */
    private void getReportList(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = "";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getReportList");

        try {
            int locationType                = HandlerUtils.getOptionalInteger(toHandle, "customerType");
            //NischaySharma_10-Feb-2009_Start: added new parameters to the handler
            //to define if report list is required for bevsync or bevmanager
            String enabledString            = HandlerUtils.getOptionalString(toHandle, "enable");
            String bevSyncString            = HandlerUtils.getOptionalString(toHandle, "bevSync");
            boolean enabled                 = enabledString.toLowerCase().compareTo("true") == 0 ? true : false;
            boolean bevSync                 = bevSyncString.toLowerCase().compareTo("true") == 0 ? true : false;

            boolean boss                    = HandlerUtils.getOptionalBoolean(toHandle, "boss");
            boolean bevManager              = HandlerUtils.getOptionalBoolean(toHandle, "bevManager");


            if (enabled) {
                select = " select id, title, file, name from usbn.report where enabled is true and customerType = ? order by sequence asc;";
            } else if (bevSync) {
                select = " select id, title, file, name from usbn.report where bevSync is true order by sequence asc;";
            } else if (boss) {
                select = " select id, title, file, name from usbn.report where boss is true order by sequence asc;";
            }  else {
                throw new HandlerException("USBN Paltform was not specified");
            }
            //NischaySharma_10-Feb-2009_End

            stmt = transconn.prepareStatement(select);
            if (enabled) {
                stmt.setInt(1, locationType);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element p = toAppend.addElement("report");
                p.addElement("id").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                p.addElement("title").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                p.addElement("file").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                p.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    private void getBevBoxXML(Element toAppend, ResultSet rs, boolean getDetails, boolean getCoords) throws SQLException {
        while (rs.next()) {
            int colCount                    = 1;
            Element bevBoxEl                = toAppend.addElement("bevBox");
            bevBoxEl.addElement("id").addText(String.valueOf(rs.getInt(colCount++)));
            bevBoxEl.addElement("name").addText(String.valueOf(rs.getString(colCount++)));
            bevBoxEl.addElement("locationId").addText(String.valueOf(rs.getInt(colCount++)));
            bevBoxEl.addElement("totalSystems").addText(String.valueOf(rs.getInt(colCount++)));
            bevBoxEl.addElement("startSystem").addText(String.valueOf(rs.getInt(colCount++)));
            bevBoxEl.addElement("systemInterval").addText(String.valueOf(rs.getInt(colCount++)));
            bevBoxEl.addElement("lastPoured").addText(String.valueOf(rs.getString(colCount++)));
            bevBoxEl.addElement("version").addText(String.valueOf(rs.getString(colCount++)));
            bevBoxEl.addElement("active").addText(String.valueOf(rs.getInt(colCount++)));
            bevBoxEl.addElement("alert").addText(String.valueOf(rs.getInt(colCount++)));
            bevBoxEl.addElement("mac").addText(String.valueOf(rs.getString(colCount++)));
            if (getDetails) {
                bevBoxEl.addElement("dhcp").addText(String.valueOf(rs.getInt(colCount++)));
                bevBoxEl.addElement("ip").addText(String.valueOf(rs.getString(colCount++)));
                bevBoxEl.addElement("gateway").addText(String.valueOf(rs.getString(colCount++)));
                bevBoxEl.addElement("netmask").addText(String.valueOf(rs.getString(colCount++)));
                bevBoxEl.addElement("dns1").addText(String.valueOf(rs.getString(colCount++)));
                bevBoxEl.addElement("dns2").addText(String.valueOf(rs.getString(colCount++)));
            }
            if (getCoords) {
                bevBoxEl.addElement("latitude").addText(String.valueOf(rs.getDouble(colCount++)));
                bevBoxEl.addElement("longitude").addText(String.valueOf(rs.getDouble(colCount++)));
            }
        }
    }

    private void getBevBox(Element toHandle, Element toAppend) throws HandlerException {

        int id                              = HandlerUtils.getOptionalInteger(toHandle, "bevBoxId");
        int refLocationId                   = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int refBOSSId                       = HandlerUtils.getOptionalInteger(toHandle, "bossId");
        boolean getDetails                  = HandlerUtils.getOptionalBoolean(toHandle, "getDetails");
        boolean getCoords                   = HandlerUtils.getOptionalBoolean(toHandle, "getCoords");
        
        int paramsSet                       = 0;
        if (id >= 0) {
            paramsSet++;
        }
        if (refLocationId >= 0) {
            paramsSet++;
        }
        if (refBOSSId >= 0) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getBevBox.");
        }

        String select                       = "SELECT b.id, b.name, b.location, b.totalSystems, b.startSystem, b.systemInterval, b.lastPoured, b.version, b.active, b.alert, b.mac ";
        if (getDetails) {
            select                          += ", b.dhcp, INET_NTOA(b.ip), INET_NTOA(b.gateway), INET_NTOA(b.netmask), INET_NTOA(b.dns1), INET_NTOA(b.dns2) ";
        }
        if (getCoords) {
            select                          += ", b.latitude, b.longitude ";
        }
        select                              += " FROM bevBox b ";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) { throw new HandlerException("Foreign Key Not found : location " + refLocationId);
                }
                select                      += " WHERE b.location = ?";
                stmt                        = transconn.prepareStatement(select);
                stmt.setInt(1, refLocationId);
                rs                          = stmt.executeQuery();
            } else if (refBOSSId >= 0) {
                if (!checkForeignKey("BOSS_Location", "id", refBOSSId)) { throw new HandlerException("Foreign Key Not found : BOSS_Location " + refBOSSId);
                }
                select                      += " LEFT JOIN BOSS_Location BL ON BL.usbn_location = b.location WHERE BL.id = ?";
                stmt                        = transconn.prepareStatement(select);
                stmt.setInt(1, refBOSSId);
                rs                          = stmt.executeQuery();
            } else if (id >= 0) {
                select                      += " WHERE b.id = ?";
                stmt                        = transconn.prepareStatement(select);
                stmt.setInt(1, id);
                rs                          = stmt.executeQuery();
            }
            getBevBoxXML(toAppend, rs, getDetails, getCoords);
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getLocationRights(Element toHandle, Element toAppend) throws HandlerException {

        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int userId                          = HandlerUtils.getOptionalInteger(toHandle, "userId");

        String select                       = "SELECT lR.location, rh.id, rh.name, rh.type FROM rights rh LEFT JOIN locationRights lR ON lR.rights = rh.id " +
                                            " LEFT JOIN locationDetails lD ON lD.location = lR.location ";
        int paramsSet                       = 0, paramValue = 0;
        if (locationId >= 0) {
            paramsSet++;
            select                         += " WHERE lD.active = 1 AND lD.data = 1 AND lR.location = ? ";
            paramValue                      = locationId;
        }
        if (userId >= 0) {
            paramsSet++;
            select                         += " LEFT JOIN location l ON l.id = lR.location LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                                            " LEFT JOIN groupRegionMap gRM ON gRM.regionMaster = rCM.region" +
                                            " LEFT JOIN region r ON r.regionGroup = gRM.id" +
                                            " LEFT JOIN userRegionMap uRM ON uRM.region = r.id " +
                                            " WHERE lD.active = 1 AND lD.data = 1 AND uRM.user = ? ";
            paramValue                      = userId;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getLocationRights.");
        }

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        try {
            stmt                            = transconn.prepareStatement(select);
            stmt.setInt(1, paramValue);
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                Element p                   = toAppend.addElement("rights");
                p.addElement("location").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                p.addElement("id").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                p.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                p.addElement("type").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getLineCleaning(Element toHandle, Element toAppend) throws HandlerException {
        int locationId                      = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String time                         = HandlerUtils.getRequiredString(toHandle, "time");
        int callerId                        = getCallerId(toHandle);

        String selectLineCleaning           = "SELECT id,TIMESTAMPDIFF(MINUTE,startTime,endTime) FROM lineCleaning WHERE location = ? AND ? BETWEEN startTime and endTime";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            stmt                            = transconn.prepareStatement(selectLineCleaning);
            stmt.setInt(1, locationId);
            stmt.setString(2, time);
            rs                              = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("state").addText("true");
                toAppend.addElement("cleanTime").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            } else {
                toAppend.addElement("state").addText("false");
                 toAppend.addElement("cleanTime").addText("120");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**  Return a list of all associated suppliers from this location
     */
    private void getCustomerPeriods(Element toHandle, Element toAppend) throws HandlerException {

        int location                        = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int customer                        = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        String date                         = HandlerUtils.getOptionalString(toHandle, "periodDate");
        int periodId                        = HandlerUtils.getOptionalInteger(toHandle, "periodId");
        boolean getPastPeriods              = HandlerUtils.getOptionalBoolean(toHandle, "getPastPeriods");

        String select                       = "", conditionString = "";
        int parameter                       = -1;

        if (customer > 0) {
            conditionString                 = " WHERE cP.customer = ? ";
            parameter                       = customer;
        } else {
            conditionString                 = " LEFT JOIN location l ON l.customer = cP.customer WHERE l.id = ? ";
            parameter                       = location;
        }
        
        select                              = " SELECT cP.id, cP.customer, cP.date, cP.start, cP.end, cP.description " +
                                            " FROM customerPeriods cP " + conditionString;

        if (date != null && !date.equals("")) {
            select                          += " AND DATEDIFF(cP.date, '" + date + "') = 0 ";
        }
        if (periodId > 0 ){
            select                          += " AND cP.id = ? ";
        }

        if(!getPastPeriods)
        {
            select                          += " AND cP.date > LEFT(SUBDATE(NOW(),1),10) ";
        }

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            stmt                            = transconn.prepareStatement(select);
            stmt.setInt(1, parameter);
            if(periodId > 0){ stmt.setInt(2, periodId); }
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                int i                       = 1;
                Element period              = toAppend.addElement("periodDates");
                period.addElement("periodId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                period.addElement("customerId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                period.addElement("periodDate").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                period.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                period.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                period.addElement("periodDesc").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getCustomerPeriods: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**  Return a list of all product categories
     */
    private void getProductCategory(Element toHandle, Element toAppend) throws HandlerException {

        int productId                       = HandlerUtils.getOptionalInteger(toHandle, "productId");
        int prodctType                      = HandlerUtils.getRequiredInteger(toHandle, "pType");
        String select                       = "SELECT p.id, c.id, c.name FROM product p LEFT JOIN category c ON c.id = p.category WHERE p.pType = ? ";
        if (productId > 0) {
            select                          += " AND p.id=? ";
        }

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            stmt                            = transconn.prepareStatement(select);
            stmt.setInt(1, prodctType);
            if (productId > 0) {
                stmt.setInt(2, productId);
            }
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                Element cat                 = toAppend.addElement("prodCategory");
                cat.addElement("product").addText(String.valueOf(rs.getInt(1)));
                cat.addElement("category").addText(String.valueOf(rs.getInt(2)));
                cat.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductCategory: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
    
    
    private void addUpdateLocationLogo(Element toHandle, Element toAppend) throws Exception {

        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String logo                         = HandlerUtils.getRequiredString(toHandle, "logo");
        
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        String selectLogo                   = "SELECT  logo FROM locationGraphics  WHERE  location = ? ";
        String insertLogo                   = "INSERT INTO locationGraphics (location, logo) VALUES (?, ?)";
        String updateLogo                   = "UPDATE locationGraphics SET logo = ?  WHERE location = ? ; ";
        String updateBeerBoard              = "UPDATE locationBeerBoardMap SET logo = ?  WHERE location = ? ; ";
        try {
            stmt                            = transconn.prepareStatement(selectLogo);
            stmt.setInt(1, location);
            rs                              = stmt.executeQuery();
            if(rs.next()) {
                stmt                        = transconn.prepareStatement(updateLogo);
                stmt.setString(1, logo);
                stmt.setInt(2, location);
                stmt.executeUpdate();
                stmt                        = transconn.prepareStatement(updateBeerBoard);
                stmt.setInt(1, 1);
                stmt.setInt(2, location);
                stmt.executeUpdate();
                 
            } else {
                int id                      = 0;
                String getLastId            = " SELECT LAST_INSERT_ID()";
                stmt                        = transconn.prepareStatement(insertLogo);
                stmt.setInt(1, location);
                stmt.setString(2, logo);              
                stmt.executeUpdate();
                stmt                        = transconn.prepareStatement(getLastId);
                rs                          = stmt.executeQuery();
                if (rs.next()) {
                    id                      = rs.getInt(1);
                }
                
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }
    
    private void getLocationLogo(Element toHandle, Element toAppend) throws HandlerException {

        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String selectLogo                   = "SELECT  logo FROM locationGraphics  WHERE  location = ? ";
        

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

         try {
            stmt                            = transconn.prepareStatement(selectLogo);
            stmt.setInt(1, location);
            rs                              = stmt.executeQuery();
            if(rs.next()) {
                
                toAppend.addElement("logo").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
               
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationLogo: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
    
    
    private void getBBTVFonts(Element toHandle, Element toAppend) throws HandlerException {

        
        String selectFonts                  = "SELECT  id, name, fileName FROM fonts ORDER BY name ";
        

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

         try {
             stmt                            = transconn.prepareStatement(selectFonts);
             rs                              = stmt.executeQuery();
             while (rs.next()) {
                 Element font                 = toAppend.addElement("fonts");
                 font.addElement("id").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                 font.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                 font.addElement("fileName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                 
             }
         } catch (SQLException sqle) {
            logger.dbError("Database error in getFonts: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
    
    
    private void getBBTVDesign(Element toHandle, Element toAppend) throws HandlerException {

        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String selectDesign[]               = {"Location Specials","Beer Category","Beer Name","Beer Style","Beer Abv","Draft Size"};
        String selectType                   = "SELECT  font, size FROM locationFontMap WHERE location = ? AND type = ? ; ";
        String selectCount                  = "SELECT menuItemCount FROM locationMenu WHERE location = ? ; ";

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

         try {
             stmt                            = transconn.prepareStatement(selectCount);
             stmt.setInt(1,location);
             int   count                    = 9;
             rs                              = stmt.executeQuery();
             if (rs.next()) {
                 count                      = rs.getInt(1);
             }
             toAppend.addElement("count").addText(String.valueOf(count));
             
             for(int i=0;i<selectDesign.length;i++) {
                 int t                          = i+1;
                 int size                       = 0;
                 int font                       = 0;
                 if(t==1) {
                     size                   = 45; 
                     font                   = 3;
                 } else if(t==2) {
                     size                   = 26;
                     font                   = 2;
                 } else if(t==3) {
                     size                   = 52;
                     font                   = 1;
                 } else if(t==4) {
                     size                   = 26;
                     font                   = 1;
                 }  else if(t==5) {
                     size                   = 20;  
                    font                   = 3;
                } else if(t==6) {
                     size                   = 30;  
                    font                   = 1;
                } 
                 stmt                            = transconn.prepareStatement(selectType);
                 stmt.setInt(1,location);
                 stmt.setInt(2,t);
                 rs                              = stmt.executeQuery();
             if (rs.next()) {
                 font                           =rs.getInt(1);
                 size                           = rs.getInt(2);              
                 
             }
                 Element design                 = toAppend.addElement("design");
                 design.addElement("type").addText(String.valueOf(t));
                 design.addElement("name").addText(HandlerUtils.nullToEmpty(selectDesign[i]));
                 design.addElement("font").addText(String.valueOf(font));
                 design.addElement("size").addText(String.valueOf(size));
                                
                 
             }
         } catch (SQLException sqle) {
            logger.dbError("Database error in getFonts: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
    
    
   private void getBeerBoardSettings(Element toHandle, Element toAppend) throws HandlerException {

        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String selectTemplate               = "SELECT template FROM locationBeerBoardMap WHERE location = ? ";
        

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

         try {
             stmt                            = transconn.prepareStatement(selectTemplate);
             stmt.setInt(1, location);
             rs                              = stmt.executeQuery();
             if (rs.next()) {
                 int template = rs.getInt(1);
                 
                 Element templateEl1             = toAppend.addElement("template");
                 templateEl1.addElement("id").addText(String.valueOf(template));
                 switch(template) {                     
                     case 1:                         
                         templateEl1.addElement("name").addText("9 Beer Brands");
                       break;                         
                         case 2:
                         
                         templateEl1.addElement("name").addText("6 Beer Brands");
                         break;
                      case 3:
                        
                         templateEl1.addElement("name").addText("4 Beer Brands");
                         break;
                         
                         
                 }
                 
                 
                 
             }
         } catch (SQLException sqle) {
            logger.dbError("Database error in getTemplate: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
   
   //GenericHandler
   private void getLocationErrorDetail(Element toHandle, Element toAppend) throws HandlerException {

        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String selectLocation = "SELECT name FROM location WHERE id=?";
        String selectLocationError = "SELECT message, level, datetime FROM clientError WHERE location=? ORDER BY datetime DESC LIMIT 5";

        try {
            stmt = transconn.prepareStatement(selectLocation);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }

            stmt = transconn.prepareStatement(selectLocationError);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();

            while (rs.next()) {
                Element line = toAppend.addElement("error");
                line.addElement("message").addText(rs.getString(1));
                line.addElement("level").addText(rs.getString(2));
                line.addElement("datetime").addText(rs.getString(3));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }
   
   
   private String getGenericResult(Element toHandle, Element toAppend) throws HandlerException {


        String query = HandlerUtils.getRequiredString(toHandle, "query");
        PreparedStatement stmt = null;
        ResultSet rs = null;
        String queryResult = null;
        String sql = query;

        try {
            stmt = transconn.prepareStatement(sql);
            rs = stmt.executeQuery();

            int i = 1;
            String totalrow = "";
            while (rs.next()) {
                try {
                    while (rs.getObject(i) != null) {
                        totalrow = totalrow + String.valueOf(rs.getObject(i) + ", ");
                        i = i + 1;
                    }
                } catch (SQLException sqle1) {
                }
                toAppend.addElement("queryResult").addText(HandlerUtils.nullToEmpty(totalrow));
                i = 1;
                totalrow = "";
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
            return queryResult;
        }
    }
   
   
   private void authTestUser(Element toHandle, Element toAppend)
            throws HandlerException {

        final int HQ_CUSTID = 10;
        final int ROOT_CUSTOMER = 0;
        //final String ADMIN_SECURITY_STRING = "1";
        //final String SUPERVISOR_SECURITY_STRING = "3";

        String username = HandlerUtils.getRequiredString(toHandle, "username");
        String password = HandlerUtils.getRequiredString(toHandle, "password");

        String checkRoot = "SELECT u.id, u.isManager, isITAdmin, u.lastCustomer, u.customer FROM user u " +
                " WHERE u.username = ? AND u.password = ? ";

        String selectNormal = "SELECT l.id, l.name, l.type, c.id, c.name, c.type, l.easternOffset, l.volAdjustment, m.securityLevel" +
                " FROM userMap m " +
                " LEFT JOIN location l ON m.location = l.id " +
                " LEFT JOIN customer c ON l.customer = c.id " +
                " WHERE m.user=? " +
                " ORDER BY m.securityLevel ASC, l.name ASC";

        String selectRoot = "SELECT l.id, l.name, l.type, c.id, c.name, c.type, l.easternOffset, l.volAdjustment" +
                " FROM customer c " +
                " LEFT JOIN location l ON l.customer = c.id " +
                " WHERE c.id=? " +
                " ORDER BY l.name ASC ";


        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            // we need to know if the user has Admin access
            stmt = transconn.prepareStatement(checkRoot);
            stmt.setString(1, username);
            stmt.setString(2, password);
            rs = stmt.executeQuery();

            int isManager = -1;
            int isITAdmin = -1;
            int userId = -1;
            int customerToLoad = 0;
            int associatedCustomer = -1;
            boolean isSuperAdmin = false;
            if (rs != null && rs.next()) {
                int rsIndex = 1;
                userId = rs.getInt(rsIndex++);
                isManager = rs.getInt(rsIndex++);
                isITAdmin = rs.getInt(rsIndex++);
                customerToLoad = rs.getInt(rsIndex++);
                associatedCustomer = rs.getInt(rsIndex++);
                if (associatedCustomer == ROOT_CUSTOMER) {
                    if (customerToLoad <= 0) {
                        customerToLoad = HQ_CUSTID;
                    }
                    isSuperAdmin = true;
                } else {
                    customerToLoad = associatedCustomer;
                    isSuperAdmin = false;
                }
                toAppend.addElement("userId").addText(String.valueOf(userId));
            }
            if (isManager > 0) {
                // the user is an Admin (root)
                String logMessage = "Granting " + (isSuperAdmin ? "Admin" : "Super-manager") + " access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, transconn);
                stmt = transconn.prepareStatement(selectRoot);
                stmt.setInt(1, customerToLoad);
                rs = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    WebPermission perm = isSuperAdmin ? WebPermission.instanceOfUsbnAdmin() : WebPermission.instanceOfCustomerAdmin();
                    locEl.addElement("securityLevel").addText(String.valueOf(perm.getLevel()));

                }
            } else if (isITAdmin > 0) {
                // the user is an Admin (root)
                String logMessage = "Granting " + (isSuperAdmin ? "Admin" : "Super-manager") + " access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, transconn);
                stmt = transconn.prepareStatement(selectRoot);
                stmt.setInt(1, customerToLoad);
                rs = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    WebPermission perm = isSuperAdmin ? WebPermission.instanceOfUsbnAdmin() : WebPermission.instanceOfITAdmin();
                    locEl.addElement("securityLevel").addText(String.valueOf(perm.getLevel()));

                }
            } else if (userId >= 0) {
                // the user is not an Admin(root)
                String logMessage = "Granting map-level access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, transconn);
                stmt = transconn.prepareStatement(selectNormal);
                stmt.setInt(1, userId);
                rs = stmt.executeQuery();

                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("locationType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("securityLevel").addText(String.valueOf(rs.getInt(rsIndex++)));

                }
            } else {
                logger.portalAction("Authentication failed for " + username);
                // authentication failed
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

   
   private void getProducts1(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "productId");
        String name = HandlerUtils.getOptionalString(toHandle, "name");
        int prodType = HandlerUtils.getOptionalInteger(toHandle, "prodType");
        int brewery = HandlerUtils.getOptionalInteger(toHandle, "breweryId");
        
        int paramsSet = 0;
        if (id >= 0) {
            paramsSet++;
        }
        if ( null != name && !name.equals("")) {
            paramsSet++;
        }
        if (brewery >= 0) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getProducts.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;
        String select = "SELECT p.id, p.name, p.category, p.segment, p.isActive, " +
                        " pD.boardName, pD.abv, pD.category, pD.origin, sL.logo, CONCAT(bL.logo, IF(bL.type = 0, '.png', IF(bL.type = 1, '.jpg', '.gif'))),  pD.seasonality, pSM.productSet,p.approved " +
                        " FROM product p LEFT JOIN productDescription pD ON pD.product = p.id " +
                        " LEFT JOIN productSetMap sPSM ON sPSM.product = pD.product LEFT JOIN productSet sPS ON sPS.id = sPSM.productSet " +
                        " LEFT JOIN styleLogo sL ON sL.style = sPS.name  " +
                        " LEFT JOIN productSetMap pSM ON pSM.product = pD.product LEFT JOIN productSet pS ON pS.id = pSM.productSet " +
                        "LEFT JOIN breweryLogo bL ON bL.brewery = pS.name ";
        String changeLogVersion             = "SELECT max(date) from productChangeLog;";
        


        try {

            if (id > 0) {
                //NischaySharma_24-Jun-2010_Start
                //NischaySharma_02-Mar-2010_Start
                String selectById = select + " WHERE pS.productSetType = 7 AND sPS.productSetType = 9 AND p.isActive = 1 AND p.id = ?";
                stmt = transconn.prepareStatement(selectById);
                stmt.setInt(1, id);
                rs = stmt.executeQuery();
                getProducts1XML(toAppend, rs);
            } //NischaySharma_08-May-2009_Start: Added check if that if name is empty string then
            //do not execue the query for name
            else if (brewery > 0) {
                //NischaySharma_24-Jun-2010_Start
                //NischaySharma_02-Mar-2010_Start
                String selectByBrewery = select +  " WHERE pS.productSetType = 7 AND sPS.productSetType = 9 AND p.isActive = 1 AND pSM.productSet = ?";
                stmt = transconn.prepareStatement(selectByBrewery);
                stmt.setInt(1, brewery);
                rs = stmt.executeQuery();
                getProducts1XML(toAppend, rs);
            } //NischaySharma_08-May-2009_Start: Added check if that if name is empty string then
            //do not execue the query for name
            else if (null != name && !name.equals("")) {
                String selectByName = select + "WHERE pS.productSetType = 7 AND sPS.productSetType = 9 AND p.isActive = 1 AND p.name LIKE ?";
                name = '%' + name + '%';
                stmt = transconn.prepareStatement(selectByName);
                stmt.setString(1, name);
                rs = stmt.executeQuery();
                getProducts1XML(toAppend, rs);
            } //NischaySharma_08-May-2009_End
            else {
                //logger.debug("SelectAll");
                String selectAll = select + " WHERE pS.productSetType = 7 AND sPS.productSetType = 9 AND p.isActive = 1 AND p.id > 0 AND p.pType = ?";
                //NischaySharma_24-Jun-2010_Start
                //NischaySharma_02-Mar-2010_End
                stmt = transconn.prepareStatement(selectAll);
                stmt.setInt(1, prodType);
                rs = stmt.executeQuery();
                getProducts1XML(toAppend, rs);
            }
            stmt = transconn.prepareStatement(changeLogVersion);
            rs = stmt.executeQuery();
            if(rs.next()) {
                toAppend.addElement("productVersion").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
   
   
    /**
     * The folowing code is to fetch the products items for each location when a single beverage is selected 
     *---- SR
     */
    private void getProducts1XML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            int colCount                    = 1;
            Element ProductE1               = toAppend.addElement("product");
            ProductE1.addElement("productId").addText(String.valueOf(rs.getInt(colCount++)));
            ProductE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("category").addText(String.valueOf(rs.getInt(colCount++)));
            ProductE1.addElement("segment").addText(String.valueOf(rs.getInt(colCount++)));
            ProductE1.addElement("isActive").addText(String.valueOf(rs.getBoolean(colCount++)));
            ProductE1.addElement("boardName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("abv").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("bbtvCategory").addText(String.valueOf(rs.getInt(colCount++)));
            ProductE1.addElement("origin").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("styleLogo").addText(HandlerUtils.nullToEmpty("http://beerboard.tv/USBN.BeerBoard.UI/Images/glass/"+rs.getString(colCount++)+".png"));
            ProductE1.addElement("brewLogo").addText(HandlerUtils.nullToEmpty("http://beerboard.tv/USBN.BeerBoard.UI/Images/logo/"+rs.getString(colCount++)));
            ProductE1.addElement("seasonality").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("breweryId").addText(String.valueOf(rs.getInt(colCount++)));
            ProductE1.addElement("isApprove").addText(String.valueOf(rs.getInt(colCount++)));
        }
    }

   
   
   private void getDraftInventory(Element toHandle, Element toAppend) throws HandlerException {

        int refLocationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;


        try {
            if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " + refLocationId);
                }
                String selectByLocationId = "SELECT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id " +
                        " WHERE i.location = ? and p.pType in (1,2)";
                stmt = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                rs = stmt.executeQuery();
                getDraftInventoryXML(toAppend, rs);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
   
   
   private void getTestInventory(Element toHandle, Element toAppend) throws HandlerException {

        //NischaySharma_11-Feb-2009_Start: Added Extraction of supplierid
        int supplierId = HandlerUtils.getOptionalInteger(toHandle, "supplierId");
        //NischaySharma_11-Feb-2009_End

        int refLocationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int refCustomerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int userId      = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "location");
        int zoneId = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int barId = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int stationId = HandlerUtils.getOptionalInteger(toHandle, "stationId");
        int coolerId = HandlerUtils.getOptionalInteger(toHandle, "coolerId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int prodType = HandlerUtils.getRequiredInteger(toHandle, "prodID");
        boolean getActive = HandlerUtils.getOptionalBoolean(toHandle, "getActive");
        boolean getDetails = HandlerUtils.getOptionalBoolean(toHandle, "getDetails");
        String alphabet                     = HandlerUtils.getOptionalString(toHandle, "alphabet");

        String isActive = getActive ? " AND i.isActive = 1 " : " ";
        PreparedStatement stmt = null;
        ResultSet rs = null;
        
        String alphabetCondition            = "";
        if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
            alphabetCondition                       = " AND p.name like '"+alphabet+"%' ";
        }

        try {
            if (refCustomerId >= 0) {
                if (!checkForeignKey("customer", "id", refCustomerId)) {
                    throw new HandlerException("Foreign Key Not found : customer " + refCustomerId);
                }
                String selectByCustomerId = "SELECT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType," +
                        " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product LEFT JOIN location l ON i.location = l.id " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id " +
                        " LEFT JOIN kegLine AS k ON k.id = i.kegLine " +
                        " LEFT JOIN cooler AS c ON k.cooler = c.id " +
                        " WHERE l.customer = ? and p.pType = ? " + isActive ;
                if(regionId > 0) {
                    selectByCustomerId      += "  AND l.region =  "+String.valueOf(regionId);
                }
                stmt = transconn.prepareStatement(selectByCustomerId);
                stmt.setInt(1, refCustomerId);
                stmt.setInt(2, prodType);
                rs = stmt.executeQuery();
                getTestInventoryXML(toAppend, rs, getDetails, true);
                
                if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
                    stmt = transconn.prepareStatement(selectByCustomerId+alphabetCondition);                    
                    stmt.setInt(1, refCustomerId);
                    stmt.setInt(2, prodType);
                    rs = stmt.executeQuery();
                    getTestAlphabetInventoryXML(toAppend, rs, getDetails, true);
                }
            } else if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " + refLocationId);
                }
                String selectByLocationId = "SELECT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType," +
                        " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id " +
                        " LEFT JOIN kegLine AS k ON k.id = i.kegLine " +
                        " LEFT JOIN cooler AS c ON k.cooler = c.id " +
                        " WHERE i.location = ? and p.pType = ? " + isActive ;
                stmt = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                stmt.setInt(2, prodType);
                rs = stmt.executeQuery();
                getTestInventoryXML(toAppend, rs, getDetails, false);
                
                if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
                    stmt = transconn.prepareStatement(selectByLocationId+alphabetCondition);                    
                    stmt.setInt(1, refLocationId);
                    stmt.setInt(2, prodType);
                    rs = stmt.executeQuery();
                    getTestAlphabetInventoryXML(toAppend, rs, getDetails, true);
                }
            } else if (userId >= 0) {
                if (!checkForeignKey("user", "id", userId)) {
                    throw new HandlerException("Foreign Key Not found : user " + userId);
                }
                String selectByLocationId = "SELECT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType," +
                        " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id " +
                        " LEFT JOIN kegLine AS k ON k.id = i.kegLine " +
                        " LEFT JOIN cooler AS c ON k.cooler = c.id " +
                        " LEFT JOIN userMap uM ON uM.location = i.location WHERE uM.user = ? and p.pType = ? " + isActive ;
                stmt = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, userId);
                stmt.setInt(2, prodType);
                rs = stmt.executeQuery();
                getTestInventoryXML(toAppend, rs, getDetails, true);
                
                if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
                    stmt = transconn.prepareStatement(selectByLocationId+alphabetCondition);                    
                    stmt.setInt(1, userId);
                    stmt.setInt(2, prodType);
                    rs = stmt.executeQuery();
                    getTestAlphabetInventoryXML(toAppend, rs, getDetails, true);
                }
            } else if (coolerId >= 0) {
                if (!checkForeignKey("cooler", "id", coolerId)) {
                    throw new HandlerException("Foreign Key Not found : cooler " + coolerId);
                }
                String selectByCoolerId = "SELECT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType, " +
                        " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id " +
                        " LEFT JOIN kegLine AS k ON k.id = i.kegLine " +
                        " LEFT JOIN cooler AS c ON k.cooler = c.id " +
                        " WHERE k.cooler = ? and p.pType = ? " + isActive;
                stmt = transconn.prepareStatement(selectByCoolerId);
                stmt.setInt(1, coolerId);
                stmt.setInt(2, prodType);
                rs = stmt.executeQuery();
                getTestInventoryXML(toAppend, rs, getDetails, true);
                
                if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
                    stmt = transconn.prepareStatement(selectByCoolerId+alphabetCondition);                    
                    stmt.setInt(1, coolerId);
                    stmt.setInt(2, prodType);
                    rs = stmt.executeQuery();
                    getTestAlphabetInventoryXML(toAppend, rs, getDetails, true);
                }
            } else if (zoneId >= 0) {
                if (!checkForeignKey("zone", "id", zoneId)) {
                    throw new HandlerException("Foreign Key Not found : zone " + zoneId);
                }
                String selectByZoneId = "SELECT DISTINCT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType, " +
                        " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category  " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id" +
                        " LEFT JOIN kegLine AS k ON k.id = i.kegLine " +
                        " LEFT JOIN cooler AS c ON k.cooler = c.id " +
                        " WHERE i.location = ? AND c.zone=? and p.pType = ? " + isActive ;
                stmt = transconn.prepareStatement(selectByZoneId);
                stmt.setInt(1, locationId);
                stmt.setInt(2, zoneId);
                stmt.setInt(3, prodType);
                rs = stmt.executeQuery();
                getTestInventoryXML(toAppend, rs, getDetails, true);
                
                if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
                    stmt = transconn.prepareStatement(selectByZoneId+alphabetCondition);
                    stmt.setInt(1, locationId);
                    stmt.setInt(2, zoneId);
                    stmt.setInt(3, prodType);
                    rs = stmt.executeQuery();
                    getTestAlphabetInventoryXML(toAppend, rs, getDetails, true);
                }
            } else if (barId >= 0) {
                if (!checkForeignKey("bar", "id", barId)) {
                    throw new HandlerException("Foreign Key Not found : bar " + barId);
                }
                String selectByBarId = "SELECT DISTINCT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType, " +
                        " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id" +
                        " LEFT JOIN kegLine AS k ON k.id = i.kegLine " +
                        " LEFT JOIN cooler AS c ON k.cooler = c.id LEFT JOIN bar ba ON ba.cooler = c.id" +
                        " WHERE i.location = ? AND ba.id = ? AND p.pType = ? " + isActive ;
                stmt = transconn.prepareStatement(selectByBarId);
                stmt.setInt(1, locationId);
                stmt.setInt(2, barId);
                stmt.setInt(3, prodType);
                rs = stmt.executeQuery();
                getTestInventoryXML(toAppend, rs, getDetails, true);
                
                
                if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
                    stmt = transconn.prepareStatement(selectByBarId+alphabetCondition);
                    stmt.setInt(1, locationId);
                    stmt.setInt(2, barId);
                    stmt.setInt(3, prodType);
                    rs = stmt.executeQuery();
                    getTestAlphabetInventoryXML(toAppend, rs, getDetails, true);
                }
            } else if (stationId >= 0) {
                if (!checkForeignKey("station", "id", stationId)) {
                    throw new HandlerException("Foreign Key Not found : station " + stationId);
                }
                String selectByStationId = "SELECT DISTINCT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType, " +
                        " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id" +
                        " LEFT JOIN kegLine AS k ON k.id = i.kegLine " +
                        " LEFT JOIN cooler AS c ON k.cooler = c.id  LEFT JOIN bar ba ON ba.cooler = c.id LEFT JOIN station s ON s.bar = ba.id " +
                        " WHERE i.location = ? AND s.id = ? AND p.pType = ? " + isActive ;
                stmt = transconn.prepareStatement(selectByStationId);
                stmt.setInt(1, locationId);
                stmt.setInt(2, stationId);
                stmt.setInt(3, prodType);
                rs = stmt.executeQuery();
                getTestInventoryXML(toAppend, rs, getDetails, true);
                
                if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
                    stmt = transconn.prepareStatement(selectByStationId+alphabetCondition);
                    stmt.setInt(1, locationId);
                    stmt.setInt(2, stationId);
                    stmt.setInt(3, prodType);
                    rs = stmt.executeQuery();
                    getTestAlphabetInventoryXML(toAppend, rs, getDetails, true);
                }
            } //NischaySharma_11-Feb-2009_Start: Added check to verify and generate response according to
            // supplierId
            else if (supplierId >= 0) {
                if (!checkForeignKey("supplier", "id", supplierId)) {
                    throw new HandlerException("Foreign Key Not found : supplier " + supplierId);
                }
                String selectBySupplierId = "SELECT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType," +
                        " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id " +
                        " LEFT JOIN kegLine AS k ON k.id = i.kegLine " +
                        " LEFT JOIN cooler AS c ON k.cooler = c.id " +
                        " WHERE sup.id = ? and p.pType = ? " + isActive ;
                stmt = transconn.prepareStatement(selectBySupplierId);
                stmt.setInt(1, supplierId);
                stmt.setInt(2, prodType);
                rs = stmt.executeQuery();
                getTestInventoryXML(toAppend, rs, getDetails, true);
                
                if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
                    stmt = transconn.prepareStatement(selectBySupplierId+alphabetCondition);
                    stmt.setInt(1, supplierId);
                    stmt.setInt(2, prodType);
                    rs = stmt.executeQuery();
                    getTestAlphabetInventoryXML(toAppend, rs, getDetails, true);
                }
            }
            //NischaySharma_11-Feb-2009_End
            // regionId
           /* else if (regionId >= 0) {
                if (!checkForeignKey("region", "id", regionId)) {
                    throw new HandlerException("Foreign Key Not found : region " + regionId);
                }

                //To fetch data for only the required locations
                int j = 0;
                String userLocationRequired = " ";
                Iterator i = toHandle.elementIterator("reqLocations");
                while (i.hasNext()) {
                    Element el = (Element) i.next();
                    if (j == 0) {
                        userLocationRequired += " AND l.id IN (" + String.valueOf(HandlerUtils.getRequiredInteger(el, "locationId"));
                        j++;
                    } else {
                        userLocationRequired += ", " + String.valueOf(HandlerUtils.getRequiredInteger(el, "locationId"));
                    }
                }
                if (j > 0) {
                    userLocationRequired += ") ";
                }

                String selectByRegionId = "SELECT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType," +
                        " i.bottleSize, b.name, c.id, c.name, i.kegLine, k.name, p.segment, p.category " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id LEFT JOIN bottleSize AS b ON i.bottleSize = b.id " +
                        " LEFT JOIN kegLine AS k ON k.id = i.kegLine LEFT JOIN cooler AS c ON k.cooler = c.id " +
                        " LEFT JOIN location l ON l.id = i.location LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                        " LEFT JOIN groupRegionMap gRM ON gRM.regionMaster = rCM.region LEFT JOIN region r ON r.regionGroup = gRM.id " +
                        " WHERE r.id = ? AND p.pType = ? " + isActive + userLocationRequired;
                stmt = transconn.prepareStatement(selectByRegionId);
                stmt.setInt(1, regionId);
                stmt.setInt(2, prodType);
                rs = stmt.executeQuery();
                getTestInventoryXML(toAppend, rs, getDetails, true);
                
                if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
                    stmt = transconn.prepareStatement(selectByRegionId+alphabetCondition);
                    stmt.setInt(1, regionId);
                    stmt.setInt(2, prodType);
                    rs = stmt.executeQuery();
                    getTestAlphabetInventoryXML(toAppend, rs, getDetails, true);
                }
                
            }*/

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**
     * The folowing code is to fetch the inventory items for each location when a single beverage is selected 
     *---- SR
     */
    private void getTestInventoryXML(Element toAppend, ResultSet rs, boolean getDetails, boolean isCustomer) throws SQLException {
        while (rs.next()) {
            Element InventoryE1 = toAppend.addElement("inventoryItem");
            InventoryE1.addElement("inventoryId").addText(String.valueOf(rs.getInt(1)));
            InventoryE1.addElement("productId").addText(String.valueOf(rs.getInt(2)));
            InventoryE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            InventoryE1.addElement("locationId").addText(String.valueOf(rs.getInt(4)));
            InventoryE1.addElement("qtyOnHand").addText(String.valueOf(rs.getDouble(5)));
            InventoryE1.addElement("minimumQty").addText(String.valueOf(rs.getDouble(6)));
            InventoryE1.addElement("pluCode").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
            InventoryE1.addElement("qtyToOrder").addText(String.valueOf(rs.getInt(8)));
            InventoryE1.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
            InventoryE1.addElement("supplierId").addText(String.valueOf(rs.getInt(10)));
            InventoryE1.addElement("kegSize").addText(String.valueOf(rs.getInt(11)));
            InventoryE1.addElement("brixWater").addText(String.valueOf(rs.getInt(12)));
            InventoryE1.addElement("brixSyrup").addText(String.valueOf(rs.getInt(13)));
            InventoryE1.addElement("prodType").addText(String.valueOf(rs.getInt(14)));
            InventoryE1.addElement("bottleSizeId").addText(String.valueOf(rs.getInt(15)));
            InventoryE1.addElement("bottleSizeName").addText(HandlerUtils.nullToEmpty(rs.getString(16)));
            InventoryE1.addElement("coolerId").addText(HandlerUtils.nullToEmpty(rs.getString(17)));
            InventoryE1.addElement("cooler").addText(HandlerUtils.nullToEmpty(rs.getString(18)));
            InventoryE1.addElement("kegLineId").addText(HandlerUtils.nullToEmpty(rs.getString(19)));
            InventoryE1.addElement("kegLine").addText(HandlerUtils.nullToEmpty(rs.getString(20)));
            InventoryE1.addElement("segment").addText(HandlerUtils.nullToEmpty(rs.getString(21)));
            InventoryE1.addElement("category").addText(HandlerUtils.nullToEmpty(rs.getString(22)));
        }

    }
    
    private void getTestAlphabetInventoryXML(Element toAppend, ResultSet rs, boolean getDetails, boolean isCustomer) throws SQLException {
        while (rs.next()) {
            Element InventoryE1 = toAppend.addElement("alphabetInventoryItem");
            InventoryE1.addElement("inventoryId").addText(String.valueOf(rs.getInt(1)));
            InventoryE1.addElement("productId").addText(String.valueOf(rs.getInt(2)));
            InventoryE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            InventoryE1.addElement("locationId").addText(String.valueOf(rs.getInt(4)));
            InventoryE1.addElement("qtyOnHand").addText(String.valueOf(rs.getDouble(5)));
            InventoryE1.addElement("minimumQty").addText(String.valueOf(rs.getDouble(6)));
            InventoryE1.addElement("pluCode").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
            InventoryE1.addElement("qtyToOrder").addText(String.valueOf(rs.getInt(8)));
            InventoryE1.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
            InventoryE1.addElement("supplierId").addText(String.valueOf(rs.getInt(10)));
            InventoryE1.addElement("kegSize").addText(String.valueOf(rs.getInt(11)));
            InventoryE1.addElement("brixWater").addText(String.valueOf(rs.getInt(12)));
            InventoryE1.addElement("brixSyrup").addText(String.valueOf(rs.getInt(13)));
            InventoryE1.addElement("prodType").addText(String.valueOf(rs.getInt(14)));
            InventoryE1.addElement("bottleSizeId").addText(String.valueOf(rs.getInt(15)));
            InventoryE1.addElement("bottleSizeName").addText(HandlerUtils.nullToEmpty(rs.getString(16)));
            InventoryE1.addElement("coolerId").addText(HandlerUtils.nullToEmpty(rs.getString(17)));
            InventoryE1.addElement("cooler").addText(HandlerUtils.nullToEmpty(rs.getString(18)));
            InventoryE1.addElement("kegLineId").addText(HandlerUtils.nullToEmpty(rs.getString(19)));
            InventoryE1.addElement("kegLine").addText(HandlerUtils.nullToEmpty(rs.getString(20)));
            InventoryE1.addElement("segment").addText(HandlerUtils.nullToEmpty(rs.getString(21)));
            InventoryE1.addElement("category").addText(HandlerUtils.nullToEmpty(rs.getString(22)));
        }

    }

    /**
     * The folowing code is to fetch the inventory items for each location when all beverages is selected 
     *---- SR
     */
    private void getTestInventoryXML1(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element InventoryE1 = toAppend.addElement("inventoryItem");

            InventoryE1.addElement("inventoryId").addText(String.valueOf(rs.getInt(1)));
            InventoryE1.addElement("productId").addText(String.valueOf(rs.getInt(2)));
            InventoryE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            InventoryE1.addElement("locationId").addText(String.valueOf(rs.getInt(4)));
            InventoryE1.addElement("qtyOnHand").addText(String.valueOf(rs.getDouble(5)));
            InventoryE1.addElement("minimumQty").addText(String.valueOf(rs.getDouble(6)));
            InventoryE1.addElement("pluCode").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
            InventoryE1.addElement("qtyToOrder").addText(String.valueOf(rs.getInt(8)));
            InventoryE1.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
            InventoryE1.addElement("supplierId").addText(String.valueOf(rs.getInt(10)));
            InventoryE1.addElement("kegSize").addText(String.valueOf(rs.getInt(11)));
            InventoryE1.addElement("brixWater").addText(String.valueOf(rs.getInt(12)));
            InventoryE1.addElement("brixSyrup").addText(String.valueOf(rs.getInt(13)));
            InventoryE1.addElement("prodType").addText(String.valueOf(rs.getInt(14)));
        }

    }

    private void getTestInventory1(Element toHandle, Element toAppend) throws HandlerException {

        int refLocationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int prodType = HandlerUtils.getRequiredInteger(toHandle, "prodID");
        PreparedStatement stmt = null;
        ResultSet rs = null;


        try {
            if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " + refLocationId);
                }
                String selectByLocationId = "SELECT i.id, i.product, p.name, " +
                        " i.location, IF(i.qtyOnHand < 0, 0.0, i.qtyOnHand), i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup, p.pType " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id " +
                        " WHERE i.location = ?";
                stmt = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                rs = stmt.executeQuery();
                getTestInventoryXML1(toAppend, rs);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**
     * The folowing code is to run Generic Querys and return the value to the report 
     * - This particular hander gets 2 input and returns 1 output ---- SR
     */
    private void getGenericResult1(Element toHandle, Element toAppend) throws HandlerException {

        int queryEntry1 = HandlerUtils.getRequiredInteger(toHandle, "queryEntry1");
        int queryEntry2 = HandlerUtils.getRequiredInteger(toHandle, "queryEntry2");
        String query = HandlerUtils.getRequiredString(toHandle, "query");
        PreparedStatement stmt = null;
        ResultSet rs = null;

        String sql = query;

        try {
            stmt = transconn.prepareStatement(sql);
            stmt.setInt(1, queryEntry1);
            stmt.setInt(1, queryEntry2);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("queryResult").addText(HandlerUtils.nullToEmpty(rs.getString(1)));

            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**
     * The folowing code is to run Generic Querys and return the value to the report 
     * - This particular hander gets 1 input and returns 2 output ---- SR
     */
    private void getGenericResult2(Element toHandle, Element toAppend) throws HandlerException {

        int queryEntry1 = HandlerUtils.getRequiredInteger(toHandle, "queryEntry1");

        String query = HandlerUtils.getRequiredString(toHandle, "query");
        PreparedStatement stmt = null;
        ResultSet rs = null;

        String sql = query;

        try {
            stmt = transconn.prepareStatement(sql);
            stmt.setInt(1, queryEntry1);

            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("queryResult").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("queryResult1").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**
     * The folowing code is to run Generic Querys and return the value to the report 
     * - This particular hander gets 2 input and returns 2 output ---- SR
     */
    private void getGenericResult3(Element toHandle, Element toAppend) throws HandlerException {

        int queryEntry1 = HandlerUtils.getRequiredInteger(toHandle, "queryEntry1");
        int queryEntry2 = HandlerUtils.getRequiredInteger(toHandle, "queryEntry2");
        String query = HandlerUtils.getRequiredString(toHandle, "query");
        PreparedStatement stmt = null;
        ResultSet rs = null;

        String sql = query;

        try {
            stmt = transconn.prepareStatement(sql);
            stmt.setInt(1, queryEntry1);
            stmt.setInt(2, queryEntry2);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("queryResult").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("queryResult1").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**
     * The folowing code is to run Generic Querys and return the value to the report 
     * - This particular hander gets 1 input and returns 3 output ---- SR
     */
    private void getGenericResult4(Element toHandle, Element toAppend) throws HandlerException {

        int queryEntry1 = HandlerUtils.getRequiredInteger(toHandle, "queryEntry1");

        String query = HandlerUtils.getRequiredString(toHandle, "query");
        PreparedStatement stmt = null;
        ResultSet rs = null;

        String sql = query;

        try {
            stmt = transconn.prepareStatement(sql);
            stmt.setInt(1, queryEntry1);

            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("queryResult").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("queryResult1").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("queryResult2").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**
     * The folowing code is to run Generic Querys and return the value to the report 
     * - This particular hander gets 2 input and returns 3 output ---- SR
     */
    private void getGenericResult5(Element toHandle, Element toAppend) throws HandlerException {

        int queryEntry1 = HandlerUtils.getRequiredInteger(toHandle, "queryEntry1");
        int queryEntry2 = HandlerUtils.getRequiredInteger(toHandle, "queryEntry2");
        String query = HandlerUtils.getRequiredString(toHandle, "query");
        PreparedStatement stmt = null;
        ResultSet rs = null;

        String sql = query;

        try {
            stmt = transconn.prepareStatement(sql);
            stmt.setInt(1, queryEntry1);
            stmt.setInt(2, queryEntry2);

            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("queryResult").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("queryResult1").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("queryResult2").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getDailyLineCleaningReports(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = "SELECT Location, Bar, SUM(Poured) Poured, IF(SUM(Poured)>0,'***',' ') Xcpt" +
                "FROM (SELECT c.id Customer, l.name Location, b.name Bar, s.systemId Sys," +
                "line.lineIndex Line, p.name Product, ROUND(MAX(r.value)-MIN(r.value),1) Poured" +
                "FROM customer c JOIN location l ON c.id=l.customer JOIN bar b ON l.id=b.location" +
                "JOIN system s ON l.id=s.location JOIN line ON s.id=line.system" +
                "JOIN product p ON p.id=line.product JOIN readingNew r ON line.id=r.line" +
                "JOIN locationHours lH ON lH.location=l.id" +
                "JOIN (select Cust, Loc, addtime(Close2,concat(eO,':0:0')) Closed," +
                "addtime(Open2,concat(eO,':0:0')) Opened, eO from" +
                "(select Cust, Loc, If(Close1>'12:0:0',concat(left(now()-1000000,11),Close1),concat(left(now(),11),Close1)) Close2," +
                "Concat(left(now(),11),Open1) Open2, eO from" +
                "(Select l.customer Cust, l.id Loc," +
                "CASE DAYOFWEEK(NOW()-1000000)" +
                "WHEN 1 THEN Right(lH.preOpenSun,8)" +
                "WHEN 2 THEN Right(lH.preOpenMon,8)" +
                "WHEN 3 THEN Right(lH.preOpenTue,8)" +
                "WHEN 4 THEN Right(lH.preOpenWed,8)" +
                "WHEN 5 THEN Right(lH.preOpenThu,8)" +
                "WHEN 6 THEN Right(lH.preOpenFri,8)" +
                "WHEN 7 THEN Right(lH.preOpenSat,8) END Close1," +
                "CASE DAYOFWEEK(NOW())" +
                "WHEN 1 THEN Right(lH.OpenSun,8)" +
                "WHEN 2 THEN Right(lH.OpenMon,8)" +
                "WHEN 3 THEN Right(lH.OpenTue,8)" +
                "WHEN 4 THEN Right(lH.OpenWed,8)" +
                "WHEN 5 THEN Right(lH.OpenThu,8)" +
                "WHEN 6 THEN Right(lH.OpenFri,8)" +
                "WHEN 7 THEN Right(lH.OpenSat,8) END Open1, MID(easternOffset,2,1) eO" +
                "FROM locationHours lH JOIN location l ON lH.location=l.id" +
                "WHERE l.customer=?) AS x) AS y) As z ON z.Loc=l.id" +
                "WHERE r.date BETWEEN Closed AND Opened AND r.type = 0" +
                "AND line.status='RUNNING' AND pType=1" +
                "GROUP BY l.id, b.name, s.systemId, line.lineIndex) AS x GROUP BY Location,Bar;";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("addTest");

        try {

            int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");
            String emailAddr = HandlerUtils.getRequiredString(toHandle, "emailAddr");


            //Check that this product doesn't already exist in inventory at this location
            stmt = transconn.prepareStatement(select);
            stmt.setString(1, emailAddr);
            stmt.setInt(2, locationId);
            rs = stmt.executeQuery();

            if (rs.next()) {
                toAppend.addElement("report1").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("report2").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("report3").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                toAppend.addElement("report4").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                toAppend.addElement("report5").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                toAppend.addElement("report6").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                toAppend.addElement("exception").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /** RETIRED
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void getReports(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = " SELECT report1, report2, report3, report4, report5, report6, exceptionsOnly  FROM emailReports WHERE emailAddr=? and location=?";
        String selectAlert = " SELECT noSoldAlert, noPouredAlert  FROM emailReports WHERE emailAddr=? and customer=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getReports");

        try {
            int locationId = -1;
            locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");
            String emailAddr = HandlerUtils.getRequiredString(toHandle, "emailAddr");

            if (locationId > 0) {

                stmt = transconn.prepareStatement(select);
                stmt.setString(1, emailAddr);
                stmt.setInt(2, locationId);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("report1").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    toAppend.addElement("report2").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    toAppend.addElement("report3").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    toAppend.addElement("report4").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                    toAppend.addElement("report5").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                    toAppend.addElement("report6").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                    toAppend.addElement("exception").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
                }

            }

            stmt = transconn.prepareStatement(selectAlert);
            stmt.setString(1, emailAddr);
            stmt.setInt(2, customerId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("noSold").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("noPoured").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    
    private void getBottleInv(Element toHandle, Element toAppend)
            throws HandlerException {

        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String date;
        String getRecentInvDate = "SELECT date FROM bottleInv WHERE location = ? ORDER BY date DESC LIMIT 1";
        String getLastInvDate = "SELECT date FROM bottleInv WHERE location = ? and date < ? ORDER BY date DESC LIMIT 1";
        String getLastInv = "SELECT product, actualInv FROM bottleInv WHERE location = ? AND date=?";
        String getLastBeforeInv = "SELECT product, calcOnHand, actualInv, ROUND(actualInv-calcOnHand,2) FROM bottleInv WHERE location = ? AND date=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            // we need to know if the user is logging in for the First Time
            stmt = transconn.prepareStatement(getRecentInvDate);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                date = rs.getString(1);
                toAppend.addElement("lastDate").addText(String.valueOf(rs.getString(1)));
            } else {
                date = "2007-01-01 08:00:00";
                toAppend.addElement("lastDate").addText("2007-01-01 08:00:00");
            }

            stmt = transconn.prepareStatement(getLastInv);
            stmt.setInt(1, location);
            stmt.setString(2, date);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element p = toAppend.addElement("productInv");
                p.addElement("product").addText(String.valueOf(rs.getString(1)));
                p.addElement("lastActualInv").addText(String.valueOf(rs.getString(2)));
            }

            stmt = transconn.prepareStatement(getLastInvDate);
            stmt.setInt(1, location);
            stmt.setString(2, date);
            rs = stmt.executeQuery();
            if (rs.next()) {

                toAppend.addElement("lastBeforeDate").addText(String.valueOf(rs.getString(1)));
            } else {

                toAppend.addElement("lastBeforeDate").addText("2007-01-01 08:00:00");
            }
            stmt = transconn.prepareStatement(getLastBeforeInv);
            stmt.setInt(1, location);
            stmt.setString(2, date);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element p = toAppend.addElement("productBeforeInv");
                p.addElement("product").addText(String.valueOf(rs.getString(1)));
                p.addElement("lastBeforeOnHand").addText(String.valueOf(rs.getString(2)));
                p.addElement("lastBeforeActInv").addText(String.valueOf(rs.getString(3)));
                p.addElement("lastBeforeVar").addText(String.valueOf(rs.getString(4)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** Get the details of a purchase number, and lookup the supplier address that this location uses
     *  <orderNumber> 0000
     *  <locationId> 000
     *
     *  returns:
     *
     *  <date>
     *  <totalPrice>
     *  <status>
     *  <supplierId>
     *  <supplierName>
     *  <supplierAddress> 1|0   //if the suppler address is set up
     *  OPT<supplierStreet>
     *  OPT<supplierCity>
     *  OPT<supplierState>
     *  OPT<supplierZip>
     *  <product >
     *      <name>
     *      <productId>
     *      <quantity>
     *      <plu>
     *  </product>
     *  <product>...</>
     *  <product>...</>
     */
    private void getTestPurchaseDetail(Element toHandle, Element toAppend) throws HandlerException {
        int purchase = HandlerUtils.getRequiredInteger(toHandle, "orderNumber");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String getPurchase =
                " SELECT supplier,date,total,status FROM purchase WHERE id=? AND location=? ";
        String getDetails =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu, pr.pType FROM " +
                " purchaseDetail pd LEFT JOIN product pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getDetailsMisc =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu, pr.pType FROM " +
                " purchaseDetailMisc pd LEFT JOIN miscProduct pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getAddress =
                " SELECT s.name, sa.addrStreet, sa.addrCity, sa.addrState, sa.addrZip " +
                " FROM location l LEFT JOIN locationSupplier map ON l.id=map.location " +
                " LEFT JOIN supplierAddress sa ON map.address=sa.id " +
                " LEFT JOIN supplier s ON sa.supplier = s.id " +
                " WHERE l.id=? AND s.id=?";
        String getSupplier =
                " SELECT name FROM supplier WHERE id=? ";

        try {
            stmt = transconn.prepareStatement(getPurchase);
            stmt.setInt(1, purchase);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                int supplier = rs.getInt(1);
                toAppend.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("totalPrice").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                toAppend.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                toAppend.addElement("supplierId").addText(String.valueOf(supplier));
                // get the supplier address IF the location has this supplier in its current list, otherwise just grab its name
                stmt = transconn.prepareStatement(getAddress);
                stmt.setInt(1, location);
                stmt.setInt(2, supplier);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("supplierAddress").addText(String.valueOf(1));
                    toAppend.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    toAppend.addElement("supplierStreet").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    toAppend.addElement("supplierCity").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    toAppend.addElement("supplierState").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                    toAppend.addElement("supplierZip").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                } else {
                    // No supplier address at this location, just grab the name
                    toAppend.addElement("supplierAddress").addText(String.valueOf(0));
                    stmt = transconn.prepareStatement(getSupplier);
                    stmt.setInt(1, supplier);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        toAppend.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    }
                }
                stmt = transconn.prepareStatement(getDetails);
                stmt.setInt(1, purchase);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element product = toAppend.addElement("product");
                    product.addElement("productId").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    product.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    product.addElement("quantity").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    product.addElement("plu").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                    product.addElement("pType").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                }
                stmt = transconn.prepareStatement(getDetailsMisc);
                stmt.setInt(1, purchase);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element product = toAppend.addElement("miscProduct");
                    product.addElement("productId").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    product.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    product.addElement("quantity").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    product.addElement("plu").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                    product.addElement("pType").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getPurchaseDetail: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    private void isNewUser(Element toHandle, Element toAppend)
            throws HandlerException {

        String username = HandlerUtils.getRequiredString(toHandle, "username");
        String password = HandlerUtils.getRequiredString(toHandle, "password");

        String getNewUser = "SELECT u.newUser FROM user u " +
                " WHERE u.username = ? AND u.password = ? ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            // we need to know if the user is logging in for the First Time
            stmt = transconn.prepareStatement(getNewUser);
            stmt.setString(1, username);
            stmt.setString(2, password);
            rs = stmt.executeQuery();
            int newUser = 0;
            if (rs != null && rs.next()) {
                int rsIndex = 1;
                newUser = rs.getInt(rsIndex++);
                toAppend.addElement("newUser").addText(String.valueOf(newUser));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** Returns a list of the locations for which a user has requested low-stock notifications
     *  Will also return that users email address, and if he has location-status updates enabled
     */
    private void authReportRequest(Element toHandle, Element toAppend) throws HandlerException {
        int customer = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int user = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int callerId = getCallerId(toHandle);

        if (location < 0) {
            throw new HandlerException("Either locationId or userId must be set.");
        }

        PreparedStatement stmt = null;

        if (location > 0) {
            try {
                String clearall = "UPDATE user SET emailReports=false WHERE customer=?";
                stmt = transconn.prepareStatement(clearall);
                stmt.setInt(1, customer);
                stmt.executeUpdate();
            } catch (SQLException sqle) {
                logger.dbError("Database error in authUser: " + sqle.getMessage());
                throw new HandlerException(sqle);
            } finally {
                close(stmt);
            }

            Iterator users = toHandle.elementIterator("userAuths");
            while (users.hasNext()) {
                Element userEl = (Element) users.next();
                int userId = HandlerUtils.getRequiredInteger(userEl, "userId");
                int notify = HandlerUtils.getOptionalInteger(userEl, "userAuth");
                Boolean notify1 = false;
                if (notify > 0) {
                    notify1 = true;
                }

                String update = "UPDATE user SET emailReports=? WHERE id=?";



                try {
                    stmt = transconn.prepareStatement(update);
                    stmt.setBoolean(1, notify1);
                    stmt.setInt(2, userId);
                    stmt.executeUpdate();

                } catch (SQLException sqle) {
                    logger.dbError("Database error in authUser: " + sqle.getMessage());
                    throw new HandlerException(sqle);
                } finally {
                    close(stmt);
                }
            }
        }

    }
    
    
    private void getReportRequest(Element toHandle, Element toAppend) throws HandlerException {
        int user = HandlerUtils.getRequiredInteger(toHandle, "userId");
        String selectReportRequest = "SELECT emailReports FROM user WHERE id=?";
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(selectReportRequest);
            stmt.setInt(1, user);
            rs = stmt.executeQuery();
            rs = stmt.executeQuery();
            String request = "";
            if (rs.next()) {
                request = rs.getString(1);
            }
            toAppend.addElement("request").addText(HandlerUtils.nullToEmpty(request));


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /** Return all the normal users and their permission level for a specific location's customer.
     *    Only users who are NOT admins or supermanagers will be returned.
     *    For example, if Location 3 belongs to Customer 1, and Loc 3 is passed,
     *    the all the normal users for Customer 1 will be returned, along with their
     *    permission level for Loc 3, including users that have "no access" to Loc 3.
     */
    private void getTestNormalUsers(Element toHandle, Element toAppend) throws HandlerException {

        int locationId                      = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        String getCustomer                  = "SELECT c.id, c.groupId FROM location l LEFT JOIN customer c ON c.id = l.customer WHERE l.id=?";
        String getUserAuth                  = "SELECT emailReports FROM user WHERE id=?";
        String listSelection                = "customer";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null, rs1 = null;

        try {
            int customerId                  = -1, groupId = -1, parameter = -1;
            ArrayList<Integer> userIds      = new ArrayList<Integer>();
            
            stmt                            = transconn.prepareStatement(getCustomer);
            stmt.setInt(1, locationId);
            rs                              = stmt.executeQuery();
            if (rs.next()) {
                customerId                  = rs.getInt(1);
                groupId                     = rs.getInt(2);
                if (groupId > 0) {
                    listSelection           = "groupId";
                    parameter               = groupId;
                } else {
                    parameter               = customerId;
                }

                String getUsers             = "(SELECT u.id, u.name, u.email, m.securityLevel, IF (u.platform = 5, 1, 0) FROM user u LEFT JOIN userMap m ON m.user=u.id " +
                                            " WHERE u.isManager=0 AND u.isITAdmin=0 AND u." + listSelection + " = ? AND m.location=?)" +
                                            " UNION " +
                                            " (SELECT u2.id, u2.name, u2.email, 10, IF (u2.platform = 5, 1, 0) FROM user u2 WHERE u2.isManager=0 AND u2.isITAdmin=0 AND u2." + listSelection + "=? " +
                                            " AND u2.id NOT IN (SELECT user FROM userMap WHERE location=?)) ORDER BY name, id";
                stmt                        = transconn.prepareStatement(getUsers);
                int index                   = 0;
                stmt.setInt(++index, parameter);
                stmt.setInt(++index, locationId);
                stmt.setInt(++index, parameter);
                stmt.setInt(++index, locationId);
                rs                          = stmt.executeQuery();
                while (rs.next()) {
                    index                   = 0;
                    int userId              = rs.getInt(++index);
                    if (userIds.contains(userId)) {
                        continue;
                    } else {
                        userIds.add(userId);
                    }
                    String fullName         = rs.getString(++index);
                    String email            = rs.getString(++index);
                    int securityLevel       = rs.getInt(++index);
                    if (securityLevel < 1) {
                        securityLevel       = 10;
                    }
                    stmt                    = transconn.prepareStatement(getUserAuth);
                    stmt.setInt(1, userId);
                    String userAuth         = "";
                    rs1                     = stmt.executeQuery();
                    if (rs1.next()) {
                        userAuth            = rs1.getString(1);
                    }
                    Element userEl          = toAppend.addElement("user");
                    userEl.addElement("fullName").addText(HandlerUtils.nullToEmpty(fullName));
                    userEl.addElement("userId").addText(String.valueOf(userId));
                    userEl.addElement("email").addText(String.valueOf(email));
                    userEl.addElement("permission").addText(String.valueOf(securityLevel));
                    userEl.addElement("userAuth").addText(String.valueOf(userAuth));
                    userEl.addElement("beerboard").addText(String.valueOf(rs.getInt(++index)));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(rs1);
            close(stmt);
        }
    }

    /** Send an email to the Corporate Admin to authorize Automated Reports for an user
     */
    private void requestReports(Element toHandle, Element toAppend) throws HandlerException {

        int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");
        int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
        int notify = HandlerUtils.getRequiredInteger(toHandle, "notify");
        PreparedStatement stmt1 = null;
        ResultSet rs1 = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;

        String getLocationInformation =
                " SELECT name FROM location WHERE id=? ";
        String getCustomerInformation =
                " SELECT name FROM customer WHERE id=? ";
        String getUserInformation =
                " SELECT name, email FROM user WHERE id=? ";
        String getAdminInformation =
                " SELECT name, email FROM user WHERE customer = ? and isManager = 1 ";

        String emailTemplatePath = HandlerUtils.getSetting("email.templatePath");
        if ((emailTemplatePath == null) || "".equals(emailTemplatePath)) {
            emailTemplatePath = ".";
        }
        logger.debug("Packaging Email");

        try {

            stmt = transconn.prepareStatement(getAdminInformation);
            stmt.setInt(1, customerId);
            rs = stmt.executeQuery();
            String adminEmail = "";
            String adminName = "";
            while (rs.next()) {

                adminName = rs.getString(1);
                adminEmail = rs.getString(2);
                logger.debug("Loading Template");
                TemplatedMessage poEmail =
                        new TemplatedMessage("User Authorization",
                        emailTemplatePath,
                        "authUser");

                //logger.debug("Setting Template Fields to "+email+" #"+String.valueOf(purchase));
                poEmail.setSender("Tech@usbeveragenet.com");
                poEmail.setRecipient(adminEmail);
                poEmail.setField("ADMINNAME", adminName.toString());

                stmt1 = transconn.prepareStatement(getCustomerInformation);
                stmt1.setInt(1, customerId);
                rs1 = stmt1.executeQuery();
                if (rs1.next()) {
                    String customer = rs1.getString(1);
                    poEmail.setField("CUSTOMER", customer.toString());
                }
                stmt1 = transconn.prepareStatement(getLocationInformation);
                stmt1.setInt(1, locationId);
                rs1 = stmt1.executeQuery();
                if (rs1.next()) {
                    String location = rs1.getString(1);
                    poEmail.setField("LOCATION", location.toString());
                }
                stmt1 = transconn.prepareStatement(getUserInformation);
                stmt1.setInt(1, userId);
                rs1 = stmt1.executeQuery();
                if (rs1.next()) {
                    String user = rs1.getString(1);
                    String userEmail = rs1.getString(2);
                    poEmail.setField("USER", user.toString());
                    poEmail.setField("USEREMAIL", userEmail.toString());
                }
                poEmail.setField("USERID", String.valueOf(userId));
                poEmail.setField("NOTIFY", String.valueOf(notify));
                logger.debug("Sending...");
                poEmail.send();
                logger.debug("Email sent successfully");
            }


        } catch (SQLException sqle) {
            logger.dbError("Database error in emailPurchase: " + sqle.toString());
            throw new HandlerException(sqle);
        } catch (MailException me) {
            logger.debug("Error sending purchase message to ");
            addErrorDetail(toAppend, "Error sending mail: " + me.toString());
        } finally {
            close(stmt);
            close(rs);
            close(stmt1);
            close(rs1);
        }
    }

    /** Send an email to the user to confirm their email address
     */
    private void emailUser(Element toHandle, Element toAppend) throws HandlerException {
        String email = HandlerUtils.getRequiredString(toHandle, "email");
        String name = HandlerUtils.getRequiredString(toHandle, "name");
        String uname = HandlerUtils.getRequiredString(toHandle, "uname");
        String pwd = HandlerUtils.getRequiredString(toHandle, "pwd");
        int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String getLocationInformation =
                " SELECT name FROM location WHERE id=? ";
        String getCustomerInformation =
                " SELECT name FROM customer WHERE id=? ";

        String emailTemplatePath = HandlerUtils.getSetting("email.templatePath");
        if ((emailTemplatePath == null) || "".equals(emailTemplatePath)) {
            emailTemplatePath = ".";
        }
        logger.debug("Packaging Email");

        try {
            logger.debug("Loading Template");
            TemplatedMessage poEmail =
                    new TemplatedMessage("User Confirmation",
                    emailTemplatePath,
                    "emailUser");

            logger.debug("Setting To email");
            //logger.debug("Setting Template Fields to "+email+" #"+String.valueOf(purchase));
            poEmail.setSender("Tech@usbeveragenet.com");
            logger.debug("Setting To Sender");
            poEmail.setRecipient(email);
            logger.debug("Setting To Recipient");
            poEmail.setField("NAME", name.toString());
            logger.debug("Setting Name");
            poEmail.setField("UNAME", uname.toString());
            logger.debug("Setting USERNAME");
            poEmail.setField("PWD", pwd.toString());
            logger.debug("Setting PASSWORD");

            stmt = transconn.prepareStatement(getLocationInformation);
            stmt.setInt(1, locationId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                String location = rs.getString(1);
                poEmail.setField("LOCATION", location.toString());
            }

            stmt = transconn.prepareStatement(getCustomerInformation);
            stmt.setInt(1, customerId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                String customer = rs.getString(1);
                poEmail.setField("CUSTOMER", customer.toString());
            }
            logger.debug("Sending...");
            poEmail.send();
            logger.debug("Email sent successfully");

        } catch (SQLException sqle) {
            logger.dbError("Database error in emailPurchase: " + sqle.toString());
            throw new HandlerException(sqle);
        } catch (MailException me) {
            logger.debug("Error sending purchase message to " + email + ": " + me.toString());
            addErrorDetail(toAppend, "Error sending mail: " + me.toString());
        } finally {
            close(stmt);
            close(rs);
        }
    }

    private StringBuilder getAllSoldList(int locationId, String locationName, String customerName, String buff, int offSet) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;
        //String selectSalesTime = " SELECT date FROM salesNew WHERE location = ? ORDER BY sid DESC LIMIT 1";

        Calendar lastSalesPing = Calendar.getInstance();
        StringBuilder noSoldList = new StringBuilder();

        long diff = 1000 * 60 * 60 * 3;
        Calendar buff1 = Calendar.getInstance();
        diff = buff1.getTimeInMillis() - diff;

        try {
            lastSalesPing.set(Calendar.YEAR, Integer.parseInt(buff.substring(0, 4)));
            lastSalesPing.set(Calendar.MONTH, Integer.parseInt(buff.substring(5, 7)) - 1);
            lastSalesPing.set(Calendar.DAY_OF_MONTH, Integer.parseInt(buff.substring(8, 10)));
            lastSalesPing.set(Calendar.HOUR_OF_DAY, Integer.parseInt(buff.substring(11, 13)));
            lastSalesPing.set(Calendar.MINUTE, Integer.parseInt(buff.substring(14, 16)));
            lastSalesPing.set(Calendar.SECOND, Integer.parseInt(buff.substring(17)));
            if (diff > lastSalesPing.getTimeInMillis()) {
                lastSalesPing.add(Calendar.HOUR_OF_DAY, offSet);
                noSoldList.append("<tr><td style=font-size:x-small height=30>");
                noSoldList.append(HandlerUtils.nullToEmpty(customerName)); // Customer Name
                noSoldList.append("</td><td style=font-size:x-small>");
                noSoldList.append(HandlerUtils.nullToEmpty(locationName)); // Location Name
                noSoldList.append("</td><td align=center style=font-size:x-small>");
                noSoldList.append(HandlerUtils.nullToEmpty((lastSalesPing.getTime().toString()).substring(0, 20))); // Last Sales Reading
                noSoldList.append("</td><td align=center style=font-size:x-small></td style=font-size:x-small><td /></tr>");
            }
        } catch (Exception e) {
            logger.dbError("Error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(stmt);
            close(rs);
        }
        return noSoldList;
    }

    private StringBuilder getAllPouredList(int locationId, String locationName, String customerName, String buff, int offSet) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;

        Calendar lastPouredTime = Calendar.getInstance();
        StringBuilder noPouredList = new StringBuilder();

        long diff = 1000 * 60 * 60 * 3;
        Calendar buff1 = Calendar.getInstance();
        diff = buff1.getTimeInMillis() - diff;

        try {
            lastPouredTime.set(Calendar.YEAR, Integer.parseInt(buff.substring(0, 4)));
            lastPouredTime.set(Calendar.MONTH, Integer.parseInt(buff.substring(5, 7)) - 1);
            lastPouredTime.set(Calendar.DAY_OF_MONTH, Integer.parseInt(buff.substring(8, 10)));
            lastPouredTime.set(Calendar.HOUR_OF_DAY, Integer.parseInt(buff.substring(11, 13)));
            lastPouredTime.set(Calendar.MINUTE, Integer.parseInt(buff.substring(14, 16)));
            lastPouredTime.set(Calendar.SECOND, Integer.parseInt(buff.substring(17)));
            if (diff > lastPouredTime.getTimeInMillis()) {
                lastPouredTime.add(Calendar.HOUR_OF_DAY, offSet);
                noPouredList.append("<tr><td style=font-size:x-small height=30>");
                noPouredList.append(HandlerUtils.nullToEmpty(customerName)); // Customer Name
                noPouredList.append("</td><td style=font-size:x-small>");
                noPouredList.append(HandlerUtils.nullToEmpty(locationName)); // Location Name
                noPouredList.append("</td><td align=center style=font-size:x-small>");
                noPouredList.append(HandlerUtils.nullToEmpty((lastPouredTime.getTime().toString()).substring(0, 20))); // Last Poured Reading
                noPouredList.append("</td><td align=center style=font-size:x-small></td style=font-size:x-small><td /></tr>");
                noPouredList.append("");
            }
        } catch (Exception e) {
            logger.dbError("Error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(stmt);
            close(rs);
        }
        return noPouredList;
    }

    private StringBuilder getPouredList(int locationId, String locationName, String customerName, HashMap<Integer, String> pouredPingList, int offSet) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;

        Calendar lastPouredTime = Calendar.getInstance();

        StringBuilder noPouredList = new StringBuilder();

        String buff;
        long diff = 1000 * 60 * 60 * 1;
        Calendar buff1 = Calendar.getInstance();
        diff = buff1.getTimeInMillis() - diff;

        try {
            buff = pouredPingList.get(locationId);
            lastPouredTime.set(Calendar.YEAR, Integer.parseInt(buff.substring(0, 4)));
            lastPouredTime.set(Calendar.MONTH, Integer.parseInt(buff.substring(5, 7)) - 1);
            lastPouredTime.set(Calendar.DAY_OF_MONTH, Integer.parseInt(buff.substring(8, 10)));
            lastPouredTime.set(Calendar.HOUR_OF_DAY, Integer.parseInt(buff.substring(11, 13)));
            lastPouredTime.set(Calendar.MINUTE, Integer.parseInt(buff.substring(14, 16)));
            lastPouredTime.set(Calendar.SECOND, Integer.parseInt(buff.substring(17)));
            if (diff > lastPouredTime.getTimeInMillis()) {
                lastPouredTime.add(Calendar.HOUR_OF_DAY, offSet);
                noPouredList.append("<tr align=justify><td colspan=4>Your bevBox at ");
                noPouredList.append(HandlerUtils.nullToEmpty(locationName)); // Last Poured Reading
                noPouredList.append(" has <strong>not communicated draft beer pour data</strong> to our systems for over an hour.</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4>Last check-in at <strong>");
                noPouredList.append(HandlerUtils.nullToEmpty((lastPouredTime.getTime().toString()).substring(0, 20))); // Last Poured Reading
                noPouredList.append("</strong></td></tr>");
                noPouredList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4>Please try unplugging the power from the bevBox and plug it back in. This will reset the bevBox. You should also ensure the Ethernet cable is plugged in properly (Green light will be on where the Ethernet cable plugs into bevBox)</td></tr>");
                noPouredList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4>Thank You,</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4>US Beverage Net Support</td></tr>");
                noPouredList.append("<tr align=center valign=middle><td height=35 colspan=4>&nbsp;</td></tr>");
                noPouredList.append("<tr align=justify><td colspan=4><strong>This email was automatically generated; please do not reply.</strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
            }
        } catch (Exception e) {
            logger.dbError("Error: " + e.getMessage());
            throw new HandlerException(e);
        } finally {
            close(stmt);
            close(rs);
        }
        return noPouredList;
    }

    private StringBuilder getSoldList(int locationId, String locationName, String customerName, HashMap<Integer, String> soldPingList, int offSet) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;


        Calendar lastSalesPing = Calendar.getInstance();

        StringBuilder noSoldList = new StringBuilder();

        String buff;
        long diff = 1000 * 60 * 60 * 1;
        Calendar buff1 = Calendar.getInstance();
        diff = buff1.getTimeInMillis() - diff;

        try {
            buff = soldPingList.get(locationId);
            lastSalesPing.set(Calendar.YEAR, Integer.parseInt(buff.substring(0, 4)));
            lastSalesPing.set(Calendar.MONTH, Integer.parseInt(buff.substring(5, 7)) - 1);
            lastSalesPing.set(Calendar.DAY_OF_MONTH, Integer.parseInt(buff.substring(8, 10)));
            lastSalesPing.set(Calendar.HOUR_OF_DAY, Integer.parseInt(buff.substring(11, 13)));
            lastSalesPing.set(Calendar.MINUTE, Integer.parseInt(buff.substring(14, 16)));
            lastSalesPing.set(Calendar.SECOND, Integer.parseInt(buff.substring(17)));

            if (diff > lastSalesPing.getTimeInMillis()) {
                lastSalesPing.add(Calendar.HOUR_OF_DAY, offSet);
                noSoldList.append("<tr align=justify><td colspan=4>Your USBN Gateway at ");
                noSoldList.append(HandlerUtils.nullToEmpty(locationName)); // Last Poured Reading
                noSoldList.append(" has <strong>not communicated draft beer sales data</strong> to our systems for over an hour.</td></tr>");
                noSoldList.append("<tr align=justify><td colspan=4>Last check-in at <strong>");
                noSoldList.append(HandlerUtils.nullToEmpty((lastSalesPing.getTime().toString()).substring(0, 20))); // Last Poured Reading
                noSoldList.append("</strong></td></tr>");
                noSoldList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
                noSoldList.append("<tr align=justify><td colspan=4>Please try restarting the USBN Gateway software. <a href=http://www.usbeveragenet.com/Docs/WebSite/Gateway%20Restart%20Instructions.pdf>Click here</a> for restart instructions.</td></tr>");
                noSoldList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
                noSoldList.append("<tr align=justify><td colspan=4>Thank You,</td></tr>");
                noSoldList.append("<tr align=justify><td colspan=4>US Beverage Net Support</td></tr>");
                noSoldList.append("<tr align=center valign=middle><td height=35 colspan=4>&nbsp;</td></tr>");
                noSoldList.append("<tr align=justify><td colspan=4><strong>This email was automatically generated; please do not reply.</strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");

            }
        } catch (Exception sqle) {
            logger.dbError("Error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
        return noSoldList;
    }

    /**
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void sendLocationStatusAlerts(Element toHandle, Element toAppend) throws HandlerException {


        String select = "SELECT name, email FROM user WHERE customer = 0 and emailReports = 1";

        String selectLocations = "SELECT l.id, l.name, l.customer, c.name, l.easternOffset, lD.soldUp, lD.pouredUp, " +
                " IFNULL(lastSold,'2005-01-01 00:00:00'), IFNULL(lastPoured,'2005-01-01 00:00:00') " +
                " FROM location l left join customer c on c.id = l.customer left join locationDetails lD ON lD.location = l.id " +
                " where lD.active=1 AND lD.suspended = 0 order by c.name, l.name";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            int customerId = -1;
            int locationId = -1;
            int offSet = 0;
            int hasSold = -1;
            int hasPoured = -1;

            String emailAddr, userName, locationName, customerName;
            StringBuilder noPouredHeader = new StringBuilder();
            StringBuilder noSoldHeader = new StringBuilder();

            emailAddr = "";
            noSoldHeader.append("<tr align=center valign=middle><td colspan=4 ><strong><span style=text-decoration: underline>No Sales Reading Alert</span> </strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
            noSoldHeader.append("<tr><td width=180 align=left><strong>Customer Name</strong></td><td width=180 align=left><strong>Location Name</strong></td><td width=200 align=center><strong>Last Reading</strong></td><td width=200 align=center></td></tr>");
            noPouredHeader.append("<tr align=center><td colspan=4 ><strong><span style=text-decoration: underline>No Pour Reading Alert</span> </strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
            noPouredHeader.append("<tr><td width=180 align=left><strong>Customer Name</strong></td><td width=180 align=left><strong>Location Name</strong></td><td width=200 align=center><strong>Last Reading</strong></td><td width=200 align=center></td></tr>");
            customerName = "";

            long diff = 1000 * 60 * 60 * 3;
            long businessStart = 1000 * 60 * 60 * 13;
            long businessEnd = 1000 * 60 * 60 * 24;

            Calendar buff1 = Calendar.getInstance();
            diff = buff1.getTimeInMillis() - diff;


            StringBuilder noPouredList = new StringBuilder();
            StringBuilder noSoldList = new StringBuilder();
            long startMillis = System.currentTimeMillis();

            stmt = transconn.prepareStatement(selectLocations);
            rs = stmt.executeQuery();
            while (rs.next()) {
                logger.debug("Adding info for " + rs.getString(2));
                int soldUp = -1;
                int pouredUp = -1;
                locationId = rs.getInt(1);
                locationName = rs.getString(2);
                customerId = rs.getInt(3);
                customerName = rs.getString(4);
                offSet = rs.getInt(5);
                soldUp = rs.getInt(6);
                pouredUp = rs.getInt(7);

                if (soldUp > 0) {
                    noSoldList.append(getAllSoldList(locationId, locationName, customerName, rs.getString(8), offSet));
                }

                if (pouredUp > 0) {
                    noPouredList.append(getAllPouredList(locationId, locationName, customerName, rs.getString(9), offSet));
                }

            }

            long elapsedTime = System.currentTimeMillis() - startMillis;
            logger.debug("Alerts took " + elapsedTime + " ms to generate");

            /* Retreiving one super user information at a time*/
            stmt = transconn.prepareStatement(select);
            rs = stmt.executeQuery();

            /* This is the master loop for every super user*/

            while (rs.next()) {

                userName = rs.getString(1);
                emailAddr = rs.getString(2);
                Calendar businessTime = Calendar.getInstance();

                String h = businessTime.getTime().toString();

                int bushour = Integer.parseInt(h.substring(11, 13));
                long businessHour = (bushour) * 1000 * 60 * 60;

                if (noSoldList.length() != 0 || noPouredList.length() != 0) {
                    String emailTemplatePath = HandlerUtils.getSetting("email.templatePath");
                    if ((emailTemplatePath == null) || "".equals(emailTemplatePath)) {
                        emailTemplatePath = ".";
                    }
                    logger.debug("Packaging Email");
                    try {
                        logger.debug("Loading Template");
                        TemplatedMessage poEmail =
                                new TemplatedMessage("Location Status Alert",
                                emailTemplatePath, "locationStatusAlert");

                        //logger.debug("Setting Template Fields to "+email+" #"+String.valueOf(purchase));
                        poEmail.setSender("tech@usbeveragenet.com");
                        //logger.debug("*");
                        poEmail.setRecipient(emailAddr);
                        //logger.debug("*");
                        poEmail.setField("DATE", Calendar.getInstance().getTime().toString());
                        poEmail.setField("CUSTOMER", customerName.toString());
                        logger.debug("businessHour: " + String.valueOf(businessHour));
                        logger.debug("businessStart: " + String.valueOf(businessStart));
                        logger.debug("businessEnd: " + String.valueOf(businessEnd));

                        if ((noSoldList.length() > 0)) {
                            hasSold = 1;
                            poEmail.setField("NOSOLDHEADER", noSoldHeader.toString());
                            poEmail.setField("NOSOLD", noSoldList.toString());
                        } else {
                            hasSold = -1;
                            poEmail.setField("NOSOLDHEADER", "");
                            poEmail.setField("NOSOLD", "");
                        }
                        if ((noPouredList.length() > 0)) {
                            hasPoured = 1;
                            poEmail.setField("NOPOUREDHEADER", noPouredHeader.toString());
                            poEmail.setField("NOPOURED", noPouredList.toString());
                        } else {
                            hasPoured = -1;
                            poEmail.setField("NOPOUREDHEADER", "");
                            poEmail.setField("NOPOURED", "");
                        }
                        logger.debug("Sending...");
                        logger.debug("hasSold: " + hasSold);
                        logger.debug("hasPoured: " + hasPoured);
                        if (hasSold > 0 || hasPoured > 0) {
                            poEmail.send();
                            logger.debug("Email sent successfully for " + userName);
                        } else {
                            logger.debug("Email was not sent for " + userName);
                        }
                    } catch (MailException me) {
                        logger.debug("Error sending purchase message to " + emailAddr + ": " + me.toString());
                        addErrorDetail(toAppend, "Error sending mail: " + me.toString());
                    }
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /** RETIRED
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void sendAlerts(Element toHandle, Element toAppend) throws HandlerException {

        int addAlertCount = HandlerUtils.getOptionalInteger(toHandle, "reactivateAlerts");

        String select = "SELECT id, user, emailAddr, location, noSoldAlert, noPouredAlert, soldAlertCount, pouredAlertCount FROM emailReports WHERE (noSoldAlert =1 OR noPouredAlert = 1) AND time = 0";
        String selectLocations = "SELECT l.name, l.customer, c.name, l.easternOffset FROM location l left join customer c on c.id = l.customer LEFT JOIN locationDetails lD ON lD.location = l.id where lD.active=1 AND l.id = ? order by c.name, l.name";
        String selectLastPouredSoldPing = "SELECT l.id, IFNULL(l.lastSold,'2005-01-01 00:00:00'), IFNULL(l.lastPoured,'2005-01-01 00:00:00') FROM location l LEFT JOIN locationDetails lD ON lD.location = l.id WHERE lD.active=1 AND l.id = ?";

        PreparedStatement stmt = null;
        ResultSet rs = null, rsLocation = null;

        HashMap<Integer, String> soldPingList = new HashMap<Integer, String>();
        HashMap<Integer, String> pouredPingList = new HashMap<Integer, String>();

        try {
            // Resetting the time counter to check for active alerts for the next business day
            if (addAlertCount > 0) {
                stmt = transconn.prepareStatement("UPDATE emailReports SET time = 0 ");
                stmt.executeUpdate();
            }
            int alertId = -1;
            int customerId = -1;
            int locationId = -1;
            int offSet = 0;
            int hasSold = -1;
            int hasPoured = -1;
            int soldCount = -1;
            int pouredCount = -1;
            int soldUp = -1;
            int pouredUp = -1;

            String emailAddr, userName, locationName, customerName;
            StringBuilder noPouredHeader = new StringBuilder();
            StringBuilder noSoldHeader = new StringBuilder();

            emailAddr = "";
            customerName = "";

            long diff = 1000 * 60 * 60 * 1;

            Calendar buff1 = Calendar.getInstance();
            diff = buff1.getTimeInMillis() - diff;

            /* Retreiving one super user information at a time*/
            stmt = transconn.prepareStatement(select);
            rs = stmt.executeQuery();
            while (rs.next()) {

                StringBuilder noPouredList = new StringBuilder();
                StringBuilder noSoldList = new StringBuilder();

                alertId = rs.getInt(1);
                userName = rs.getString(2);
                emailAddr = rs.getString(3);
                locationId = rs.getInt(4);
                soldUp = rs.getInt(5);
                pouredUp = rs.getInt(6);
                soldCount = rs.getInt(7);
                pouredCount = rs.getInt(8);

                stmt = transconn.prepareStatement(selectLastPouredSoldPing);
                stmt.setInt(1, locationId);
                rsLocation = stmt.executeQuery();
                if (rsLocation.next()) {
                    soldPingList.put(new Integer(rsLocation.getInt(1)), new String(rsLocation.getString(2)));
                    pouredPingList.put(new Integer(rsLocation.getInt(1)), new String(rsLocation.getString(3)));
                }
                long startMillis = System.currentTimeMillis();

                stmt = transconn.prepareStatement(selectLocations);
                stmt.setInt(1, locationId);
                rsLocation = stmt.executeQuery();
                if (rsLocation.next()) {
                    locationName = rsLocation.getString(1);
                    customerId = rsLocation.getInt(2);
                    customerName = rsLocation.getString(3);
                    offSet = rsLocation.getInt(4);
                    if ((soldUp > 0) && (soldCount < 4)) {
                        noSoldList.append(getSoldList(locationId, locationName, customerName, soldPingList, offSet));
                        if (noSoldList.length() != 0) {
                            // Incrementing soldcount counter and time flag to stop alerts going out for the day
                            stmt = transconn.prepareStatement("UPDATE emailReports SET soldAlertCount = ?, time = 1 WHERE id = ?");
                            stmt.setInt(1, soldCount + 1);
                            stmt.setInt(2, alertId);
                            stmt.executeUpdate();
                            String emailTemplatePath = HandlerUtils.getSetting("email.templatePath");
                            if ((emailTemplatePath == null) || "".equals(emailTemplatePath)) {
                                emailTemplatePath = ".";
                            }
                            logger.debug("Packaging Email to send Sold Alerts");
                            try {
                                logger.debug("Loading Template");
                                TemplatedMessage poEmail =
                                        new TemplatedMessage("Location Status Alert",
                                        emailTemplatePath, "locationStatusAlert");

                                //logger.debug("Setting Template Fields to "+email+" #"+String.valueOf(purchase));
                                poEmail.setSender("tech@usbeveragenet.com");
                                //logger.debug("*");
                                poEmail.setRecipient(emailAddr);
                                poEmail.setRecipientBCC("gatewayalert@usbeveragenet.com");
                                //logger.debug("*");
                                poEmail.setField("DATE", Calendar.getInstance().getTime().toString());
                                poEmail.setField("CUSTOMER", customerName.toString());

                                if ((noSoldList.length() > 0)) {
                                    hasSold = 1;
                                    poEmail.setField("NOSOLDHEADER", noSoldHeader.toString());
                                    poEmail.setField("NOSOLD", noSoldList.toString());
                                } else {
                                    hasSold = -1;
                                    poEmail.setField("NOSOLDHEADER", "");
                                    poEmail.setField("NOSOLD", "");
                                }
                                poEmail.setField("NOPOUREDHEADER", "");
                                poEmail.setField("NOPOURED", "");

                                logger.debug("Sending...");
                                logger.debug("hasSold: " + hasSold);
                                if (hasSold > 0) {
                                    poEmail.send();
                                    /*
                                    stmt = transconn.prepareStatement(updateUserAlerts);
                                    stmt.setInt(1, 1);
                                    stmt.setInt(2, alertId);
                                    stmt.executeUpdate();
                                     */
                                    logger.debug("Email sent successfully for " + userName);
                                } else {
                                    logger.debug("Email was not sent for " + userName);
                                }
                            } catch (MailException me) {
                                logger.debug("Error sending purchase message to " + emailAddr + ": " + me.toString());
                                addErrorDetail(toAppend, "Error sending mail: " + me.toString());
                            }
                        }
                    } else if (soldCount > 3) {
                        //Setting time flag so that power-up messages go out
                        stmt = transconn.prepareStatement("UPDATE emailReports SET time = 1 WHERE id = ?");
                        stmt.setInt(1, alertId);
                        stmt.executeUpdate();
                    }
                    //logger.debug("Size of pouredList: " + pouredPingList.size());
                    if ((pouredUp > 0) && (pouredCount < 4)) {
                        noPouredList.append(getPouredList(locationId, locationName, customerName, pouredPingList, offSet));
                        if (noPouredList.length() != 0) {
                            // Incrementing pouredcount counter and time flag to stop alerts going out for the day
                            stmt = transconn.prepareStatement("UPDATE emailReports SET pouredAlertCount = ?, time = 1 WHERE id = ?");
                            stmt.setInt(1, pouredCount + 1);
                            stmt.setInt(2, alertId);
                            stmt.executeUpdate();

                            String emailTemplatePath = HandlerUtils.getSetting("email.templatePath");
                            if ((emailTemplatePath == null) || "".equals(emailTemplatePath)) {
                                emailTemplatePath = ".";
                            }
                            logger.debug("Packaging Email to send Poured Alerts");
                            try {
                                logger.debug("Loading Template");
                                TemplatedMessage poEmail =
                                        new TemplatedMessage("Location Status Alert",
                                        emailTemplatePath, "locationStatusAlert");

                                //logger.debug("Setting Template Fields to "+email+" #"+String.valueOf(purchase));
                                poEmail.setSender("tech@usbeveragenet.com");
                                //logger.debug("*");
                                poEmail.setRecipient(emailAddr);
                                poEmail.setRecipientBCC("boxalert@usbeveragenet.com");
                                //logger.debug("*");
                                poEmail.setField("DATE", Calendar.getInstance().getTime().toString());
                                poEmail.setField("CUSTOMER", customerName.toString());

                                if ((noPouredList.length() > 0)) {
                                    hasPoured = 1;
                                    poEmail.setField("NOPOUREDHEADER", noPouredHeader.toString());
                                    poEmail.setField("NOPOURED", noPouredList.toString());
                                } else {
                                    hasPoured = -1;
                                    poEmail.setField("NOPOUREDHEADER", "");
                                    poEmail.setField("NOPOURED", "");
                                }
                                poEmail.setField("NOSOLDHEADER", "");
                                poEmail.setField("NOSOLD", "");
                                logger.debug("Sending...");
                                logger.debug("hasPoured: " + hasPoured);
                                if (hasPoured > 0) {
                                    poEmail.send();
                                    /*
                                    stmt = transconn.prepareStatement(updateUserAlerts);
                                    stmt.setInt(1, 1);
                                    stmt.setInt(2, alertId);
                                    stmt.executeUpdate();
                                     */
                                    logger.debug("Email sent successfully for " + userName);
                                } else {
                                    logger.debug("Email was not sent for " + userName);
                                }
                            } catch (MailException me) {
                                logger.debug("Error sending purchase message to " + emailAddr + ": " + me.toString());
                                addErrorDetail(toAppend, "Error sending mail: " + me.toString());
                            }
                        }
                    } else if (pouredCount > 3) {
                        //Setting time flag so that power-up messages go out
                        stmt = transconn.prepareStatement("UPDATE emailReports SET time = 1 WHERE id = ?");
                        stmt.setInt(1, alertId);
                        stmt.executeUpdate();
                    }

                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
            close(rsLocation);
        }


    }

    /**
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void getVarianceTextAlerts(Element toHandle, Element toAppend) throws HandlerException {


        String selectUserInfo = "SELECT u.name, c.name, l.id, l.name, l.easternOffset, " +
                "t.mobile, t.carrier, t.varianceAlert, t.alertTime, t.user, t.customer " +
                "FROM textAlerts t LEFT JOIN location l on l.id=t.location " +
                "LEFT JOIN customer c on c.id = t.customer LEFT JOIN user u on u.id = t.user " +
                "WHERE t.type = 1 AND t.alert1 =1";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        String currentTime = Calendar.getInstance().getTime().toString();
        currentTime = currentTime.substring(11, 16);
        logger.debug("currentTime: " + currentTime);
        try {

            stmt = transconn.prepareStatement(selectUserInfo);
            rs = stmt.executeQuery();

            while (rs.next()) {

                if (currentTime.compareTo(rs.getString(9)) == 0) {

                    Element user = toAppend.addElement("locationdet");
                    user.addElement("user").addText(rs.getString(1));
                    user.addElement("customer").addText(rs.getString(2));
                    user.addElement("locationId").addText(rs.getString(3));
                    user.addElement("location").addText(rs.getString(4));
                    user.addElement("offset").addText(rs.getString(5));
                    user.addElement("mobile").addText(rs.getString(6));
                    user.addElement("carrier").addText(rs.getString(7));
                    user.addElement("varianceAlert").addText(rs.getString(8));
                    user.addElement("alertTime").addText(rs.getString(9));
                    user.addElement("userId").addText(rs.getString(10));
                    user.addElement("customerId").addText(rs.getString(11));

                } else {
                    logger.debug("Time did not match");
                    logger.debug("DB Time: " + rs.getString(8));
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    private void getLowStockTextAlerts(Element toHandle, Element toAppend) throws HandlerException {


        String selectUserInfo = "SELECT u.name, c.name, l.id, l.name, l.easternOffset, " +
                "t.mobile, t.carrier, t.lowStkAlertTime, t.user, t.customer " +
                "FROM textAlerts t LEFT JOIN location l on l.id=t.location " +
                "LEFT JOIN customer c on c.id = t.customer " +
                "LEFT JOIN user u on u.id = t.user " +
                "WHERE t.type = 1 AND t.alert2 =1";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        String currentTime = Calendar.getInstance().getTime().toString();
        currentTime = currentTime.substring(11, 16);
        try {
            logger.debug("currentTime: " + currentTime);

            stmt = transconn.prepareStatement(selectUserInfo);
            rs = stmt.executeQuery();

            while (rs.next()) {

                if (currentTime.compareTo(rs.getString(8)) == 0) {

                    Element user = toAppend.addElement("locationdet");
                    user.addElement("user").addText(rs.getString(1));
                    user.addElement("customer").addText(rs.getString(2));
                    user.addElement("locationId").addText(rs.getString(3));
                    user.addElement("location").addText(rs.getString(4));
                    user.addElement("offset").addText(rs.getString(5));
                    user.addElement("mobile").addText(rs.getString(6));
                    user.addElement("carrier").addText(rs.getString(7));
                    user.addElement("alertTime").addText(rs.getString(8));
                    user.addElement("userId").addText(rs.getString(9));
                    user.addElement("customerId").addText(rs.getString(10));
                } else {
                    logger.debug("Time did not match");
                    logger.debug("DB Time: " + rs.getString(8));
                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    private void getConcessionLowStockTextAlerts(Element toHandle, Element toAppend) throws HandlerException {


        String selectUserInfo = "SELECT u.name, z.name, c.name, l.id, l.name, " +
                "l.easternOffset, t.mobile, t.carrier, t.lowStkAlertTime, t.user, t.customer " +
                "FROM textAlerts t LEFT JOIN location l on l.id=t.location " +
                "LEFT JOIN customer c on c.id = t.customer " +
                "LEFT JOIN user u on u.id = t.user " +
                "LEFT JOIN zone z on z.id = t.zone " +
                "WHERE t.type = 2 and t.alert2 =1 and t.customer = 79 order by l.name";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(selectUserInfo);
            rs = stmt.executeQuery();

            while (rs.next()) {


                Element user = toAppend.addElement("locationdet");
                user.addElement("user").addText(rs.getString(1));
                user.addElement("zone").addText(rs.getString(2));
                user.addElement("customer").addText(rs.getString(3));
                user.addElement("locationId").addText(rs.getString(4));
                user.addElement("location").addText(rs.getString(5));
                user.addElement("offset").addText(rs.getString(6));
                user.addElement("mobile").addText(rs.getString(7));
                user.addElement("carrier").addText(rs.getString(8));
                user.addElement("alertTime").addText(rs.getString(9));
                user.addElement("userId").addText(rs.getString(10));
                user.addElement("customerId").addText(rs.getString(11));

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /**
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void getConcessionVarianceTextAlerts(Element toHandle, Element toAppend) throws HandlerException {


        java.util.Date date = new java.util.Date();

        String selectUserInfo = "SELECT u.name, c.name, l.id, l.name, l.easternOffset, t.mobile, " +
                "t.carrier, t.varianceAlert, t.alertTime, t.user, t.customer, e.preOpen, e.eventEnd, l.volAdjustment " +
                "FROM textAlerts t LEFT JOIN location l ON l.id = t.location " +
                "LEFT JOIN customer c ON c.id = t.customer LEFT JOIN user u ON u.id = t.user " +
                "LEFT JOIN eventHours e ON e.location = l.id " +
                "WHERE t.alert1 =1 AND c.type = 2 " +
                "AND e.date = ? AND e.eventStart < ? AND e.eventEnd > ?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String currentMonth, currentDay;
        String currentDate = "2008-08-01";


        currentMonth = String.valueOf(date.getMonth() + 1);
        currentDay = String.valueOf(date.getDate());

        if ((currentMonth.length()) < 2) {
            currentMonth = "0" + String.valueOf(date.getMonth() + 1);
        }

        if ((currentDay.length()) < 2) {
            currentDay = "0" + String.valueOf(date.getDate());
        }

        String currentTime = Calendar.getInstance().getTime().toString();
        currentTime = currentTime.substring(11, 19);

        currentDate = String.valueOf(1900 + date.getYear()) + "-" + currentMonth + "-" + currentDay + " " + currentTime;
        logger.debug("currentDate: " + currentDate);

        try {

            stmt = transconn.prepareStatement(selectUserInfo);
            stmt.setString(1, currentDate.substring(0, 11));
            stmt.setString(2, currentDate);
            stmt.setString(3, currentDate);
            rs = stmt.executeQuery();

            while (rs.next()) {

                Element user = toAppend.addElement("locationdet");
                user.addElement("user").addText(rs.getString(1));
                user.addElement("customer").addText(rs.getString(2));
                user.addElement("locationId").addText(rs.getString(3));
                user.addElement("location").addText(rs.getString(4));
                user.addElement("offset").addText(rs.getString(5));
                user.addElement("mobile").addText(rs.getString(6));
                user.addElement("carrier").addText(rs.getString(7));
                user.addElement("varianceAlert").addText(rs.getString(8));
                user.addElement("alertTime").addText(rs.getString(9));
                user.addElement("userId").addText(rs.getString(10));
                user.addElement("customerId").addText(rs.getString(11));
                user.addElement("eventStart").addText(rs.getString(12));
                user.addElement("eventEnd").addText(rs.getString(13));
                user.addElement("volAdjustment").addText(rs.getString(14));


            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    
     private void getLocationTextAlerts(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = " SELECT alert1, alert2 FROM textAlerts WHERE mobile=? and location=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getLocationTextAlerts");

        try {
            int locationId = -1;
            locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");
            String mobile = HandlerUtils.getRequiredString(toHandle, "mobile");

            if (locationId > 0) {

                stmt = transconn.prepareStatement(select);
                stmt.setString(1, mobile);
                stmt.setInt(2, locationId);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("locationTextAlert1").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    toAppend.addElement("locationTextAlert2").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                }

            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /** RETIRED
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void getLocationReports(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = " SELECT locationReports FROM emailReports WHERE emailAddr=? and location=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getLocationReports");

        try {
            int locationId = -1;
            locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");
            String emailAddr = HandlerUtils.getRequiredString(toHandle, "emailAddr");

            if (locationId > 0) {

                stmt = transconn.prepareStatement(select);
                stmt.setString(1, emailAddr);
                stmt.setInt(2, locationId);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("locationReport1").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                }

            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /**
     * The folowing code is to update or insert the sms alerts for each user for the user and location
     * that they provide - AD
     */
    private void getLocationSMSAlerts(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = " SELECT alert1, alert2, alert3, varianceAlert, alertTime,lowStkAlertTime FROM textAlerts WHERE user=? and location=? and customer=?";
        String easternOffsetVal = "SELECT l.easternOffset from location l WHERE l.id = ?";
        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getLocationSMSAlerts");

        try {
            int locationId = -1;
            locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");


            if (locationId > 0) {

                stmt = transconn.prepareStatement(easternOffsetVal);
                stmt.setInt(1, locationId);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    int easternOffsetVal1 = rs.getInt(1);
                    logger.debug("EasternOffset " + String.valueOf(easternOffsetVal1));


                    stmt = transconn.prepareStatement(select);
                    stmt.setInt(1, userId);
                    stmt.setInt(2, locationId);
                    stmt.setInt(3, customerId);
                    rs = stmt.executeQuery();
                    if (rs.next()) {


                        String hrAlert = rs.getString(5).substring(0, 2);
                        logger.debug("hrAlert " + hrAlert);
                        int alertTimeVal = Integer.parseInt(hrAlert);
                        logger.debug("alertTimeVal " + String.valueOf(alertTimeVal));

                        alertTimeVal = alertTimeVal + easternOffsetVal1;

                        if (easternOffsetVal1 != 0 && alertTimeVal < 0) {
                            alertTimeVal = alertTimeVal + 24;
                        }
                        logger.debug("alertTimeValDiff " + String.valueOf(alertTimeVal));
                        String alertTime;

                        if (String.valueOf(alertTimeVal).length() < 2) {
                            alertTime = "0" + String.valueOf(alertTimeVal) + rs.getString(5).substring(2);
                        } else {
                            alertTime = String.valueOf(alertTimeVal) + rs.getString(5).substring(2);
                        }

                        logger.debug("alertTime " + alertTime);

                        //for low stock alert time
                        String lowStkHrAlert = rs.getString(6).substring(0, 2);
                        logger.debug("hrAlert " + lowStkHrAlert);
                        int lowStkAlertTimeVal = Integer.parseInt(lowStkHrAlert);
                        logger.debug("alertTimeVal " + String.valueOf(lowStkAlertTimeVal));

                        lowStkAlertTimeVal = lowStkAlertTimeVal + easternOffsetVal1;

                        if (easternOffsetVal1 != 0 && lowStkAlertTimeVal < 0) {
                            lowStkAlertTimeVal = lowStkAlertTimeVal + 24;
                        }
                        logger.debug("alertTimeValDiff " + String.valueOf(lowStkAlertTimeVal));
                        String lowStkAlertTime;

                        if (String.valueOf(lowStkAlertTimeVal).length() < 2) {
                            lowStkAlertTime = "0" + String.valueOf(lowStkAlertTimeVal) + rs.getString(6).substring(2);
                        } else {
                            lowStkAlertTime = String.valueOf(lowStkAlertTimeVal) + rs.getString(6).substring(2);
                        }

                        logger.debug("alertTime " + lowStkAlertTime);
                        //
                        toAppend.addElement("smsalert1").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                        toAppend.addElement("smsalert2").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                        toAppend.addElement("smsalert3").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                        toAppend.addElement("varianceAlert").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                        toAppend.addElement("alertTime").addText(HandlerUtils.nullToEmpty(alertTime));
                        toAppend.addElement("lowStkAlertTime").addText(HandlerUtils.nullToEmpty(lowStkAlertTime));
                    }
                }
            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /**
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void checkRewards(Element toHandle, Element toAppend) throws HandlerException {

        String select = " SELECT showRewards FROM user WHERE username=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("checkRewards");

        try {
            String username = HandlerUtils.getRequiredString(toHandle, "username");

            stmt = transconn.prepareStatement(select);
            stmt.setString(1, username);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("showRewards").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }
    
    
    private void getLogCategory(Element toHandle, Element toAppend)
            throws HandlerException {

        String selectLogCategory = "SELECT id, name FROM logCategory order by name";


        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(selectLogCategory);
            rs = stmt.executeQuery();
            while (rs != null && rs.next()) {

                int rsIndex = 1;
                Element locEl = toAppend.addElement("logCategory");
                locEl.addElement("logCategoryId").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("logCategoryName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**
     * The folowing code is to update or insert the shift hour information for each location - SR
     */
    private void getLocationLogs(Element toHandle, Element toAppend) throws HandlerException {

        int locationId = -1;
        int customerId = -1;
        int logId = -1;

        locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        customerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        logId = HandlerUtils.getOptionalInteger(toHandle, "logId");

        String selectCustomerLogs = " SELECT id, location, date, category, status, resolutionDate FROM techLogs WHERE customer=? ORDER BY date LIMIT 15";

        String selectLocationLogs = " SELECT id, location, date, category, issue, resolution, status, resolutionDate FROM techLogs WHERE location=? ORDER BY date LIMIT 15";

        String selectLogs = " SELECT id, location, date, category, issue, resolution, status, resolutionDate FROM techLogs WHERE id=?";

        String selectLocation = " SELECT name FROM location WHERE id=?";

        String selectLogCategory = " SELECT name FROM logCategory WHERE id=?";

        int location = -1;
        int catId = -1;
        PreparedStatement stmt = null;
        ResultSet rs = null;

        PreparedStatement stmt1 = null;
        ResultSet rs1 = null;

        try {
            if (customerId > 0) {

                stmt = transconn.prepareStatement(selectCustomerLogs);
                stmt.setInt(1, customerId);
                rs = stmt.executeQuery();

                while (rs.next()) {
                    int i = 1;
                    location = rs.getInt(2);
                    catId = rs.getInt(4);
                    Element logsEl = toAppend.addElement("logs");
                    logsEl.addElement("logId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("locationId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("date").addText(HandlerUtils.nullToEmpty((rs.getString(i++)).substring(0, 10)));
                    logsEl.addElement("categoryId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("resolutionDate").addText(HandlerUtils.nullToEmpty((rs.getString(i++)).substring(0, 10)));

                    stmt1 = transconn.prepareStatement(selectLocation);
                    stmt1.setInt(1, location);
                    rs1 = stmt1.executeQuery();

                    if (rs1.next()) {
                        logsEl.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs1.getString(1)));
                    }

                    stmt1 = transconn.prepareStatement(selectLogCategory);
                    stmt1.setInt(1, catId);
                    rs1 = stmt1.executeQuery();

                    if (rs1.next()) {
                        logsEl.addElement("category").addText(HandlerUtils.nullToEmpty(rs1.getString(1)));
                    }

                }


            }


            if (logId > 0) {

                stmt = transconn.prepareStatement(selectLogs);
                stmt.setInt(1, logId);
                rs = stmt.executeQuery();

                if (rs.next()) {
                    int i = 1;
                    location = rs.getInt(2);
                    catId = rs.getInt(4);
                    Element logsEl = toAppend.addElement("logs");
                    logsEl.addElement("logId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("locationId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("date").addText(HandlerUtils.nullToEmpty((rs.getString(i++)).substring(0, 10)));
                    logsEl.addElement("categoryId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("issue").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("resolution").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("resolutionDate").addText(HandlerUtils.nullToEmpty((rs.getString(i++)).substring(0, 10)));

                    stmt1 = transconn.prepareStatement(selectLocation);
                    stmt1.setInt(1, location);
                    rs1 = stmt1.executeQuery();

                    if (rs1.next()) {
                        logsEl.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs1.getString(1)));
                    }

                    stmt1 = transconn.prepareStatement(selectLogCategory);
                    stmt1.setInt(1, catId);
                    rs1 = stmt1.executeQuery();

                    if (rs1.next()) {
                        logsEl.addElement("category").addText(HandlerUtils.nullToEmpty(rs1.getString(1)));
                    }

                }


            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /**
     * The folowing code is to update or insert the shift hour information for each location - SR
     */
    private void datedLocationLogs(Element toHandle, Element toAppend) throws HandlerException {

        int locationId = -1;
        int customerId = -1;
        int logId = -1;

        customerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        String startDate = HandlerUtils.getOptionalString(toHandle, "startDate");
        String endDate = HandlerUtils.getOptionalString(toHandle, "endDate");

        String selectCustomerLogs = " SELECT id, location, date, category, status, resolutionDate FROM techLogs t WHERE t.customer=? and t.date>? and t.date<?";

        String selectLocation = " SELECT name FROM location WHERE id=?";

        String selectLogCategory = " SELECT name FROM logCategory WHERE id=?";

        int location = -1;
        int catId = -1;
        PreparedStatement stmt = null;
        ResultSet rs = null;

        PreparedStatement stmt1 = null;
        ResultSet rs1 = null;

        try {
            if (customerId > 0) {

                stmt = transconn.prepareStatement(selectCustomerLogs);
                stmt.setInt(1, customerId);
                stmt.setString(2, startDate);
                stmt.setString(3, endDate);
                rs = stmt.executeQuery();

                while (rs.next()) {
                    int i = 1;
                    location = rs.getInt(2);
                    catId = rs.getInt(4);
                    Element logsEl = toAppend.addElement("logs");
                    logsEl.addElement("logId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("locationId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("date").addText(HandlerUtils.nullToEmpty((rs.getString(i++)).substring(0, 10)));
                    logsEl.addElement("categoryId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    logsEl.addElement("resolutionDate").addText(HandlerUtils.nullToEmpty((rs.getString(i++)).substring(0, 10)));

                    stmt1 = transconn.prepareStatement(selectLocation);
                    stmt1.setInt(1, location);
                    rs1 = stmt1.executeQuery();

                    if (rs1.next()) {
                        logsEl.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs1.getString(1)));
                    }
                    stmt1 = transconn.prepareStatement(selectLogCategory);
                    stmt1.setInt(1, catId);
                    rs1 = stmt1.executeQuery();

                    if (rs1.next()) {
                        logsEl.addElement("category").addText(HandlerUtils.nullToEmpty(rs1.getString(1)));
                    }

                }


            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }
    
    
    private void getCustomerPoints(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = "";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getCustomerPoints");

        try {
            int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");

            if (customerId > 0) {
                select = "select ifnull(latitude,0) as centerLat, ifnull(longitude,0) as centerLon, ifnull(zoomLevel,0) as zoomLevel from customer where id = ?;";
                stmt = transconn.prepareStatement(select);
                stmt.setInt(1, customerId);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element p = toAppend.addElement("center");
                    p.addElement("centerLat").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    p.addElement("centerLon").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    p.addElement("zoomLevel").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                }

                select = "select ifnull(latitude,0) as latitude, ifnull(longitude,0) as longitude from customerPoint WHERE customer = ? ORDER BY sequence;";
                stmt = transconn.prepareStatement(select);
                stmt.setInt(1, customerId);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element p = toAppend.addElement("customerPoints");
                    p.addElement("latitude").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    p.addElement("longitude").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }
    //NischaySharma_10-Feb-2009_End

    //NischaySharma_11-Feb-2009_Start: Added new handler
    ///This method uses the customerid, startdate and enddate to calculate the variance of all the locations
    private void getCustomerVariance(Element toHandle, Element toAppend) throws HandlerException {

        int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");
        String startDate = HandlerUtils.getRequiredTimestamp(toHandle, "startDate").toString();
        String endDate = HandlerUtils.getRequiredTimestamp(toHandle, "endDate").toString();


        PreparedStatement stmt = null;
        PreparedStatement pouredStmt = null;
        PreparedStatement soldStmt = null;
        ResultSet rs = null;
        ResultSet pouredRS = null;
        ResultSet soldRS = null;

        if (customerId == 0) {
            throw new HandlerException("Customer id cannot be 0.");
        }

        try {
            String select =
                    " SELECT l.id, l.name" +
                    " FROM customer c LEFT JOIN location l ON c.id=l.customer where c.id = ? ";
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, customerId);
            rs = stmt.executeQuery();
            double pouredValue = 0.0;
            double soldValue = 0.0;
            double variance = 0.0;
            while (rs.next()) {
                int locationId = rs.getInt(1);
                String pouredSelect = " SELECT value FROM (SELECT location, SUM(value) as 'VALUE' FROM pouredSummary ps LEFT JOIN product p on p.id = ps.product" +
                        " WHERE ps.date BETWEEN '" + startDate + "' and '" + endDate + "'" +
                        " and p.pType = 1 group by ps.location) as ps where ps.location = ?;";

                String soldSelect = " select value from (SELECT location, SUM(value) as 'VALUE' FROM soldSummary ss left join product p on p.id = ss.product" +
                        " where ss.date between '" + startDate + "' and '" + endDate + "'" +
                        " and p.pType = 1 group by ss.location) as ss where ss.location = ?;";

                pouredStmt = transconn.prepareStatement(pouredSelect);
                pouredStmt.setInt(1, locationId);
                pouredRS = pouredStmt.executeQuery();

                soldStmt = transconn.prepareStatement(soldSelect);
                soldStmt.setInt(1, locationId);
                soldRS = soldStmt.executeQuery();

                if (pouredRS.first()) {
                    pouredValue = pouredRS.getDouble(1);
                }
                if (soldRS.first()) {
                    soldValue = soldRS.getDouble(1);
                }

                if (pouredValue != 0.0) {
                    variance = ((soldValue - pouredValue) / pouredValue) * 100;
                }

                Element p = toAppend.addElement("location");
                p.addElement("locationId").addText(Integer.toString(locationId));
                p.addElement("variance").addText(Double.toString(variance));
                p.addElement("pouredOunces").addText(Double.toString((pouredValue)));

                soldValue = 0.0;
                pouredValue = 0.0;
                variance = 0.0;

            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    //NischaySharma_11-Feb-2009_End

    //NischaySharma_11-Feb-2009_Start: added new handler GetUserLocations
    private void getUserLocations(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        if (userId == 0) {
            throw new HandlerException("User id cannot be 0.");
        }

        try {
            String select =
                    " select ifnull(latitude,0) as centerLat, ifnull(longitude,0) as centerLon, ifnull(zoomLevel,0) as zoomLevel from location" +
                    " where id in (select location from user where id = ?); ";
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, userId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element p = toAppend.addElement("location");
                p.addElement("centerLat").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                p.addElement("centerLon").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                p.addElement("zoomLevel").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    //NischaySharma_11-Feb-2009_End

    //NischaySharma_13-Feb-2009_Start: added new handler GetUserInfo
    private void getUserInfo(Element toHandle, Element toAppend) throws HandlerException {

        int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");
        int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        if (customerId == 0 || locationId == 0) {
            throw new HandlerException("Customer id  and location id cannot be 0.");
        }

        try {
            String select =
                    " SELECT u.id, securityLevel FROM user u" +
                    " LEFT JOIN userMap umap ON u.id = umap.user" +
                    " WHERE customer = ? AND umap.location = ?";
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, customerId);
            stmt.setInt(2, locationId);
            rs = stmt.executeQuery();
            if (rs.first()) {
                toAppend.addElement("userMstrId").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("securityLevel").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    
    
     private void getConcessionProductMap(Element toHandle, Element toAppend) throws HandlerException {
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int supplierId = HandlerUtils.getOptionalInteger(toHandle, "supplierId");
        int productId = HandlerUtils.getOptionalInteger(toHandle, "productId");
        String alphabet                     = HandlerUtils.getOptionalString(toHandle, "alphabet");

        String selectStmt = " SELECT c.id, p.name, c.product, l.name, c.location, s.name, c.supplier, p.category, p.segment FROM concessionProductMap c " +
                " LEFT JOIN product p on c.product = p.id " +
                " LEFT JOIN location l on c.location = l.id " +
                " LEFT JOIN supplier s on c.supplier = s.id " +
                " WHERE ";
        
        String alphabetCondition            = "";
        if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
            alphabetCondition               = " AND p.name like '"+alphabet+"%' ";
        }
        int paramsCount = 0;
        if (locationId >= 0) {
            paramsCount++;
        }
        if (supplierId >= 0) {
            paramsCount++;
        }
        if (productId >= 0) {
            paramsCount++;
        }
        if (paramsCount > 1) {
            throw new HandlerException("Exactly one of the following must " +
                    "be set: locationId supplierId productId");
        }
        PreparedStatement stmt = null;
        ResultSet productMap = null;
        try {
            if (locationId > 0) {
                selectStmt += " location = ?";
                stmt = transconn.prepareStatement(selectStmt + alphabetCondition);
                stmt.setInt(1, locationId);
                productMap = stmt.executeQuery();
                getConcessionProductMapXML(toAppend, productMap);
            } else if (supplierId > 0) {
                selectStmt += " supplier = ?";
                stmt = transconn.prepareStatement(selectStmt);
                stmt.setInt(1, supplierId);
                productMap = stmt.executeQuery();
                getConcessionProductMapXML(toAppend, productMap);
            } else if (productId > 0) {
                selectStmt += " product = ?";
                stmt = transconn.prepareStatement(selectStmt);
                stmt.setInt(1, supplierId);
                productMap = stmt.executeQuery();
                getConcessionProductMapXML(toAppend, productMap);

            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(productMap);
        }
    }

    private void getConcessionProductMapXML(Element toAppend, ResultSet productMap) throws SQLException {
        while (productMap.next()) {
            Element product = toAppend.addElement("product");
            product.addElement("id").addText(HandlerUtils.nullToEmpty(productMap.getString(1)));
            product.addElement("product").addText(HandlerUtils.nullToEmpty(productMap.getString(2)));
            product.addElement("productId").addText(String.valueOf(productMap.getInt(3)));
            product.addElement("location").addText(HandlerUtils.nullToEmpty(productMap.getString(4)));
            product.addElement("locationId").addText(String.valueOf(productMap.getInt(5)));
            product.addElement("supplier").addText(HandlerUtils.nullToEmpty(productMap.getString(6)));
            product.addElement("supplierId").addText(String.valueOf(productMap.getInt(7)));
            product.addElement("category").addText(String.valueOf(productMap.getInt(8)));
            product.addElement("segment").addText(String.valueOf(productMap.getInt(9)));
        }
    }
    
    
    private void getEmailReportMaster(Element toHandle, Element toAppend) throws HandlerException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        //NischaySharma_31-Jul-2009_Start: Changed query to fetch the email report duration also
        String selectStmt = "SELECT id, name, description, timing, emailReportDurations FROM reportMaster";
        //NischaySharma_31-Jul-2009_End
        try {
            stmt = transconn.prepareStatement(selectStmt);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element report = toAppend.addElement("ReportInfo");
                report.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                report.addElement("report").addText(String.valueOf(rs.getInt(1)));
                report.addElement("description").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                report.addElement("timing").addText(String.valueOf(rs.getTimestamp(4)));
                //NischaySharma_31-Jul-2009_Start: Added email report duration
                report.addElement("emailReportDurations").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                //NischaySharma_31-Jul-2009_End
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getEmailReportComponents(Element toHandle, Element toAppend) throws HandlerException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        String selectStmt = "SELECT id, name, description, headerWidths FROM reportComponents";
        try {
            stmt = transconn.prepareStatement(selectStmt);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element report = toAppend.addElement("ReportComponentInfo");
                report.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                report.addElement("reportComponent").addText(String.valueOf(rs.getInt(1)));
                report.addElement("description").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                report.addElement("headerWidths").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getEmailReportComponentsMap(Element toHandle, Element toAppend) throws HandlerException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        String selectStmt = " SELECT rm.id, rm.name, rc.id, rc.name FROM reportComponentsMap rcm " +
                " LEFT JOIN reportMaster rm on rm.id = rcm.reportMaster " +
                " LEFT JOIN reportComponents rc on rc.id = rcm.reportComponent " +
                " ORDER BY rm.id, rcm.id ";
        try {
            stmt = transconn.prepareStatement(selectStmt);
            rs = stmt.executeQuery();
            int previousReport = -1;
            boolean isLastExecuted = false;
            while (rs.next()) {
                if (previousReport < 0) {
                    previousReport = rs.getInt(1);
                    Element report = toAppend.addElement("ReportInfo");
                    report.addElement("ReportName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    report.addElement("ReportID").addText(String.valueOf(rs.getInt(1)));
                    do {
                        Element components = report.addElement("Component");
                        components.addElement("ComponentName").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                        components.addElement("ComponentID").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                        if (rs.isLast()) {
                            previousReport = -1;
                            isLastExecuted = true;
                        } else {
                            rs.next();
                        }
                    } while (previousReport == rs.getInt(1));
                    if (isLastExecuted) {
                        break;
                    }
                    previousReport = -1;
                    rs.previous();
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    //SundarRavindran_28-Jul-2009_Start

    private void getEmailTimeTable(Element toHandle, Element toAppend) throws HandlerException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        String selectStmt = " SELECT e.id, e.report, e.user, e.time, e.day FROM emailTimeTable e ";
        try {
            stmt = transconn.prepareStatement(selectStmt);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element timeInfo = toAppend.addElement("timeInfo");
                timeInfo.addElement("id").addText(String.valueOf(rs.getInt(1)));
                timeInfo.addElement("report").addText(String.valueOf(rs.getInt(2)));
                timeInfo.addElement("user").addText(String.valueOf(rs.getInt(3)));
                timeInfo.addElement("time").addText(String.valueOf(rs.getTimestamp(4)));
                timeInfo.addElement("day").addText(String.valueOf(rs.getInt(5)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    //SundarRavindran_28-Jul-2009_End
    //NischaySharma_23-Jul-2009_End

    //NischaySharma_31-Jul-2009_Start
    private void getEmailReportDurations(Element toHandle, Element toAppend) throws HandlerException {
        ResultSet rs = null;
        PreparedStatement stmt = null;
        String selectStmt = " SELECT e.id, e.name, e.identifier FROM emailReportDurations e ";
        try {
            stmt = transconn.prepareStatement(selectStmt);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element emailReportDuration = toAppend.addElement("emailReportDuration");
                emailReportDuration.addElement("id").addText(String.valueOf(rs.getInt(1)));
                emailReportDuration.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                emailReportDuration.addElement("identifier").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    
     private void getEmailReportLogtype(Element toHandle, Element toAppend) throws HandlerException {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        String selectStmt = " SELECT e.id, e.name FROM emailReportLogtype e ";
        try {
            stmt = transconn.prepareStatement(selectStmt);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element emailReportLogtype = toAppend.addElement("emailReportLogtype");
                emailReportLogtype.addElement("id").addText(String.valueOf(rs.getInt(1)));
                emailReportLogtype.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
     
     
      private void getGrouping(Element toHandle, Element toAppend) throws HandlerException {

        String select = " SELECT id, name, segment FROM grouping ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element grouping = toAppend.addElement("grouping");
                grouping.addElement("id").addText(String.valueOf(rs.getInt(1)));
                grouping.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                grouping.addElement("segment").addText(String.valueOf(rs.getInt(3)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductSet: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getProductGrouping(Element toHandle, Element toAppend) throws HandlerException {

        String select = " SELECT pg.id, pg.grouping, pg.product, p.name FROM productGrouping pg LEFT JOIN product p "
                        + " ON  pg.product = p.id WHERE pg.grouping = ? ";

        int groupingId = HandlerUtils.getRequiredInteger(toHandle, "groupingId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, groupingId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element prdGrp = toAppend.addElement("productGrouping");
                prdGrp.addElement("id").addText(String.valueOf(rs.getInt(1)));
                prdGrp.addElement("groupingId").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                prdGrp.addElement("productId").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                prdGrp.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductSet: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getGroupingForGroup(Element toHandle, Element toAppend) throws HandlerException {

        String select = " SELECT gPG.id, g.id, g.name, g.segment FROM groupProductGroupingMap gPG LEFT JOIN grouping g ON g.id = gPG.grouping WHERE gPG.groups = ? ";
        String selectProductDetails = " SELECT pg.product, p.name FROM productGrouping pg LEFT JOIN product p ON pg.product = p.id WHERE pg.grouping = ? ";

        int groupId = HandlerUtils.getRequiredInteger(toHandle, "groupId");
        boolean getDetails = HandlerUtils.getOptionalBoolean(toHandle, "getDetails");
        PreparedStatement stmt = null;
        ResultSet rs = null, innerRS = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, groupId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element prdGrp = toAppend.addElement("groupPG");
                prdGrp.addAttribute("id", String.valueOf(rs.getInt(1)));
                prdGrp.addAttribute("groupingId", String.valueOf(rs.getInt(2)));
                prdGrp.addAttribute("name", HandlerUtils.nullToEmpty(rs.getString(3)));
                prdGrp.addAttribute("segment", String.valueOf(rs.getInt(4)));

                if(getDetails) {
                    stmt = transconn.prepareStatement(selectProductDetails);
                    stmt.setInt(1, rs.getInt(2));
                    innerRS = stmt.executeQuery();
                    while (innerRS.next()) {
                        Element prdDet = prdGrp.addElement("prodDetails");
                        prdDet.addAttribute("id", String.valueOf(innerRS.getInt(1)));
                        prdDet.addAttribute("name", HandlerUtils.nullToEmpty(innerRS.getString(2)));
                    }
                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductSet: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(innerRS);
            close(rs);
            close(stmt);
        }

    }
    
    
    private void getEmailReportLogs(Element toHandle, Element toAppend) throws HandlerException {

        String select = " SELECT emailReport, timeOfGeneration FROM emailReportLogs WHERE emailReportLogType = ? AND isProblem = ? AND timeOfGeneration between ? AND  ? ";

        int emailReportLogType = HandlerUtils.getRequiredInteger(toHandle, "emailReportLogType");
        int isProblem = HandlerUtils.getRequiredInteger(toHandle, "isProblem");
        String startDate = HandlerUtils.getRequiredString(toHandle, "startDate");
        String endDate = HandlerUtils.getRequiredString(toHandle, "endDate");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, emailReportLogType);
            stmt.setInt(2, isProblem);
            stmt.setString(3, startDate);
            stmt.setString(4, endDate);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element log = toAppend.addElement("getEmailReportLogDate");
                log.addAttribute("emailReport", rs.getString(1));
                log.addText(rs.getString(2));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductSet: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
    
    
        private void getKegLines(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "stationId");
        int coolerId = HandlerUtils.getOptionalInteger(toHandle, "coolerId");
        //NischaySharma_10-Jul-2009_Start: Added new request parameter locationId
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int zoneId = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        //NischaySharma_10-Jul-2009_End

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (coolerId >= 0) {
                String selectByCoolerId = "SELECT id, name, cooler " +
                        "FROM kegLine WHERE cooler=?";
                stmt = transconn.prepareStatement(selectByCoolerId);
                stmt.setInt(1, coolerId);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element KegLineE1 = toAppend.addElement("kegLine");
                    KegLineE1.addElement("id").addText(String.valueOf(rs.getInt(1)));
                    KegLineE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    KegLineE1.addElement("cooler").addText(String.valueOf(rs.getInt(3)));
                }

            } else if (id >= 0) {
                String selectByKegLineId = "SELECT id, name, cooler " +
                        "FROM kegLine WHERE id=?";
                stmt = transconn.prepareStatement(selectByKegLineId);
                stmt.setInt(1, id);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element KegLineE1 = toAppend.addElement("kegLine");
                    KegLineE1.addElement("id").addText(String.valueOf(rs.getInt(1)));
                    KegLineE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    KegLineE1.addElement("cooler").addText(String.valueOf(rs.getInt(3)));
                }

            } //NischaySharma_10-Jul-2009_Start: querying based on location id
            else if (locationId >= 0) {
                String selectByLocationId = " SELECT k.id, k.name, k.cooler FROM kegLine k " +
                        " LEFT JOIN cooler c on k.cooler = c.id " +
                        " WHERE c.location = ? ";
                stmt = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, locationId);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element KegLineE1 = toAppend.addElement("kegLine");
                    KegLineE1.addElement("id").addText(String.valueOf(rs.getInt(1)));
                    KegLineE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    KegLineE1.addElement("cooler").addText(String.valueOf(rs.getInt(3)));
                }
            } else if (zoneId >= 0) {
                String selectByZoneId = " SELECT k.id, k.name, k.cooler FROM kegLine k " +
                        " LEFT JOIN cooler c on k.cooler = c.id " +
                        " WHERE c.zone = ? ";
                stmt = transconn.prepareStatement(selectByZoneId);
                stmt.setInt(1, zoneId);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element KegLineE1 = toAppend.addElement("kegLine");
                    KegLineE1.addElement("id").addText(String.valueOf(rs.getInt(1)));
                    KegLineE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    KegLineE1.addElement("cooler").addText(String.valueOf(rs.getInt(3)));
                }
            } //NischaySharma_10-Jul-2009_End
            else {
                String selectAll = "SELECT id, name, cooler " +
                        "FROM kegLine";
                stmt = transconn.prepareStatement(selectAll);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element KegLineE1 = toAppend.addElement("kegLine");
                    KegLineE1.addElement("id").addText(String.valueOf(rs.getInt(1)));
                    KegLineE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    KegLineE1.addElement("cooler").addText(String.valueOf(rs.getInt(3)));
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
        
        
        private void getCoolersXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element CoolerE1 = toAppend.addElement("cooler");
            CoolerE1.addElement("coolerId").addText(String.valueOf(rs.getInt(1)));
            CoolerE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            CoolerE1.addElement("locationId").addText(String.valueOf(rs.getInt(3)));
            CoolerE1.addElement("zoneId").addText(String.valueOf(rs.getInt(4)));
            //NischaySharma_16-Jun-2009_Start: Changed the structure of response xml to send back
            //system and line also
            CoolerE1.addElement("system").addText(String.valueOf(rs.getInt(5)));
            CoolerE1.addElement("line").addText(String.valueOf(rs.getInt(6)));
            CoolerE1.addElement("alertPoint").addText(String.valueOf(rs.getInt(7)));
            //NischaySharma_16-Jun-2009_End
        }

    }

    private void getUnits(Element toHandle, Element toAppend) throws HandlerException {

        int platform = HandlerUtils.getOptionalInteger(toHandle, "platform");
        PreparedStatement stmt = null;
        ResultSet rs = null;
        if (platform < 1) {
            platform = 1;
        }
        try {
            String selectAll = "SELECT id, name, convValue FROM unit WHERE platform = ? ORDER BY name";
            stmt = transconn.prepareStatement(selectAll);
            stmt.setInt(1, platform);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element UnitE1 = toAppend.addElement("unit");
                UnitE1.addElement("unitId").addText(String.valueOf(rs.getInt(1)));
                UnitE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                UnitE1.addElement("convValue").addText(String.valueOf(rs.getFloat(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }


    private void getCoolers(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "coolerId");
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int zoneId = HandlerUtils.getOptionalInteger(toHandle, "zoneId");

        PreparedStatement stmt = null;
        ResultSet rs = null;
        //NischaySharma_16-Jun-2009_Start: Changed the query to return system and line also
        try {
            if (locationId >= 0) {
                String selectByLocationId = "SELECT id, name, location, zone, system, line, alertPoint " +
                        "FROM cooler WHERE location=?";
                stmt = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, locationId);
                rs = stmt.executeQuery();

                getCoolersXML(toAppend, rs);
            } else if (zoneId >= 0) {
                String selectByZoneId = "SELECT id, name, location, zone, system, line, alertPoint " +
                        "FROM cooler WHERE zone=?";
                stmt = transconn.prepareStatement(selectByZoneId);
                stmt.setInt(1, zoneId);
                rs = stmt.executeQuery();

                getCoolersXML(toAppend, rs);
            } else if (id >= 0) {
                String selectByCoolerId = "SELECT id, name, location, zone, system, line, alertPoint " +
                        "FROM cooler WHERE id=?";
                stmt = transconn.prepareStatement(selectByCoolerId);
                stmt.setInt(1, id);
                rs = stmt.executeQuery();

                getCoolersXML(toAppend, rs);
            } else {
                String selectAll = "SELECT id, name, location, zone, system, line, alertPoint " +
                        "FROM cooler";
                stmt = transconn.prepareStatement(selectAll);
                rs = stmt.executeQuery();

                getCoolersXML(toAppend, rs);
            }
            //NischaySharma_16-Jun-2009_End

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getStationsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element BarE1                   = toAppend.addElement("station");
            BarE1.addElement("stationId").addText(String.valueOf(rs.getInt(1)));
            BarE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            BarE1.addElement("barId").addText(String.valueOf(rs.getInt(3)));
            BarE1.addElement("barName").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            BarE1.addElement("zoneId").addText(String.valueOf(rs.getInt(5)));
            BarE1.addElement("zoneName").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
            BarE1.addElement("locationId").addText(String.valueOf(rs.getInt(7)));
            BarE1.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(8)));
        }
    }

    private void getStations(Element toHandle, Element toAppend) throws HandlerException {

        int id                              = HandlerUtils.getOptionalInteger(toHandle, "stationId");
        int barId                           = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int customerId                      = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int locationId                      = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int zoneId                          = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int parameter                       = 0;
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        String selectStations               = "SELECT st.id, st.name, b.id, b.name, z.id, z.name, lo.id, lo.name FROM station st LEFT JOIN bar b on st.bar = b.id " +
                                            " LEFT JOIN location lo on b.location = lo.id LEFT JOIN zone z ON z.id = b.zone ";
        try {
            if (id >= 0) {
                selectStations              += " WHERE st.id=? ";
                parameter                   = id;
            } else if (barId >= 0) {
                selectStations              += " WHERE b.id=? ";
                parameter                   = barId;
            } else if (zoneId > 0) {
                selectStations              += " WHERE z.id=? ";
                parameter                   = zoneId;
            } else if (locationId > 0) {
                selectStations              += " WHERE lo.id=? ";
                parameter                   = locationId;
            } else if (customerId > 0) {
                selectStations              += " WHERE lo.customer=? ";
                parameter                   = customerId;
            }
            stmt                            = transconn.prepareStatement(selectStations);
            stmt.setInt(1, parameter);
            rs                              = stmt.executeQuery();
            getStationsXML(toAppend, rs);
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getZonesXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element BarE1 = toAppend.addElement("zone");

            BarE1.addElement("zoneId").addText(String.valueOf(rs.getInt(1)));
            BarE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            BarE1.addElement("locationId").addText(String.valueOf(rs.getInt(3)));
            BarE1.addElement("latitude").addText(String.valueOf(rs.getDouble(4)));
            BarE1.addElement("longitude").addText(String.valueOf(rs.getDouble(5)));

            //NischaySharma_09-Feb-2009_Start: Added tags to hold Zone Poly Point
            String selectZonePolyPoints = "SELECT Replace(AsText(zp.points), 'POLYGON', '') FROM zone_point zp WHERE zp.zone = ? and zp.new = 1;";
            PreparedStatement stmt = transconn.prepareStatement(selectZonePolyPoints);
            stmt.setInt(1, rs.getInt(1));
            ResultSet tempRS = stmt.executeQuery();
            Element zonePolyPoints = BarE1.addElement("zonePolyPoints");
            if (tempRS.next()) {
                zonePolyPoints.addElement("zonePoints").addText(HandlerUtils.nullToEmpty(tempRS.getString(1)));
            }

            //NischaySharma_09-Feb-2009_End
        }

    }

    private void getZones(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int refLocationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int refCustomerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");

        int paramsSet = 0;
        if (id >= 0) {
            paramsSet++;
        }
        if (refLocationId >= 0) {
            paramsSet++;
        }
        if (refCustomerId >= 0) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getZones.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " +
                            refLocationId);
                }
                String selectByLocationId = "SELECT id, name, location, latitude, longitude " +
                        "FROM zone WHERE location = ?";
                stmt = transconn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                rs = stmt.executeQuery();
                getZonesXML(toAppend, rs);
            } else if (refCustomerId >= 0) {
                if (!checkForeignKey("customer", "id", refCustomerId)) {
                    throw new HandlerException("Foreign Key Not found : customer " +
                            refCustomerId);
                }
                String selectByCustomerId = "SELECT zone.id, zone.name, zone.location, zone.latitude, zone.longitude " +
                        "FROM zone LEFT JOIN location ON location.id=zone.location " +
                        "LEFT JOIN customer ON location.customer = customer.id " +
                        "WHERE customer.id=?";
                stmt = transconn.prepareStatement(selectByCustomerId);
                stmt.setInt(1, refCustomerId);
                rs = stmt.executeQuery();
                getZonesXML(toAppend, rs);

            } else if (id >= 0) {
                String selectByZoneId = "SELECT id, name, location, latitude, longitude " +
                        "FROM zone WHERE id=?";
                stmt = transconn.prepareStatement(selectByZoneId);
                stmt.setInt(1, id);
                rs = stmt.executeQuery();

                getZonesXML(toAppend, rs);
            } else {
                String selectByLocationId = "SELECT id, name, location, latitude, longitude " +
                        "FROM zone";
                stmt = transconn.prepareStatement(selectByLocationId);
                rs = stmt.executeQuery();

                getZonesXML(toAppend, rs);
            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }


 /**  Gets all beverages at a location
     *  This method now has an optional 'barId' param 
     *  If this is set, then only beverage matching this bar will be returned.  If this
     *  field is NOT set, then all beverages will be returned, regardless if they
     *  are associated with a specific bar or null
     *
     *  BarId 'b' supplied   =  Only beverages of bar 'b'
     *  BarId 'b' null       =  All beverages, including bar=null and bar='x'
     */
    private void getBeverages1(Element toHandle, Element toAppend) throws HandlerException {
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int barId                           = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int prodType                        = HandlerUtils.getRequiredInteger(toHandle, "prodID");
        boolean getComplexPlu               = HandlerUtils.getOptionalBoolean(toHandle, "getComplexPlu");
        String alphabet                     = HandlerUtils.getOptionalString(toHandle, "alphabet");
        String selectBeverages              = "SELECT id, name, plu, id, simple FROM beverage WHERE retired = 0 AND location=? AND pType=? AND ounces " + (barId > 0 ? " AND bar=?" : "");
        String selectIngredients            = "SELECT product.name, product.id, ingredient.ounces FROM ingredient LEFT JOIN product on ingredient.product = product.id " +
                                            " WHERE ingredient.beverage=?";
        if(alphabet!=null && !alphabet.equals("")&& !alphabet.equals("ALL")) {
            selectBeverages                 += " AND name like '"+alphabet+"%' ";
        }
        
        if (getComplexPlu) {
            selectBeverages                 += " AND id IN (SELECT id FROM (SELECT b.id id, COUNT(i.id) cnt FROM beverage b " +
                                            " LEFT JOIN ingredient i ON i.beverage = b.id WHERE b.location = ? GROUP BY b.id) as a WHERE cnt > 1)";
        }

        PreparedStatement stmt = null;
        ResultSet bev = null;
        ResultSet ing = null;
        try {
            int colCount                    = 1;
            stmt                            = transconn.prepareStatement(selectBeverages);
            stmt.setInt(colCount++, location);
            stmt.setInt(colCount++, prodType);
            if (barId > 0) {
                stmt.setInt(colCount++, barId);
            }
            if (getComplexPlu) {
                stmt.setInt(colCount++, location);
            }
            bev                             = stmt.executeQuery();
            while (bev.next()) {
                Element beverage = toAppend.addElement("beverage");
                beverage.addElement("id").addText(HandlerUtils.nullToEmpty(bev.getString(1)));
                beverage.addElement("name").addText(HandlerUtils.nullToEmpty(bev.getString(2)));
                beverage.addElement("plu").addText(HandlerUtils.nullToEmpty(bev.getString(3)));
                beverage.addElement("simple").addText(HandlerUtils.nullToEmpty(bev.getString(5)));
                stmt                        = transconn.prepareStatement(selectIngredients);
                stmt.setInt(1, bev.getInt(4));
                ing                         = stmt.executeQuery();
                while (ing.next()) {
                    Element ingredient      = beverage.addElement("ingredient");
                    ingredient.addElement("name").addText(HandlerUtils.nullToEmpty(ing.getString(1)));
                    ingredient.addElement("id").addText(HandlerUtils.nullToEmpty(ing.getString(2)));
                    ingredient.addElement("ounces").addText(HandlerUtils.nullToEmpty(ing.getString(3)));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(ing);
            close(bev);
            close(stmt);
        }
    }

    private void getComplexPlu(Element toHandle, Element toAppend)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String name = HandlerUtils.getRequiredString(toHandle, "name");
        int prodType = HandlerUtils.getRequiredInteger(toHandle, "prodID");
        String selectComplexPlu = "SELECT id, plu FROM beverage WHERE name = ? and location=? and pType=?";


        PreparedStatement stmt = null;
        ResultSet comp = null;
        try {
            stmt = transconn.prepareStatement(selectComplexPlu);
            stmt.setString(1, name);
            stmt.setInt(2, location);
            stmt.setInt(3, prodType);
            comp = stmt.executeQuery();
            while (comp.next()) {
                Element compPlu = toAppend.addElement("complexPlu");
                compPlu.addElement("id").addText(HandlerUtils.nullToEmpty(comp.getString(1)));
                compPlu.addElement("plu").addText(HandlerUtils.nullToEmpty(comp.getString(2)));


            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(comp);
            close(stmt);
        }


    }
    
    
    /**  Return the Variance Value for a location
     */
    private void getLocationVariance(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getOptionalInteger(toHandle, "location");

        String select = "Select varianceAlert FROM location where id=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                toAppend.addElement("varianceValue").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationVariance: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**  Return a list of all associated suppliers from this location
     */
    private void getBottleSize(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int prodType = HandlerUtils.getOptionalInteger(toHandle, "prodID");

        String select = "Select id, name FROM bottleSize where pType=? order by name";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, prodType);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element sup = toAppend.addElement("bottleSize");
                sup.addElement("id").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                sup.addElement("sizeName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getBottleSize: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**  Return a list of all associated suppliers from this location
     */
    private void getEventDates(Element toHandle, Element toAppend) throws HandlerException {

        int location                        = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int customer                        = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        String eventDate                    = HandlerUtils.getOptionalString(toHandle, "eventDate");

        int eventId                         = HandlerUtils.getOptionalInteger(toHandle, "eventId");
        boolean getNoDetails                = HandlerUtils.getOptionalBoolean(toHandle, "getNoDetails");

        boolean getPastGames                = HandlerUtils.getOptionalBoolean(toHandle, "getPastGames");
        String conditionString              = "";
        int parameter                       = -1;

        if (customer > 0) {
            conditionString                 = " WHERE l.customer = ? ";
            parameter                       = customer;
        } else {
            conditionString                 = " WHERE l.id = ? ";
            parameter                       = location;
        }

        if (eventDate != null && !eventDate.equals("")) {
            conditionString                 += " AND DATEDIFF(eH.date, '" + eventDate + "') = 0 ";
        }

        if(!getPastGames)
        {
            conditionString                 += " AND eH.date > LEFT(SUBDATE(NOW(),1),10) ";
        }

        String select                       = "SELECT eH.id, eH.location, l.name, eH.date, eH.eventDesc" +
                                            (getNoDetails ? "" : ", eH.eventPourStart, eH.preOpen, eH.eventStart, eH.eventEnd, eH.eventAfterHoursEnd ") +
                                            " FROM eventHours eH LEFT JOIN location l ON l.id = eH.location " + conditionString + (eventId > 0 ? " AND eH.id = ? " : "") +
                                            " ORDER BY eH.eventPourStart ";

        String selectSpecialHours           = "SELECT eH.id, eH.barString, eH.eventPourStart, eH.preOpen, eH.eventStart, eH.eventEnd, eH.eventAfterHoursEnd " +
                                            " FROM eventSpecialHours eH LEFT JOIN location l ON l.id = eH.location " + conditionString + " AND eH.date = ? " + 
                                            " ORDER BY eH.eventPourStart ";

        String selectCateredHours           = "SELECT eH.id, eH.barString, eH.eventPourStart, eH.preOpen, eH.eventStart, eH.eventEnd, eH.eventAfterHoursEnd " +
                                            " FROM eventCateredHours eH LEFT JOIN location l ON l.id = eH.location " + conditionString + " AND eH.date = ? " + 
                                            " ORDER BY eH.eventPourStart ";

        PreparedStatement stmt              = null;
        ResultSet rs                        = null, innerRS = null;

        try {
            stmt                            = transconn.prepareStatement(select);
            stmt.setInt(1, parameter);
            if(eventId > 0){ stmt.setInt(2, eventId); }
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                int i                       = 1;
                
                Element event               = toAppend.addElement("eventDates");
                event.addElement("eventId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                event.addElement("locationId").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                event.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                eventDate                   = rs.getString(i++);
                event.addElement("eventDate").addText(HandlerUtils.nullToEmpty(eventDate));
                event.addElement("eventDesc").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                if(!getNoDetails)
                {
                    
                    event.addElement("eventPourStart").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    event.addElement("eventPreOpenTime").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    event.addElement("eventStartTime").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    event.addElement("eventEndTime").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    event.addElement("eventAfterHoursEnd").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    
                    // Getting special events hours
                    stmt                    = transconn.prepareStatement(selectSpecialHours);
                    stmt.setInt(1, parameter);
                    stmt.setString(2, eventDate);
                    innerRS                 = stmt.executeQuery();
                    if (innerRS.next()) {
                        Element specialEvent= event.addElement("specialEventDates");
                        specialEvent.addElement("eventId").addText(HandlerUtils.nullToEmpty(innerRS.getString(1)));
                        specialEvent.addElement("barString").addText(HandlerUtils.nullToEmpty(innerRS.getString(2)));
                        specialEvent.addElement("eventPourStart").addText(HandlerUtils.nullToEmpty(innerRS.getString(3)));
                        specialEvent.addElement("eventPreOpenTime").addText(HandlerUtils.nullToEmpty(innerRS.getString(4)));
                        specialEvent.addElement("eventStartTime").addText(HandlerUtils.nullToEmpty(innerRS.getString(5)));
                        specialEvent.addElement("eventEndTime").addText(HandlerUtils.nullToEmpty(innerRS.getString(6)));
                        specialEvent.addElement("eventAfterHoursEnd").addText(HandlerUtils.nullToEmpty(innerRS.getString(7)));
                        
                    }

                    // Getting catered events hours
                    stmt                    = transconn.prepareStatement(selectCateredHours);
                    stmt.setInt(1, parameter);
                    stmt.setString(2, eventDate);
                    innerRS                 = stmt.executeQuery();
                    if (innerRS.next()) {
                        Element cateredEvent= event.addElement("cateredEventDates");
                        cateredEvent.addElement("eventId").addText(HandlerUtils.nullToEmpty(innerRS.getString(1)));
                        cateredEvent.addElement("barString").addText(HandlerUtils.nullToEmpty(innerRS.getString(2)));
                        cateredEvent.addElement("eventPourStart").addText(HandlerUtils.nullToEmpty(innerRS.getString(3)));
                        cateredEvent.addElement("eventPreOpenTime").addText(HandlerUtils.nullToEmpty(innerRS.getString(4)));
                        cateredEvent.addElement("eventStartTime").addText(HandlerUtils.nullToEmpty(innerRS.getString(5)));
                        cateredEvent.addElement("eventEndTime").addText(HandlerUtils.nullToEmpty(innerRS.getString(6)));
                        cateredEvent.addElement("eventAfterHoursEnd").addText(HandlerUtils.nullToEmpty(innerRS.getString(7)));
                        
                    }
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getEventDates: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(innerRS);
            close(rs);
            close(stmt);
        }
    }
    
    
    private void getSpecialCateredEvent(Element toHandle, Element toAppend) throws HandlerException {

        int location                        = HandlerUtils.getOptionalInteger(toHandle, "locationId");        
        String eventDate                    = HandlerUtils.getOptionalString(toHandle, "eventDate");
        int type                            = HandlerUtils.getOptionalInteger(toHandle, "type");
        
        String conditionString              = "";
        int parameter                       = -1;
        
        
        if (location > 0) {
            conditionString                 = " WHERE l.id = ? ";
            parameter                       = location;
        }

        if (eventDate != null && !eventDate.equals("")) {
            conditionString                 += " AND DATEDIFF(eH.date, '" + eventDate + "') = 0 ";
        }

        String selectSpecialHours           = "SELECT eH.id, eH.barString, eH.eventPourStart, eH.preOpen, eH.eventStart, eH.eventEnd, eH.eventAfterHoursEnd " +
                                            " FROM eventSpecialHours eH LEFT JOIN location l ON l.id = eH.location " + conditionString +
                                            " ORDER BY eH.eventPourStart ";

        String selectCateredHours           = "SELECT eH.id, eH.barString, eH.eventPourStart, eH.preOpen, eH.eventStart, eH.eventEnd, eH.eventAfterHoursEnd, eH.eventDesc " +
                                            " FROM eventCateredHours eH LEFT JOIN location l ON l.id = eH.location " + conditionString +
                                            " ORDER BY eH.eventPourStart ";

        PreparedStatement stmt              = null;
        ResultSet rs                        = null, innerRS = null;

        try {
            switch(type) {
                case 1: 
            stmt                            = transconn.prepareStatement(selectSpecialHours);
            stmt.setInt(1, parameter);            
            rs                              = stmt.executeQuery();
            if (rs.next()) {
                Element specialEvent        = toAppend.addElement("specialEvent");
                specialEvent.addElement("eventId").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                specialEvent.addElement("barString").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                specialEvent.addElement("eventPourStart").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                specialEvent.addElement("eventPreOpenTime").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                specialEvent.addElement("eventStartTime").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                specialEvent.addElement("eventEndTime").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                specialEvent.addElement("eventAfterHoursEnd").addText(HandlerUtils.nullToEmpty(rs.getString(7)));                 
                    
                }
            break;
                case 2: 
                    // Getting catered events hours
                    stmt                    = transconn.prepareStatement(selectCateredHours);
                    stmt.setInt(1, parameter);
                    rs                 = stmt.executeQuery();
                    if (rs.next()) {                       
                        Element cateredEvent= toAppend.addElement("cateredEvent");
                        cateredEvent.addElement("eventId").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                        cateredEvent.addElement("barString").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                        cateredEvent.addElement("eventPourStart").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                        cateredEvent.addElement("eventPreOpenTime").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                        cateredEvent.addElement("eventStartTime").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                        cateredEvent.addElement("eventEndTime").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                        cateredEvent.addElement("eventAfterHoursEnd").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
                        cateredEvent.addElement("eventDesc").addText(HandlerUtils.nullToEmpty(rs.getString(8)));
                        
                    }
                    break;
            }
    
        } catch (SQLException sqle) {
            logger.dbError("Database error in getEventDates: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(innerRS);
            close(rs);
            close(stmt);
        }
    }

    /**  Return a list of all associated suppliers from this location
     */
    private void getStandUnitCount(Element toHandle, Element toAppend) throws HandlerException {

        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int zone = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int bar = HandlerUtils.getOptionalInteger(toHandle, "barId");
        String eventStartTime = HandlerUtils.getOptionalString(toHandle, "eventStartTime");

        //NischaySharma_12-Feb-2009_Start: Changed the xml to fetch unitStandCountId, barid and zoneid
        String select = "SELECT p.id, p.name, ifnull(uSC.count,0), ifnull(uSC.id,0), " +
                " ifnull(uSC.bar,0), ifnull(uSC.zone,0) FROM unitStandCount uSC " +
                " LEFT JOIN product p ON p.id = uSC.product " +
                " WHERE uSC.location = ? ";
        if (zone > 0) {
            select += " AND uSC.zone = ? ";
        }
        if (bar > 0) {
            select += " AND uSC.bar = ? ";
        }
        select += " AND uSC.date BETWEEN ? and (? + INTERVAL 1 DAY) GROUP BY uSC.bar, p.id";

        //NischaySharma_12-Feb-2009_End
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            int fieldCount = 0;

            stmt = transconn.prepareStatement(select);
            stmt.setInt(++fieldCount, location);
            if (zone > 0) {
                stmt.setInt(++fieldCount, zone);
            }
            if (bar > 0) {
                stmt.setInt(++fieldCount, bar);
            }
            stmt.setString(++fieldCount, eventStartTime);
            stmt.setString(++fieldCount, eventStartTime);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element eventStandCount = toAppend.addElement("eventStandCount");
                eventStandCount.addElement("productID").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                eventStandCount.addElement("product").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                eventStandCount.addElement("count").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                //NischaySharma_12-Feb-2009_Start: Added new tags to the response XML: unitStandCountId,
                //barId & zoneId
                eventStandCount.addElement("unitStandCountId").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                eventStandCount.addElement("barId").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                eventStandCount.addElement("zoneId").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                //NischaySharma_12-Feb-2009_End
                }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getStandUnitCount: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**  Return a list of all associated suppliers from this location
     */
    private void getUnitCount(Element toHandle, Element toAppend) throws HandlerException {

        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int zone = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int bar = HandlerUtils.getOptionalInteger(toHandle, "barId");
        String eventStartTime = HandlerUtils.getOptionalString(toHandle, "eventStartTime");
        //NischaySharma_12-Feb-2009_Start: chnaged the query to return UnitCountId also
        String select = "SELECT p.id, p.name, st.id, st.name, ifnull(uC.count,0), ifnull(uC.id,0) FROM unitCount uC " +
                " LEFT JOIN product p ON p.id = uC.product " +
                " LEFT JOIN station st ON st.id = uC.station " +
                " WHERE uC.location = ?";
        if (zone > 0) {
            select += " and uC.zone = ? ";
        }
        if (bar > 0) {
            select += " and uC.bar = ? ";
        }
        select += " AND uC.date BETWEEN ? and (? + INTERVAL 1 DAY)" +
                " GROUP BY uC.station, p.id;";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            int fieldCount = 0;

            stmt = transconn.prepareStatement(select);
            stmt.setInt(++fieldCount, location);
            if (zone > 0) {
                stmt.setInt(++fieldCount, zone);
            }
            if (bar > 0) {
                stmt.setInt(++fieldCount, bar);
            }
            stmt.setString(++fieldCount, eventStartTime);
            stmt.setString(++fieldCount, eventStartTime);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element eventStandCount = toAppend.addElement("eventCount");
                eventStandCount.addElement("productID").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                eventStandCount.addElement("product").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                eventStandCount.addElement("stationID").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                eventStandCount.addElement("station").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                eventStandCount.addElement("count").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                //NischaySharma_12-Feb-2009_Start: Added tag unitCountId to the response XML
                eventStandCount.addElement("unitCountId").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                //NischaySharma_12-Feb-2009_End
                }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getStandUnitCount: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    
    
    /**  Get all products ordered after a cutoff date or within X days (date takes priority
     */
    private void getRecentlyReceivedProducts(Element toHandle, Element toAppend) throws HandlerException {
        String cutoffDate = HandlerUtils.getOptionalString(toHandle, "date");
        String startDate = HandlerUtils.getOptionalString(toHandle, "startDate");
        String endDate = HandlerUtils.getOptionalString(toHandle, "endDate");
        int cutoffDays = HandlerUtils.getOptionalInteger(toHandle, "daysOld");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String dateCondition = "";
        if (cutoffDate != null) {
            dateCondition = " AND p.date>?";
        } else if (cutoffDays > 0) {
            dateCondition = " AND TO_DAYS(NOW())-TO_DAYS(p.date) <= ? ";
        } else if (startDate != null && endDate != null) {
            dateCondition = " AND p.date BETWEEN ? AND ? ";
        }
        String getRecent =
                " SELECT DISTINCT pr.id, pr.name " +
                " FROM purchaseDetail d LEFT JOIN purchase p ON d.purchase=p.id " +
                "   LEFT JOIN product pr ON d.product = pr.id " +
                " WHERE p.location=? " + dateCondition;
        String getReceived =
                " SELECT d.product,pr.name,SUM(d.quantity) " +
                " FROM purchase p LEFT JOIN purchaseDetail d ON d.purchase=p.id " +
                " LEFT JOIN product pr ON d.product=pr.id " +
                " WHERE p.location=? AND p.status='RECEIVED' AND d.product IS NOT NULL" + dateCondition +
                " GROUP BY pr.id ";

        HashMap<Integer, String> productNames = new HashMap<Integer, String>();
        //Set<Integer> recentProducts = new HashSet<Integer>();
        HashMap<Integer, Integer> onOrder = new HashMap<Integer, Integer>();

        try {
            // get recently received products
            stmt = transconn.prepareStatement(getRecent);
            stmt.setInt(1, location);
            if (cutoffDate != null) {
                stmt.setString(2, cutoffDate);
            } else if (cutoffDays > 0) {
                stmt.setInt(2, cutoffDays);
            } else if (startDate != null && endDate != null) {
                stmt.setString(2, startDate);
                stmt.setString(3, endDate);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Integer productId = new Integer(rs.getInt(1));
                String productName = rs.getString(2);
                productNames.put(productId, productName);
                //recentProducts.add(productId);
            }

            // get received orders
            stmt = transconn.prepareStatement(getReceived);
            stmt.setInt(1, location);
            if (cutoffDate != null) {
                stmt.setString(2, cutoffDate);
            } else if (startDate != null && endDate != null) {
                stmt.setString(2, startDate);
                stmt.setString(3, endDate);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Integer productId = new Integer(rs.getInt(1));
                String productName = rs.getString(2);
                Integer quantity = new Integer(rs.getInt(3));
                productNames.put(productId, productName);
                onOrder.put(productId, quantity);
            }

            //build the output XML
            for (Integer pkey : productNames.keySet()) {
                Element prEl = toAppend.addElement("product");
                prEl.addElement("productId").addText(String.valueOf(pkey));
                prEl.addElement("name").addText(String.valueOf(productNames.get(pkey)));
                int orderQty = 0;
                Integer checkQty = onOrder.get(pkey);
                if (checkQty != null) {
                    orderQty = checkQty.intValue();
                }
                prEl.addElement("receivedQuantity").addText(String.valueOf(orderQty));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    
    private void getLocationData(Element toHandle, Element toAppend) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;

        int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int mobileUserId = HandlerUtils.getOptionalInteger(toHandle, "mobileUserId");
        
        int callerId = getCallerId(toHandle);

        String getLocationData = "SELECT l.id, l.name, l.lastPoured, l.picoPowerup, l.picoVersion, l.lastSold, l.processorName, l.processorVersion, l.gatewayVersion, l.volAdjustment" +
                                " FROM location l LEFT JOIN locationDetails lD ON lD.location = l.id   WHERE lD.active = 1 ";
        String getCustomerName = "SELECT name from customer where id = ?";
        String getStatus                    = "SELECT c.name, l.name, l.lastPoured, l.lastSold, b.lastPing FROM location l LEFT JOIN locationDetails lD ON lD.location = l.id LEFT JOIN customer c ON c.id = l.customer LEFT JOIN beerboard b ON l.id = b.location WHERE lD.active = 1 ";
        
            
        try {
            if(customerId > 0) {
                 if(locationId > 0) {
                     getStatus                   += "AND l.customer =? AND l.id ="+locationId+" ORDER BY l.lastSold;";
                     getLocationData        +=" AND l.customer = ? AND l.id ="+locationId+"  ORDER BY l.name ;  ";
                 } else {
                     getStatus              += "AND l.customer =? ORDER BY l.lastSold;";
                     getLocationData        +=" AND l.customer = ?  ORDER BY l.name ;  ";
                 }
          
            String logMessage = "Getting location information for customer" + customerId;
            stmt = transconn.prepareStatement(getLocationData);            
            stmt.setInt(1, customerId);            
            rs = stmt.executeQuery();
            while (rs != null && rs.next()) {
                int rsIndex = 1;
                Element locEl = toAppend.addElement("location");
                locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("lastPoured").addText(String.valueOf(rs.getString(rsIndex++)));
                locEl.addElement("picoPowerup").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("picoVersion").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("lastSold").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("processorName").addText(String.valueOf(rs.getString(rsIndex++)));
                locEl.addElement("processorVersion").addText(String.valueOf(rs.getString(rsIndex++)));
                locEl.addElement("gatewayVersion").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                
            }
            
            
            stmt = transconn.prepareStatement(getStatus);            
            stmt.setInt(1, customerId);            
            rs = stmt.executeQuery();
            while (rs != null && rs.next()) {
                int rsIndex = 1;
                Element locEl = toAppend.addElement("status");
                locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("bevbox").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("gateway").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("bbtv").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                
            }
            
            stmt = transconn.prepareStatement(getCustomerName);
            stmt.setInt(1, customerId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("customerName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }
            } else {
                
                getStatus                   += " ORDER BY l.lastSold;";
                stmt = transconn.prepareStatement(getStatus);            
                     
            rs = stmt.executeQuery();
            while (rs != null && rs.next()) {
                int rsIndex = 1;
                Element locEl = toAppend.addElement("status");
               locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("bevbox").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("gateway").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                locEl.addElement("bbtv").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                
            }
                           
                
            }
            
            if(mobileUserId > 0 && locationId > 0) {
                stmt                        = transconn.prepareStatement("SELECT active FROM bevMobileLocationMap WHERE location = ? AND user =?");
                stmt.setInt(1, locationId);
                stmt.setInt(2, mobileUserId);
                rs                          = stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("notification").addText(String.valueOf(1));
                } else {
                    toAppend.addElement("notification").addText(String.valueOf(0));
                }
                
                stmt            = transconn.prepareStatement("UPDATE bevMobileUser SET lastAccess = now() WHERE id= ? ");
                stmt.setInt(1,mobileUserId);
                stmt.executeUpdate();
                //SQLBevManagerMobileHandler log = new SQLBevManagerMobileHandler();
                addMobileUserHistory(callerId, "locationData", locationId, "Access bevBOX,bbtv lastPing and Cooler Temperature", mobileUserId);
            } 
            
            
            stmt = transconn.prepareStatement("SELECT id,alertPoint  FROM cooler WHERE location = ?");            
            stmt.setInt(1, locationId);
            rs = stmt.executeQuery();
            if(rs.next()) {
                String cooler               = rs.getString(1);
                int alertPoint              = rs.getInt(2);
                if(cooler==null|| cooler.equals("")) {
                    cooler                  = "0";
                }
            stmt = transconn.prepareStatement("Select  ROUND(cT.value,2), cT.date FROM coolerTemperature cT WHERE cT.cooler IN ("+cooler+") AND DATE(cT.date) = DATE(now()) ORDER BY cT.date DESC LIMIT 1;");                                                
            rs = stmt.executeQuery();
            if (rs.next()) { 
                toAppend.addElement("cooler").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            } else {
                toAppend.addElement("cooler").addText(String.valueOf(0));
                
            }
            toAppend.addElement("coolerAlert").addText(String.valueOf(alertPoint));
            } else {
                toAppend.addElement("cooler").addText(String.valueOf(0));
                toAppend.addElement("coolerAlert").addText(String.valueOf(0));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationData: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
        }
    }

    
      /**  Obtain a list of the user-defined beverage sizes for a location
     *
     *  required arguments:
     *  <locationId>
     *
     *  returns:
     *  <size>
     *    <id>int</id>
     *    <name>String</name>
     *    <ounces>00.0</ounces>
     *  </size>
     *  <size>...</size>
     *
     */
    private void getBeverageSizes1(Element toHandle, Element toAppend)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int prodType = HandlerUtils.getRequiredInteger(toHandle, "prodID");
        String select = "SELECT id,name,ounces FROM beverageSize WHERE location=? and pType=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        boolean hasSize = false;
        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, location);
            stmt.setInt(2, prodType);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element size = toAppend.addElement("size");
                size.addElement("id").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                size.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                size.addElement("ounces").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                hasSize = true;
            }
            if (!hasSize) {
                Element size = toAppend.addElement("size");
                size.addElement("id").addText(HandlerUtils.nullToEmpty("0"));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getBeverageSizes: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /**
     * The folowing code is to fetch the inventory items for each location when a single beverage is selected 
     *---- SR
     */
    private void getDraftInventoryXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element InventoryE1 = toAppend.addElement("inventoryItem");

            InventoryE1.addElement("inventoryId").addText(String.valueOf(rs.getInt(1)));
            InventoryE1.addElement("productId").addText(String.valueOf(rs.getInt(2)));
            InventoryE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            InventoryE1.addElement("locationId").addText(String.valueOf(rs.getInt(4)));
            InventoryE1.addElement("qtyOnHand").addText(String.valueOf(rs.getDouble(5)));
            InventoryE1.addElement("minimumQty").addText(String.valueOf(rs.getDouble(6)));
            InventoryE1.addElement("pluCode").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
            InventoryE1.addElement("qtyToOrder").addText(String.valueOf(rs.getInt(8)));
            InventoryE1.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
            InventoryE1.addElement("supplierId").addText(String.valueOf(rs.getInt(10)));
            InventoryE1.addElement("kegSize").addText(String.valueOf(rs.getInt(11)));
            InventoryE1.addElement("brixWater").addText(String.valueOf(rs.getInt(12)));
            InventoryE1.addElement("brixSyrup").addText(String.valueOf(rs.getInt(13)));
            InventoryE1.addElement("prodType").addText(String.valueOf(rs.getInt(14)));
        }

    }

    
    
     /**  Return a list of all Keg sizes
     */
    private void getKegSize(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int prodType = HandlerUtils.getOptionalInteger(toHandle, "prodID");

        String select = "Select name, size FROM kegSize order by size";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element sup = toAppend.addElement("kegSize");
                sup.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                sup.addElement("size").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getKegSize: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }


    private void getShifts(Element toHandle, Element toAppend)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "location");
        String select = "SELECT preOpenSun, openSun, closeSun, preOpenMon, openMon, closeMon, preOpenTue, openTue, closeTue, preOpenWed, openWed, closeWed, preOpenThu, openThu, closeThu, preOpenFri, openFri, closeFri, preOpenSat, openSat, closeSat FROM locationHours WHERE location=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            while (rs.next()) {

                toAppend.addElement("preOpenSun").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("openSun").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("closeSun").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                toAppend.addElement("preOpenMon").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                toAppend.addElement("openMon").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                toAppend.addElement("closeMon").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                toAppend.addElement("preOpenTue").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
                toAppend.addElement("openTue").addText(HandlerUtils.nullToEmpty(rs.getString(8)));
                toAppend.addElement("closeTue").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
                toAppend.addElement("preOpenWed").addText(HandlerUtils.nullToEmpty(rs.getString(10)));
                toAppend.addElement("openWed").addText(HandlerUtils.nullToEmpty(rs.getString(11)));
                toAppend.addElement("closeWed").addText(HandlerUtils.nullToEmpty(rs.getString(12)));
                toAppend.addElement("preOpenThu").addText(HandlerUtils.nullToEmpty(rs.getString(13)));
                toAppend.addElement("openThu").addText(HandlerUtils.nullToEmpty(rs.getString(14)));
                toAppend.addElement("closeThu").addText(HandlerUtils.nullToEmpty(rs.getString(15)));
                toAppend.addElement("preOpenFri").addText(HandlerUtils.nullToEmpty(rs.getString(16)));
                toAppend.addElement("openFri").addText(HandlerUtils.nullToEmpty(rs.getString(17)));
                toAppend.addElement("closeFri").addText(HandlerUtils.nullToEmpty(rs.getString(18)));
                toAppend.addElement("preOpenSat").addText(HandlerUtils.nullToEmpty(rs.getString(19)));
                toAppend.addElement("openSat").addText(HandlerUtils.nullToEmpty(rs.getString(20)));
                toAppend.addElement("closeSat").addText(HandlerUtils.nullToEmpty(rs.getString(21)));

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getBeverageSizes: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }
    
    
    private void getLocationId(Element toHandle, Element toAppend) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;

        int store = HandlerUtils.getRequiredInteger(toHandle, "storeId");

        String getLocationId = "SELECT location FROM customerStoreId WHERE store=?";
        try {
            stmt = transconn.prepareStatement(getLocationId);
            stmt.setInt(1, store);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("locationId").addText(String.valueOf(rs.getInt(1)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationId: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {

            close(stmt);
        }

    }
    
    
    /** Return all customer-managers for a specific customer
     */
    private void getTestAdminUsers(Element toHandle, Element toAppend) throws HandlerException {

        int customerId                      = HandlerUtils.getRequiredInteger(toHandle, "customerId");

        String getGroupId                   = " SELECT groupId FROM customer WHERE id=? ";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            int parameter                   = -1;
            ArrayList<Integer> userIds      = new ArrayList<Integer>();
            String listSelection            = "customer";
            
            stmt                            = transconn.prepareStatement(getGroupId);
            stmt.setInt(1, customerId);
            rs                              = stmt.executeQuery();
            if (rs.next() && (rs.getInt(1) > 0)) {
                parameter                   = rs.getInt(1);
                listSelection               = "groupId";
            } else {
                parameter                   = customerId;
            }

            String getAdmins                = " SELECT id,name,email FROM user WHERE " + listSelection + "=? AND isManager=1 ORDER BY name, username ";
            stmt                            = transconn.prepareStatement(getAdmins);
            stmt.setInt(1, parameter);
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                int userId                  = rs.getInt(1);
                if (userIds.contains(userId)) {
                    continue;
                } else {
                    userIds.add(userId);
                }
                Element userEl              = toAppend.addElement("user");
                userEl.addElement("userId").addText(String.valueOf(userId));
                userEl.addElement("fullName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                userEl.addElement("email").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }

            String getITAdmins              = " SELECT id,name,email FROM user WHERE " + listSelection + "=? AND isITAdmin=1 ORDER BY name, username ";
            stmt                            = transconn.prepareStatement(getITAdmins);
            stmt.setInt(1, parameter);
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                int userId                  = rs.getInt(1);
                if (userIds.contains(userId)) {
                    continue;
                } else {
                    userIds.add(userId);
                }
                Element userEl              = toAppend.addElement("ITuser");
                userEl.addElement("userId").addText(String.valueOf(userId));
                userEl.addElement("fullName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                userEl.addElement("email").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    
    
    /**  Return a list of all associated suppliers from this location
     */
    private void getInventoryDates(Element toHandle, Element toAppend) throws HandlerException {

        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");

        String select = "Select DISTINCT date FROM bottleInv where location=? order by date desc";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element sup = toAppend.addElement("invDates");
                sup.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getInventoryDates: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }


/**  Return a list of all associated suppliers from this location
     */
    private void getBottleInventoryData(Element toHandle, Element toAppend) throws HandlerException {

        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        String invDate = HandlerUtils.getOptionalString(toHandle, "invDate");

        String select = "Select b.id, b.product, p.name, b.location, b.bar, b.lastActualInv, b.received, b.sold, b.calcOnhand, b.actualInv, b.var FROM bottleInv b left join product p on p.id = b.product where b.location=? and b.date =?";

        String selectStartDate = "Select date FROM bottleInv where location=? and date <? order by date desc limit 1";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = transconn.prepareStatement(select);
            stmt.setInt(1, location);
            stmt.setString(2, invDate);
            rs = stmt.executeQuery();
            while (rs.next()) {
                int colCount = 1;
                Element sup = toAppend.addElement("invData");
                sup.addElement("inventoryID").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("product").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("locationId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("bar").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("lastActualInv").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("ordered").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("sold").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("calcOnHand").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("actInventory").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                sup.addElement("variance").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            }
            stmt = transconn.prepareStatement(selectStartDate);
            stmt.setInt(1, location);
            stmt.setString(2, invDate);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getBottleInventoryData: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    
    
     /**  Return Yesterdays's Value for a location
     */
    private void getYesterdayVariance(Element toHandle, Element toAppend) throws HandlerException {
        int user    = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int customer = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int sqlParameter = 0;

        String selectPoured = "Select SUM(ps.value)*l.volAdjustment FROM openHoursSummary ps LEFT JOIN product p on ps.product = p.id " +
                " LEFT JOIN location l ON l.id = ps.location WHERE p.pType=1 and ps.date=? AND l.id = ? GROUP BY ps.location ORDER BY ps.location";
        String selectSold = "Select SUM(ss.value) FROM openHoursSoldSummary ss LEFT JOIN product p on ss.product = p.id " +
                " LEFT JOIN location l ON l.id = ss.location WHERE p.pType=1 and ss.date=? AND l.id = ? group by ss.location ORDER BY ss.location ";
        String selectLocation = "Select l.id FROM location l ";
        PreparedStatement stmt = null;
        ResultSet rs = null, rsLocation = null;
        Calendar date1 = Calendar.getInstance();
        date1.add(Calendar.DATE, -1);

        int paramsSet = 0, locationId = 0;

        if (user >= 0) {
            paramsSet++;
            selectLocation += " LEFT JOIN userMap uM ON uM.location = l.id WHERE uM.user = ? ";
            sqlParameter = user;
        }

        if (location >= 0) {
            paramsSet++;
            selectLocation += " WHERE l.id = ? ";
            sqlParameter = location;
        }

        if (customer >= 0) {
            paramsSet++;
            selectLocation += " WHERE l.customer = ? ";
            if(regionId > 0) {
                selectLocation              += "  AND l.region =  "+String.valueOf(regionId);
            }
            selectLocation                  +="  ORDER BY l.name";
            sqlParameter = customer;
        }

        if (paramsSet != 1) {
            throw new HandlerException("Exactly one of the following must be set: location customer");
        }

        String Yesterday = String.valueOf(date1.get(Calendar.YEAR)) + "-0" + String.valueOf(date1.get(Calendar.MONTH) + 1) + "-" + String.valueOf(date1.get(Calendar.DAY_OF_MONTH));

        try {
            stmt = transconn.prepareStatement(selectLocation);
            stmt.setInt(1, sqlParameter);
            rsLocation = stmt.executeQuery();
            while (rsLocation.next()) {
                double pouredTotal = 0.00, soldTotal = 0.00, varTotal = 0.00;

                locationId = rsLocation.getInt(1);

                stmt = transconn.prepareStatement(selectPoured);
                stmt.setString(1, Yesterday);
                stmt.setInt(2, locationId);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    pouredTotal = rs.getDouble(1);
                }

                stmt = transconn.prepareStatement(selectSold);
                stmt.setString(1, Yesterday);
                stmt.setInt(2, locationId);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    soldTotal = rs.getDouble(1);
                }

                varTotal = ((soldTotal - pouredTotal) / pouredTotal) * 100;

                Element locationEl = toAppend.addElement("location");
                locationEl.addElement("locationId").addText(String.valueOf(locationId));
                locationEl.addElement("pouredTotal").addText(String.valueOf(pouredTotal));
                locationEl.addElement("soldTotal").addText(String.valueOf(soldTotal));
                locationEl.addElement("ydayVariance").addText(String.valueOf(varTotal));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getYesterdayVariance: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**  Create a new beverage by copying the recipe from a plu at the same location,
     *  but scaling it to a new size. This method now includes
     *  an optional "barId"  If this is set, the beverage will be associated with this
     *  bar.  If not, the beverage will have a 'null' bar field. 
     *  
     *
     *  <locationId>
     *  <beverage>
     *    <plu>"String"
     *    <copyFrom>"String"
     *    <size>0.00
     *  </beverage>  
     *
     */
    private void copyTestBeverage(Element toHandle, Element toAppend) throws HandlerException {

        boolean forCustomer = HandlerUtils.getOptionalBoolean(toHandle, "forCustomer");
        
        int location = 0;

        location = HandlerUtils.getRequiredInteger(toHandle, "location");
        int callerId = getCallerId(toHandle);

        String selectLocations = " SELECT id FROM location WHERE customer = ? ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (forCustomer) {
                int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");
                stmt = transconn.prepareStatement(selectLocations);
                stmt.setInt(1, customerId);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    location = rs.getInt(1);
                    copyBeverageDetail(callerId, location, toHandle, toAppend);
                }
            } else {
                location = HandlerUtils.getRequiredInteger(toHandle, "location");
                copyBeverageDetail(callerId, location, toHandle, toAppend);
            }
        } catch (SQLException sqle) {
            logger.dbError("SQL Exception: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }
    
    
    private void copyBeverageDetail(int callerId, int location, Element toHandle, Element toAppend) throws HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;
        ResultSet ings = null;

        
        int bar = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int prodType = HandlerUtils.getRequiredInteger(toHandle, "prodID");

        String checkPlu =
                " SELECT id FROM beverage WHERE plu=? AND location=?";
        String getLastId =
                " SELECT LAST_INSERT_ID()";
        String getReference =
                " SELECT b.name, b.simple, SUM(i.ounces) FROM beverage b LEFT JOIN ingredient i ON " +
                " i.beverage=b.id WHERE b.id=? GROUP BY b.id ";
        String getIngs =
                " SELECT product,ounces FROM ingredient WHERE beverage=?";
        String insertBev = (bar > 0 ? " INSERT INTO beverage (name, location, plu, ounces, simple, pType, bar) VALUES (?,?,?,?,?,?,?) "
                : " INSERT INTO beverage (name, location, plu, ounces, simple, pType) VALUES (?,?,?,?,?,?)");
        String insertIng =
                " INSERT INTO ingredient (beverage, product, ounces) " +
                " VALUES (?,?,?)";

        boolean oldAutoCommit = true;
        boolean changedAutoCommit = false;

        try {

            oldAutoCommit = transconn.getAutoCommit();
            changedAutoCommit = true;
            transconn.setAutoCommit(false);

            Iterator bevs = toHandle.elementIterator("beverage");
            while (bevs.hasNext()) {
                Element beverage = (Element) bevs.next();

                String plu = HandlerUtils.getRequiredString(beverage, "plu");
                String copyFrom = HandlerUtils.getRequiredString(beverage, "copyFrom");
                double size = HandlerUtils.getRequiredDouble(beverage, "size");
                String name = HandlerUtils.getOptionalString(beverage, "name");
                int simple = HandlerUtils.getOptionalInteger(beverage, "simple");
                boolean overWrite = HandlerUtils.getOptionalBoolean(beverage, "overwrite");
                if (simple < 0) {
                    simple = 1;
                }

                // check that the reference plu exists
                stmt = transconn.prepareStatement(checkPlu);
                stmt.setString(1, copyFrom);
                stmt.setInt(2, location);
                rs = stmt.executeQuery();
                int fromId=0;
                if (rs.next()) {
                    fromId = rs.getInt(1);
                } else {
                    addErrorDetail(toAppend, "Reference plu doesn't exist: " + copyFrom);
                    continue;
                     
                    
                }
                //check that the new plu doesn't already exist
                stmt = transconn.prepareStatement(checkPlu);
                stmt.setString(1, plu);
                stmt.setInt(2, location);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    addErrorDetail(toAppend, "The plu '" + plu + "' already exists");
                    continue;
                     
                }

                //get the details of the reference beverage and the list of ingredients
                stmt = transconn.prepareStatement(getReference);
                stmt.setInt(1, fromId);
                rs = stmt.executeQuery();
                double scaleFactor = 1;
                simple = 0;
                name = "";
                if (rs.next()) {
                    name = rs.getString(1);
                    simple = rs.getInt(2);
                    scaleFactor = size / rs.getDouble(3);
                } else {
                    addErrorDetail(toAppend, "Reference plu doesn't exist: " + copyFrom);
                    continue;
                     
                }
                stmt = transconn.prepareStatement(getIngs);
                stmt.setInt(1, fromId);
                ings = stmt.executeQuery();

                // insert the bev (name,location,plu,simple)
                stmt = transconn.prepareStatement(insertBev);
                stmt.setString(1, name);
                stmt.setInt(2, location);
                stmt.setString(3, plu);
                stmt.setDouble(4, size);
                stmt.setInt(5, simple);
                stmt.setInt(6, prodType);
                if (bar > 0) {
                    stmt.setInt(7, bar);
                }
                stmt.executeUpdate();
                stmt = transconn.prepareStatement(getLastId);
                rs = stmt.executeQuery();
                int newId = 0;
                if (rs.next()) {
                    newId = rs.getInt(1);
                } else {
                    addErrorDetail(toAppend, "Database Error");
                    transconn.rollback();
                    continue;
                }

                //add the ingredients
                double sizeLeft = size;
                while (ings.next()) {
                    double sizeToInsert = 0.0;
                    int product = ings.getInt(1);
                    if (ings.isLast()) {
                        sizeToInsert = sizeLeft;
                    } else {
                        sizeToInsert = twoPlaces(scaleFactor * ings.getDouble(2));
                        sizeLeft -= sizeToInsert;
                    }
                    logger.debug("Adding ingredient " + product + ": " + sizeToInsert + " oz");
                    stmt = transconn.prepareStatement(insertIng); // (bev,product,ounces)
                    stmt.setInt(1, newId);
                    stmt.setInt(2, product);
                    stmt.setDouble(3, sizeToInsert);
                    stmt.executeUpdate();
                }
                String logMessage = "Added plu#" + plu + " (copied from " + copyFrom + " to " + size + " oz)";
                logger.portalDetail(callerId, "addBeverage", location, "beverage", newId, logMessage, transconn);
                transconn.commit();
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            if (null != transconn && changedAutoCommit) {
                try {
                    transconn.setAutoCommit(oldAutoCommit);
                } catch (SQLException ignore) {
                }
            }
            close(ings);
            close(stmt);
            close(rs);
        }
    }
    
    
    private double twoPlaces(double d) {
        return Math.floor(d * 100 + 0.5) / 100;
    }
    
    
    private void sendOpenTicket(Element toHandle, Element toAppend) throws HandlerException {

        PreparedStatement stmt              = null;
        ResultSet rs                        = null,ticketRs = null;
        
        String selectAssignTo               ="SELECT count(id),assignedTo,(SELECT email FROM user WHERE id = assignedTo)As email,DATE(now()) FROM ticket WHERE close is NULL GROUP BY assignedTo;";

        String checkOpenTickets             = "SELECT CONCAT(c.name, ' : ', l.name),(SELECT name FROM user WHERE id = t.owner)As Owner,  t. notes, tC.name AS Category, tP.description AS Problem,t.open,DATEDIFF( now(), t.open),tC.id FROM ticket t LEFT JOIN location l ON l.id = t.location"
                                            + " LEFT JOIN customer c ON c.id = l.customer LEFT JOIN ticketCategory tC ON tC.id=t.category "
                                            + " LEFT JOIN ticketProblem tP ON tP.id=t.problem WHERE  t.close is NULL AND t.assignedTo = ?;";
        
        
        StringBuilder OpenTicketHeader          = new StringBuilder();
        StringBuilder OpenTicketFotter          = new StringBuilder();

        OpenTicketHeader.append("<tr align=center valign=middle><td colspan=3 ><strong><span style=text-decoration: underline>Open Tickets</span> </strong></td></tr><tr><td colspan=3>&nbsp;</td></tr>");
        OpenTicketHeader.append("<tr style=font-size:small height=15><td style=width=30%><strong>Ticket</strong></td><td style=width=30%><strong>location</strong></td><td style=width=20%><strong>Open Date</strong></td></tr>");
        
        OpenTicketFotter.append("<tr align=justify><td colspan=4>Please login to <a href='http://bevboss.net/'>bevBoss</a> to access the ticket for more information.</td></tr>");
        OpenTicketFotter.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
        OpenTicketFotter.append("<tr align=justify><td colspan=4>Thank You,</td></tr>");
        OpenTicketFotter.append("<tr align=justify><td colspan=4>US Beverage Net Support</td></tr>");
        OpenTicketFotter.append("<tr align=center valign=middle><td height=35 colspan=4>&nbsp;</td></tr>");
        OpenTicketFotter.append("<tr align=justify><td colspan=4><strong>This email was automatically generated; please do not reply.</strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
        
        Integer ticketArray[]                   = {1,2,3,8,9,14,16,18,21,23};
        

        try {
            String subjectLine              = "Ticket Escalationt from US Beverage NET, Inc.";
            HashSet<Integer> ticketSet= new HashSet<Integer>(Arrays.asList(ticketArray));
            
            
            stmt                            = transconn.prepareStatement(selectAssignTo);
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                
                String email                = rs.getString(3);
                String subjectLine1         = "Open Tickets for: Date-"+rs.getString(4);
               
                StringBuilder ticketInformation
                                            = new StringBuilder(); 
                StringBuilder tempOpenTicket        
                                            = new StringBuilder();
                stmt                        = transconn.prepareStatement(checkOpenTickets);
                stmt.setInt(1,rs.getInt(2));
                ticketRs                    = stmt.executeQuery();
                while (ticketRs.next()) {
                    String locationName     = ticketRs.getString(1);
                    String owner            = ticketRs.getString(2);
                    String notes            = ticketRs.getString(3);
                    String cateroryString   = ticketRs.getString(4);
                    String problemString    = ticketRs.getString(5);
                    String date             = ticketRs.getString(6);
                    int days                = ticketRs.getInt(7);
                    int category            = ticketRs.getInt(8);
                    
                    tempOpenTicket.append("<tr style=font-size:x-small height=15><td>");
                    tempOpenTicket.append(HandlerUtils.nullToEmpty(cateroryString)); // Ticket Category
                    tempOpenTicket.append("</td><td>");
                    tempOpenTicket.append(HandlerUtils.nullToEmpty(locationName)); // location
                    tempOpenTicket.append("</td><td>");
                    tempOpenTicket.append(HandlerUtils.nullToEmpty(date));  // date
                    tempOpenTicket.append("</td><td>");
                        
                    if(days >=14&&ticketSet.contains(category)){
                          StringBuilder ticketHighLevel
                                            = new StringBuilder();
                        ticketHighLevel.append("<tr align=justify><td colspan=4>A Ticket for  <strong>");
                        ticketHighLevel.append(HandlerUtils.nullToEmpty(locationName));
                        ticketHighLevel.append("</strong>");
                        ticketHighLevel.append(" is pending closure.   By ");
                        ticketHighLevel.append(HandlerUtils.nullToEmpty(owner));
                        ticketHighLevel.append("It has been open for more than "+days+"Days.</td></tr>");
                        ticketHighLevel.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
                        ticketHighLevel.append("<tr align=justify><td>Category: </td><td colspan=3>");
                        ticketHighLevel.append(HandlerUtils.nullToEmpty(cateroryString));
                        ticketHighLevel.append("</td></tr>");
                        ticketHighLevel.append("<tr align=justify><td>Problem: </td><td colspan=3>");
                        ticketHighLevel.append(HandlerUtils.nullToEmpty(problemString));
                        ticketHighLevel.append("</td></tr>");
                        ticketHighLevel.append("<tr align=justify><td>Open Date: </td><td colspan=3>");
                        ticketHighLevel.append(HandlerUtils.nullToEmpty(date));
                        ticketHighLevel.append("</td></tr>");
                        ticketHighLevel.append("<tr align=justify><td>Notes: </td><td colspan=3>");
                        ticketHighLevel.append(HandlerUtils.nullToEmpty(notes));
                        ticketHighLevel.append("</td></tr>");
                        ticketHighLevel.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
                        ticketHighLevel.append("");
                        ticketHighLevel.append(OpenTicketFotter);
                        sendMail("USBN Ticket Escalation", "tech@usbeveragenet.com", email, "support@usbeveragenet.com", subjectLine, "sendMail", ticketHighLevel, false);
                        
                    }
                    
                }
                ticketInformation.append(OpenTicketHeader);
                ticketInformation.append("");
                ticketInformation.append(tempOpenTicket);
                ticketInformation.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
                ticketInformation.append(OpenTicketFotter);
                
                
                sendMail("USBN Open Tickets", "tech@usbeveragenet.com", email, "support@usbeveragenet.com", subjectLine1, "sendMail", ticketInformation, false);
                
            }
            
        } catch (SQLException sqle) {
            logger.dbError("Database error: "+sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(ticketRs);
            close(rs);
            close(stmt);
        }
    }
    
    private void checkProductVersion(Element toHandle, Element toAppend) throws HandlerException {
        
        String version                      = HandlerUtils.getRequiredString(toHandle, "productVersion");
        PreparedStatement stmt              = null;
        ResultSet rs                        = null,rsDetail = null;
        String changeLogVersion             = "SELECT l.type,l.product,p.name,p.approved from productChangeLog l"
                                            + " LEFT JOIN product p ON p.id=l.product "
                                            + " WHERE  date > ? AND p.name <> 'null' order by l.id,date;";
        String selectBrewStyle              = "SELECT pS.id,pS.name,pS.productSetType FROM productSetMap pSM LEFT JOIN productSet pS  ON pS.id = pSM.productSet"
                                            + " WHERE  pSM.product=? AND pS.productSetType IN(7,9);";
        String breweryLog                   = "SELECT l.type,l.product,p.name ,l.productType from productChangeLog l"
                                            + "  LEFT JOIN productSet p ON p.id=l.product  WHERE  date > ? AND p.name <> 'null' AND l.productType > 1 order by l.id,date;";

        
        try {
             stmt = transconn.prepareStatement(changeLogVersion);
             stmt.setString(1, version);
             rs = stmt.executeQuery();
             while(rs.next()) {
                Element productEl           = toAppend.addElement("changeProduct");
                productEl.addElement("type").addText(String.valueOf(rs.getInt(1)));
                productEl.addElement("id").addText(String.valueOf(rs.getInt(2)));
                productEl.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                productEl.addElement("isApprove").addText(String.valueOf(rs.getInt(4)));
                stmt = transconn.prepareStatement(selectBrewStyle); 
                stmt.setInt(1,rs.getInt(2));
                rsDetail = stmt.executeQuery();
                while(rsDetail.next()) {
                    int pSType              = rsDetail.getInt(3);
                    if(pSType==7){
                        productEl.addElement("breweryId").addText(String.valueOf(rsDetail.getInt(1)));
                        productEl.addElement("breweryName").addText(HandlerUtils.nullToEmpty(rsDetail.getString(2)));
                    } else if(pSType == 9) {
                        productEl.addElement("styleId").addText(String.valueOf(rsDetail.getInt(1)));
                        productEl.addElement("styleName").addText(HandlerUtils.nullToEmpty(rsDetail.getString(2)));
                    }
                }
            }
             
             
             stmt = transconn.prepareStatement(breweryLog);
             stmt.setString(1, version);
             rs = stmt.executeQuery();
             while(rs.next()) {
                int prodtype                = rs.getInt(4);                
                if(prodtype==7){
                    Element productEl       = toAppend.addElement("changeBrewery");
                    productEl.addElement("type").addText(String.valueOf(rs.getInt(1)));
                    productEl.addElement("breweryId").addText(String.valueOf(rs.getInt(2)));
                    productEl.addElement("breweryName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));   
                    logger.debug("Type:"+rs.getInt(1));
                } else if (prodtype==9){
                    Element productEl       = toAppend.addElement("changeStyle");
                    productEl.addElement("type").addText(String.valueOf(rs.getInt(1)));
                    productEl.addElement("styleId").addText(String.valueOf(rs.getInt(2)));
                    productEl.addElement("styleName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
             }
            }
            stmt = transconn.prepareStatement("SELECT max(date) from productChangeLog");
            rs = stmt.executeQuery();
            if(rs.next()) {
                toAppend.addElement("productVersion").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
        
        
        
    }
    
    
    private void getUnApprovedProducts(Element toHandle, Element toAppend) throws HandlerException {
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        String selectMap                    = "SELECT pSM.product, pS.name FROM productSetMap pSM LEFT JOIN productSet pS ON pS.id = pSM.productSet " +
                                            " WHERE pS.productSetType = ?;";
        String selectProduct                = " SELECT p.id, p.name, p.category, p.segment, p.isActive, pD.boardName, pD.abv, pD.category, pD.origin,  pD.seasonality " +
                                            " FROM product p LEFT JOIN productDescription pD ON pD.product = p.id WHERE p.approved = 0 ORDER BY p.name;";
        String selectProductSet             = " SELECT pS.id, pS.name,(SELECT COUNT(product) FROM productSetMap WHERE productSet=pS.id),pS.productSetType  FROM productSet pS WHERE  pS.approved = 0 ORDER BY pS.name;";
        
        try {

            HashMap<Integer, String> breweryMap
                                            = new HashMap<Integer, String>();
            HashMap<Integer, String> styleMap
                                            = new HashMap<Integer, String>();

            stmt                            = transconn.prepareStatement(selectMap);
            stmt.setInt(1, 7);
            rs                              = stmt.executeQuery();
            while(rs.next()){
                breweryMap.put(rs.getInt(1), rs.getString(2));
            }

            stmt                            = transconn.prepareStatement(selectMap);
            stmt.setInt(1, 9);
            rs                              = stmt.executeQuery();
            while(rs.next()){
                styleMap.put(rs.getInt(1), rs.getString(2));
            }

            stmt                            = transconn.prepareStatement(selectProduct);            
            rs                              = stmt.executeQuery();
            while(rs.next()){
                int colCount                    = 1;
                Element ProductE1               = toAppend.addElement("product");
                ProductE1.addElement("productId").addText(String.valueOf(rs.getInt(colCount++)));
                ProductE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));            
                ProductE1.addElement("category").addText(String.valueOf(rs.getInt(colCount++)));
                ProductE1.addElement("segment").addText(String.valueOf(rs.getInt(colCount++)));
                ProductE1.addElement("isActive").addText(String.valueOf(rs.getBoolean(colCount++)));
                ProductE1.addElement("boardName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                ProductE1.addElement("abv").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                ProductE1.addElement("bbtvCategory").addText(String.valueOf(rs.getInt(colCount++)));
                ProductE1.addElement("origin").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));            
                ProductE1.addElement("seasonality").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                ProductE1.addElement("brewery").addText(HandlerUtils.nullToEmpty(breweryMap.get(rs.getInt(1))));
                ProductE1.addElement("style").addText(HandlerUtils.nullToEmpty(styleMap.get(rs.getInt(1))));
            }
            
            stmt                            = transconn.prepareStatement(selectProductSet);            
            rs                              = stmt.executeQuery();
            while(rs.next()){
                int colCount                    = 1;
                Element ProductE1               = toAppend.addElement("productSet");
                ProductE1.addElement("id").addText(String.valueOf(rs.getInt(colCount++)));
                ProductE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));                            
                ProductE1.addElement("count").addText(String.valueOf(rs.getInt(colCount++)));
                ProductE1.addElement("productSetType").addText(String.valueOf(rs.getInt(colCount++)));
            }
        
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }
    
    
    
      public void sendBrewLogoRequestEmail(String brewName,int id,String type) throws HandlerException {

        
        StringBuilder noBBTVList            = new StringBuilder();

        noBBTVList.append("<tr align=justify><td colspan=4>New Brewery:"+id+"-"+brewName+"   "+type);        
        noBBTVList.append(" Find logo and update </td></tr>");
        
        noBBTVList.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
        noBBTVList.append("<tr align=justify><td colspan=4>Thank You,</td></tr>");
        noBBTVList.append("<tr align=justify><td colspan=4>US Beverage Net Support</td></tr>");
        noBBTVList.append("<tr align=center valign=middle><td height=35 colspan=4>&nbsp;</td></tr>");
        noBBTVList.append("<tr align=justify><td colspan=4><strong>This email was automatically generated; please do not reply.</strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
        
        sendMail("BrewLogo Request", "suba", "javadeveloper@usbeveragenet.com", "support@usbeveragenet.com", "Logo Request", "sendMail",noBBTVList, false);

       
    }
    
    private void getInventoryPrices(Element toHandle, Element toAppend) throws HandlerException {
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");        
        String selectInventory              = "SELECT i.id, i.product, p.name FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product"
                                            + " WHERE i.location = ? and p.pType = 1 AND i.isactive =1 ORDER BY p.name;";
        String selectPrice                  = "Select inventory,value,id,size FROM inventoryPrices  WHERE inventory = ?  order by value";
        String selectMaxColumn              = "SELECT count(inventory) AS c FROM inventoryPrices iP LEFT JOIN inventory i ON i.id=iP.inventory"
                                            + " WHERE i.location=? GROUP BY iP.inventory ORDER by c DESC LIMIT 1;";

        PreparedStatement stmt              = null;
        ResultSet rs                        = null,rsPrice = null;

        try {
            
            stmt = transconn.prepareStatement(selectMaxColumn);
            stmt.setInt(1,location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("priceCount").addText(String.valueOf(rs.getInt(1)));
            } else {
                toAppend.addElement("priceCount").addText(String.valueOf(0));
            } 
            
            stmt = transconn.prepareStatement(selectInventory);
            stmt.setInt(1,location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element inventory = toAppend.addElement("inventory");
                inventory.addElement("inventoryId").addText(String.valueOf(rs.getInt(1)));   
                inventory.addElement("productId").addText(String.valueOf(rs.getInt(2)));   
                inventory.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));                   
                stmt = transconn.prepareStatement(selectPrice);
                stmt.setInt(1,rs.getInt(1));
                rsPrice                     = stmt.executeQuery();
                while (rsPrice.next()) {
                    Element price = inventory.addElement("inventoryPrices");
                   // price.addElement("inventory").addText(String.valueOf(rsPrice.getInt(1)));                
                    price.addElement("value").addText(String.valueOf(rsPrice.getDouble(2)));
                    price.addElement("priceId").addText(String.valueOf(rsPrice.getInt(3)));
                    price.addElement("size").addText(String.valueOf(rsPrice.getInt(4)));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getInventoryPrices: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rsPrice);
            close(rs);
            close(stmt);
        }
    }


    /**  Return a list of all product categories
     */
    private void sendNotificationToUser(Element toHandle, Element toAppend) throws HandlerException {

        String selectUsers                  = "SELECT DISTINCT email FROM user WHERE id IN (SELECT user FROM emailReport)";
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;

        try {
            
            StringBuilder notificationEmail = new StringBuilder();
            notificationEmail.append("<tr align=justify><td colspan=4> <strong>ATTENTION: </strong>");
            notificationEmail.append(" bevManager Users<br /><br /></td></tr>");
            notificationEmail.append("<tr align=justify><td colspan=4>");
            notificationEmail.append("bevManager platform is now available on a free mobile app supported by Android and Apple operating systems.<br /></td></tr>");
            notificationEmail.append("<tr align=center valign=middle><td height=20 colspan=2>&nbsp;</td>");
            notificationEmail.append("<td colspan=2 rowspan=6><img src=\"http://bevmanager.net/USBN.BevManager.UI/Images/Login/IPhone-black-variance.png\" /></td></tr>");
            notificationEmail.append("<tr align=justify><td colspan=2><u><strong>Features</strong></u></td></tr>");
            notificationEmail.append("<tr align=justify><td colspan=2><ul>");
            notificationEmail.append("<li>Access Store-Specific Draft Variances and Brand Performance </li>");
            notificationEmail.append("<li>Drill-Down on Brand Variance, By The Hour </li>");
            notificationEmail.append("<li>Change Brands On-the-Floor, In Real-Time </li>");
            notificationEmail.append("<li>Check Current Cooler Temperatures </li>");
            notificationEmail.append("<li>Manage Line Cleaning Mode (switch Line Cleaning on/off) </li>");
            notificationEmail.append("<li>Verify Positive Connectivity of Poured and Sold Information </li>");
            notificationEmail.append("</ul></td></tr>");
            notificationEmail.append("<tr align=center valign=middle><td height=20 colspan=2>&nbsp;</td></tr>");
            notificationEmail.append("<tr align=justify><td colspan=2><u><strong>Instructions</strong></u></td></tr>");
            notificationEmail.append("<tr align=justify><td colspan=2><ul>");
            notificationEmail.append("<li>Access Google Play or App Store & Search 'bevmanager'</li>");
            notificationEmail.append("<li>Download bevManager Mobile App for Free</li>");
            notificationEmail.append("<li>Enter existing user credentials</li>");
            notificationEmail.append("</ul></td></tr>");
            notificationEmail.append("<tr align=center valign=middle><td height=20 colspan=3>&nbsp;</td></tr>");
            notificationEmail.append("<tr align=justify><td colspan=4>Based upon initial feedback from a controlled test group, ");
            notificationEmail.append("the mobile app will allow for much quicker and easier access to BevNet data and key functions to maintain the system (line assignments etc.,). We look forward to your feedback.</td></tr>");
            notificationEmail.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
            notificationEmail.append("<tr align=left><td colspan=2><strong>US Beverage Net, Inc.</strong></td></tr>");

            String subjectLine              = "bevManager Mobile App: Release Version 1.0";

            stmt                            = transconn.prepareStatement(selectUsers);
            rs                              = stmt.executeQuery();
            while (rs.next()) {
                sendMail("", "tech@usbeveragenet.com", rs.getString(1), "", subjectLine, "sendMail", notificationEmail, false);
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in sendNotificationToUser: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    
    
    private void sendUnApprovedProductsEmail(Element toHandle, Element toAppend) throws HandlerException {
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;       
        String selectProduct                = " SELECT p.id, p.name  FROM product p WHERE p.approved = 0 ORDER BY p.name;";
        String selectProductSet             = " SELECT pS.id, pS.name   FROM productSet pS WHERE  pS.approved = 0 ORDER BY pS.name;";
        
        try {
             StringBuilder productList            = new StringBuilder();

        productList.append("<tr><td><table border=\"1\"><tr><th colspan=\"2\" scope=\"col\">Unapproved Products & Brewery</th> </tr> <td valign=\"top\"><table border=1 style='border: thin solid Black;'>");
        productList.append(" <tr> <th colspan=\"2\" scope=\"col\"> Products</th> </tr> <tr><td width=\"15%\">id </td><td width=\"85%\">Name</td> </tr>");
        
        stmt                            = transconn.prepareStatement(selectProduct);            
            rs                              = stmt.executeQuery();
            while(rs.next()){
                int colCount                    = 1;
                productList.append("<tr> <td>"+String.valueOf(rs.getInt(colCount++))+"</td><td><p>"+rs.getString(colCount++)+"</p></td> </tr>");
                
                
            }
              productList.append("</table></td>");
              
              productList.append("<td valign=\"top\"><table border=1 style='border: thin solid Black;'>");
        productList.append(" <tr> <th colspan=\"2\" scope=\"col\">  Brewery</th> </tr> <tr><td width=\"15%\">id </td><td width=\"85%\">Name</td> </tr>");
        
            
            stmt                            = transconn.prepareStatement(selectProductSet);            
            rs                              = stmt.executeQuery();
            while(rs.next()){
                int colCount                    = 1;
                productList.append("<tr> <td>"+String.valueOf(rs.getInt(colCount++))+"</td><td><p>"+rs.getString(colCount++)+"</p></td> </tr>");
            }
            productList.append("</table></td></table></td></tr>");
             
             sendMail(" ", "sundar", "sravindran@usbeveragenet.com", "support@usbeveragenet.com", "Unapproved products", "sendMail",productList, false);
             sendMail(" ", "Suba", "javadeveloper@usbeveragenet.com", "support@usbeveragenet.com", "Unapproved products", "sendMail",productList, false);
             sendMail(" ", "Geoffrey Aumiller", "gaumiller@usbeveragenet.com", "support@usbeveragenet.com", "Unapproved products", "sendMail",productList, false);
        
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }
    
     public void addMobileUserHistory(int userId,String action,int locationId, String message,int mobileId)throws HandlerException {
        String checkAction                  = " SELECT id FROM task WHERE abbrev=? LIMIT 1";
        String insertFullLog                = " INSERT INTO userHistoryMobile (user,task,description,location,mobile,timestamp) " 
                                            + " VALUES (?,?,?,?,?,now()) ";
         PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                
                // check that the action exists (has a task id)
                int taskId = 0;
                stmt = transconn.prepareStatement(checkAction);
                stmt.setString(1, action);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    taskId = rs.getInt(1);
                } else {
                    // if the task doesn't exist, we'll insert it as task 0 and
                    // prepend the name of the supplied task to the message;
                    message = "UNKNOWN ("+action+") "+message;
                }
                
                stmt = transconn.prepareStatement(insertFullLog);
                stmt.setInt(1,userId);
                stmt.setInt(2,taskId);
                stmt.setString(3, message);
                stmt.setInt(4,locationId);                
                stmt.setInt(5,mobileId);
                stmt.executeUpdate();
            
            } catch (SQLException sqle) {
            logger.dbError("Database error in getProductSet: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
        
    }
     
     
     private void getForgotUsername(Element toHandle, Element toAppend) throws HandlerException {        
        
        String email                        = HandlerUtils.getRequiredString(toHandle, "email");
      
        
        String selectUsername               = "SELECT username,name FROM user  WHERE email = ?;";
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        try {
            stmt                            = transconn.prepareStatement(selectUsername); 
            stmt.setString(1, email);
            rs                              = stmt.executeQuery();   
            if (rs.next()) {
              String username               = rs.getString(1);
              String name                   = rs.getString(2);
              
              StringBuilder forgetUser      = new StringBuilder();
              forgetUser.append("<tr align=justify><td colspan=4>Your BevManager Username: "+username+"</td></tr>");
              forgetUser.append("<tr align=justify><td colspan=4>Account:"+email+"</td></tr>");
              forgetUser.append("<tr align=center valign=middle><td height=20 colspan=4>&nbsp;</td></tr>");
              forgetUser.append("<tr align=justify><td colspan=4>Thank You,</td></tr>");
              forgetUser.append("<tr align=justify><td colspan=4>US Beverage Net Support</td></tr>");
              forgetUser.append("<tr align=center valign=middle><td height=35 colspan=4>&nbsp;</td></tr>");
              forgetUser.append("<tr align=justify><td colspan=4><strong>This email was automatically generated; please do not reply.</strong></td></tr><tr><td colspan=4>&nbsp;</td></tr>");
              
              sendMail("Your BevManager Username", name,email, "support@usbeveragenet.com", "BevManager Username", "sendMail",forgetUser, false);

                
            } else {
                toAppend.addElement("message").addText("Invalid emailId!");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getErrorLogs: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
     
     
     private void getPurchaseSetting(Element toHandle, Element toAppend) throws HandlerException {
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "location");
        int supplier                        = HandlerUtils.getOptionalInteger(toHandle, "supplier");
        int day                             = HandlerUtils.getOptionalInteger(toHandle, "day");

        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        String selectProducts               = "SELECT i.product, p.name FROM product p LEFT JOIN inventory i ON i.product = p.id"
                                            + " LEFT JOIN supplier sup ON sup.id=  i.supplier WHERE  i.location =? AND sup.id=? AND i.isActive=1  ORDER by p.name";
        String getPurchase                  = " SELECT pS.id, pS.location,pS.supplier, pS.day,(SELECT group_concat(product) FROM purchaseSettingDetail WHERE purchaseSetting =  pS.id)  FROM purchaseSetting pS"
                                            + " WHERE pS.location=? ";
        if (supplier > 0) {
            getPurchase                     +=" AND pS.supplier= ? ";
        }
        if (day > 0) {
            getPurchase                     +=" AND pS.day= ? ";
        }

        getPurchase                         +=" ORDER BY pS.date";
        try {
            int param                       = 1;
            stmt = transconn.prepareStatement(getPurchase);
            stmt.setInt(param++, location);
            if (supplier > 0) {
                stmt.setInt(param++, supplier);
            }
             if (day > 0) {
                stmt.setInt(param++, day);
            }

            rs = stmt.executeQuery();

            while (rs.next()) {
                Element pur                 = toAppend.addElement("purchaseSetting");
                pur.addElement("id").addText(String.valueOf(rs.getInt(1)));
                pur.addElement("location").addText(String.valueOf(rs.getInt(2)));
                pur.addElement("supplierId").addText(String.valueOf(rs.getInt(3)));
                pur.addElement("day").addText(String.valueOf(rs.getInt(4)));
                pur.addElement("products").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
            }
            
            if (supplier > 0) {
                stmt                        = transconn.prepareStatement(selectProducts);
                stmt.setInt(1, location);            
                stmt.setInt(2, supplier);
                rs = stmt.executeQuery();
                
                while (rs.next()) {
                    Element pur             = toAppend.addElement("product");
                    pur.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                    pur.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }
     
     
      private void getCurrentProducts(Element toHandle, Element toAppend) throws HandlerException {
        
        int callerId                        = getCallerId(toHandle);
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
      
        
        String selectProducts               = "SELECT DISTINCT i.product,p.name,pS.id,pS.name FROM inventory i LEFT JOIN product p ON p.id=i.product LEFT JOIN productSetMap pSM ON pSM.product=p.id"
                                            + " LEFT JOIN productSet pS ON pS.id=pSM.productSet"
                                            + "  WHERE i.location=? AND pS.productSetType=7 ORDER by p.name;";
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        try {
            stmt                        = transconn.prepareStatement(selectProducts);  
            stmt.setInt(1,location);
            rs                          = stmt.executeQuery();   
            while (rs.next()) {               
                Element eMsg            = toAppend.addElement("locationProduct");
                eMsg.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                eMsg.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                eMsg.addElement("breweryId").addText(String.valueOf(rs.getInt(3)));
                eMsg.addElement("breweryName").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getErrorLogs: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
      
      
      private void getInsiderPass(Element toHandle, Element toAppend) throws HandlerException {
        
        int callerId                        = getCallerId(toHandle);
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
      
        
        String selectPasses                 = "SELECT id,brewery,product,rewardText,  startTime, endTime , title, file FROM  insiderPass"
                                            + " WHERE location= ? ORDER BY id DESC;";
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        try {
            stmt                        = transconn.prepareStatement(selectPasses);  
            stmt.setInt(1,location);
            rs                          = stmt.executeQuery();   
            while (rs.next()) {   
                Element rewardEl    = toAppend.addElement("insiderPass");
                rewardEl.addElement("id").addText(String.valueOf(rs.getInt(1)));                
                rewardEl.addElement("brewery").addText(String.valueOf(rs.getInt(2)));
                rewardEl.addElement("product").addText(String.valueOf(rs.getInt(3)));
                rewardEl.addElement("rewardText").addText(HandlerUtils.nullToEmpty(rs.getString(4)));                
                rewardEl.addElement("startTime").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                rewardEl.addElement("endTime").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
                rewardEl.addElement("title").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
                rewardEl.addElement("file").addText(HandlerUtils.nullToEmpty(rs.getString(8)));
                
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getErrorLogs: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
      
      
      private void getBBTVAutoFeed(Element toHandle, Element toAppend) throws HandlerException {
        
        int callerId                        = getCallerId(toHandle);
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
      
        
        String selectPasses                 = "SELECT newBeer,localBeer,comingSoon FROM bbtvAutoFeed WHERE location = ?;";
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        try {
            stmt                        = transconn.prepareStatement(selectPasses);  
            stmt.setInt(1,location);
            rs                          = stmt.executeQuery();   
            if (rs.next()) {   
                Element feedEl    = toAppend.addElement("autoFeed");
                feedEl.addElement("newBeer").addText(String.valueOf(rs.getInt(1)));                
                feedEl.addElement("localBeer").addText(String.valueOf(rs.getInt(2)));                
                feedEl.addElement("comingSoon").addText(String.valueOf(rs.getInt(3)));                     
            } else {
                stmt                        = transconn.prepareStatement("INSERT INTO bbtvAutoFeed(location) Values( ?); "); 
                stmt.setInt(1,location);
                stmt.executeUpdate();
                Element feedEl    = toAppend.addElement("autoFeed");
                feedEl.addElement("newBeer").addText(String.valueOf(0));                
                feedEl.addElement("localBeer").addText(String.valueOf(0));                
                feedEl.addElement("comingSoon").addText(String.valueOf(0));
                
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getErrorLogs: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
      
      
      private void getBBTVMenuTemplate(Element toHandle, Element toAppend) throws HandlerException {
        
        int callerId                        = getCallerId(toHandle);
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
      
        
        String selectTemplate               = "SELECT id,name,file,description FROM bbtvMenuTemplate;";
        String currentTemplate              = "SELECT template FROM  locationBeerBoardMap WHERE location=?;";
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        try {
            stmt                        = transconn.prepareStatement(selectTemplate);
            
            rs                          = stmt.executeQuery();   
            while (rs.next()) {   
                Element templateEl    = toAppend.addElement("menuTemplate");
                templateEl.addElement("id").addText(String.valueOf(rs.getInt(1)));                
                templateEl.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));                
                templateEl.addElement("file").addText(HandlerUtils.nullToEmpty(rs.getString(3)));                  
                templateEl.addElement("description").addText(HandlerUtils.nullToEmpty(rs.getString(4)));                    
            } 
            
            stmt                        = transconn.prepareStatement(currentTemplate);
            stmt.setInt(1, location);
            rs                          = stmt.executeQuery();   
            if (rs.next()) {   
                toAppend.addElement("currentTemplate").addText(String.valueOf(rs.getInt(1)));
            } 
        } catch (SQLException sqle) {
            logger.dbError("Database error in getErrorLogs: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
      
      
      private void getCustomBeerAndStyle(Element toHandle, Element toAppend) throws HandlerException {
        
        int callerId                        = getCallerId(toHandle);
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
      
        
        String selectBeerName               = "SELECT DISTINCT i.product,p.name,( SELECT name FROM customBeerName WHERE location =i.location AND product = i.product )  FROM inventory i LEFT JOIN product p ON p.id=i.product"
                                            + " WHERE i.location=? AND p.id<>'null' ORDER by p.name;";
        String selectstyleName              = "SELECT DISTINCT pS.id,pS.name, ( SELECT name FROM customBeerName WHERE location =i.location AND productSet = pS.id ),sL.logo FROM inventory i LEFT JOIN product p ON p.id=i.product LEFT JOIN productSetMap pSM ON pSM.product=p.id"
                                            + " LEFT JOIN productSet pS ON pS.id=pSM.productSet LEFT JOIN styleLogo sL ON sL.style=pS.name WHERE i.location=? AND pS.productSetType=9 ORDER by pS.name;";
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null,rsDetails = null;
        try {
            stmt                            = transconn.prepareStatement(selectBeerName);
            stmt.setInt(1, location);            
            rs                              = stmt.executeQuery();   
            while (rs.next()) {   
                Element beerEl              = toAppend.addElement("customBeer");                
                beerEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));                
                beerEl.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));                
                beerEl.addElement("customName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));                  
            } 
            
            
            stmt                            = transconn.prepareStatement(selectstyleName);
            stmt.setInt(1, location);            
            rs                              = stmt.executeQuery();   
            while (rs.next()) {   
                Element styleEl             = toAppend.addElement("customStyle");                
                styleEl.addElement("productSet").addText(String.valueOf(rs.getInt(1)));                
                styleEl.addElement("styleName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));                
                styleEl.addElement("customName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));                  
                styleEl.addElement("logo").addText("http://beerboard.tv/USBN.BeerBoard.UI/Images/glass/"+HandlerUtils.nullToString(rs.getString(4),"American%20Ale")+".png");                  
            } 
        } catch (SQLException sqle) {
            logger.dbError("Database error in getErrorLogs: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
      
       private void getBBTVMenuFormat(Element toHandle, Element toAppend) throws HandlerException {
        
        int callerId                        = getCallerId(toHandle);
        int location                        = HandlerUtils.getRequiredInteger(toHandle, "locationId");
      
        
        String selectformat                 = "SELECT row,property FROM bbtvMenuFormat WHERE location = ?;";
        String insertFormat                 = "INSERT INTO bbtvMenuFormat(row,property,location) VALUES(1,1,?),(2,3,?),(3,4,?);";
        
        String menuProprty[]                = {"Beer Name","Brewery Name","Style and Abv","Price"};
        
        PreparedStatement stmt              = null;
        ResultSet rs                        = null;
        try {
            for(int i=0;i<menuProprty.length;i++){
                Element beerEl              = toAppend.addElement("menuProperty");                
                int property                = i+1;                
                beerEl.addElement("property").addText(String.valueOf(property));
                beerEl.addElement("name").addText(menuProprty[i]);
                
            }
            boolean avail                   = false;
            stmt                            = transconn.prepareStatement(selectformat);
            stmt.setInt(1, location);            
            rs                              = stmt.executeQuery();   
            while (rs.next()) {  
                avail                       = true;
                Element beerEl              = toAppend.addElement("menuFormat");                
                beerEl.addElement("row").addText(String.valueOf(rs.getInt(1)));                
                beerEl.addElement("property").addText(String.valueOf(rs.getInt(2)));                
            } 
            
            if(!avail){
                stmt                            = transconn.prepareStatement(insertFormat);
                stmt.setInt(1, location);            
                stmt.setInt(2, location);            
                stmt.setInt(3, location);            
                stmt.executeUpdate();
                
                stmt                            = transconn.prepareStatement(selectformat);
                stmt.setInt(1, location);            
                rs                              = stmt.executeQuery();   
                while (rs.next()) {  
                Element beerEl              = toAppend.addElement("menuFormat");                
                beerEl.addElement("row").addText(String.valueOf(rs.getInt(1)));                
                beerEl.addElement("property").addText(String.valueOf(rs.getInt(2)));                
            } 
            }
            
        } catch (SQLException sqle) {
            logger.dbError("Database error in getErrorLogs: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
     
}
