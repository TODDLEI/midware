    /*
 * SQLGetHandler.java
 *
 * Created on August 25, 2005, 10:33 AM
 *
 */
package net.terakeet.soapware.handlers;

import net.terakeet.soapware.*;
import net.terakeet.soapware.handlers.auper.*;
import net.terakeet.soapware.handlers.report.ProductMap;
import net.terakeet.soapware.security.*;
import net.terakeet.usbn.WebPermission;
import net.terakeet.util.MidwareLogger;
import net.terakeet.util.TemplatedMessage;
import net.terakeet.util.MailException;
import net.terakeet.soapware.handlers.report.*;
import org.apache.log4j.Logger;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import org.dom4j.Element;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.CallableStatement;
import java.lang.String;
import java.util.Iterator;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Properties;
import java.util.*;
//import javax.mail.*;
//import javax.mail.internet.MimeMessage;
//import javax.mail.internet.InternetAddress;
public class SQLGetHandler implements Handler {

    private MidwareLogger logger;
    private static final String connName = "auper";
    private RegisteredConnection conn;
    private SecureSession ss;
    private RegionProductMap regionProductMap;
    private RegionExclusionMap regionExclusionMap;
    private ParentLevelMap parentLevelMap;
    private ChildLevelMap childLevelMap;

    /**
     * Creates a new instance of SQLGetHandler
     */
    public SQLGetHandler() throws HandlerException {
        HandlerUtils.initializeClientKeyManager();
        logger = new MidwareLogger(SQLGetHandler.class.getName());
        conn = null;
    }

    public void handle(Element toHandle, Element toAppend) throws HandlerException {

        String function = toHandle.getName();
        String responseNamespace = (String) SOAPMessage.getURIMap().get("tkmsg");

        String clientKey = HandlerUtils.getOptionalString(toHandle, "clientKey");
        ss = ClientKeyManager.getSession(clientKey);

        logger = new MidwareLogger(SQLGetHandler.class.getName(), function);
        logger.debug("SQLGetHandler processing method: " + function);
        logger.xml("request: " + toHandle.asXML());

        conn = DatabaseConnectionManager.getNewConnection(connName,
                function + " (SQLGetHandler)");

        try {
            // All methods require an admin client key
            if (ss.getLocation() == 0 && ss.getClientId() == 1 && ss.getSecurityLevel().canAdmin()) {
                if ("getLocations".equals(function)) {
                    getLocations(toHandle, responseFor(function, toAppend));
                } else if ("getInventory".equals(function)) {
                    getInventory(toHandle, responseFor(function, toAppend));
                } else if ("getProducts".equals(function)) {
                    getProducts(toHandle, responseFor(function, toAppend));
                } else if ("getBeverages".equals(function)) {
                    getBeverages(toHandle, responseFor(function, toAppend));
                } else if ("getLastReading".equals(function)) {
                    getLastReading(toHandle, responseFor(function, toAppend));
                } else if ("getGatewayInfo".equals(function)) {
                    getGatewayInfo(toHandle, responseFor(function, toAppend));
                } else if ("getBeverageSizes".equals(function)) {
                    getBeverageSizes(toHandle, responseFor(function, toAppend));
                } else if ("getCurrentLines".equals(function)) {
                    getCurrentLines(toHandle, responseFor(function, toAppend));
                } else if ("getCustomers".equals(function)) {
                    getCustomers(toHandle, responseFor(function, toAppend));
                } else if ("getCategory".equals(function)) {
                    getCategory(toHandle, responseFor(function, toAppend));
                }
                if ("getBrix".equals(function)) {
                    getBrix(toHandle, responseFor(function, toAppend));
                } else if ("getLine".equals(function)) {
                    getLine(toHandle, responseFor(function, toAppend));
                } else if ("getSystems".equals(function)) {
                    getSystems(toHandle, responseFor(function, toAppend));
                } else if ("getCountyPoints".equals(function)) {
                    getCountyPoints(toHandle, responseFor(function, toAppend));
                } else if ("getCounties".equals(function)) {
                    getCounties(toHandle, responseFor(function, toAppend));
                } else if ("getRegions".equals(function)) {
                    getRegions(toHandle, responseFor(function, toAppend));
                } else if ("getTapShare".equals(function)) {
                    getTapShare(toHandle, responseFor(function, toAppend));
                } else if ("getTapCount".equals(function)) {
                    getTapCount(toHandle, responseFor(function, toAppend));
                } else if ("getLocationCount".equals(function)) {
                    getLocationCount(toHandle, responseFor(function, toAppend));
                } else if ("checkEventTime".equals(function)) {
                    checkEventTime(toHandle, responseFor(function, toAppend));
                } else if ("getAfterHours".equals(function)) {
                    getAfterHours(toHandle, responseFor(function, toAppend));
                } else if ("authBevSyncUser".equals(function)) {
                    authBevSyncUser(toHandle, responseFor(function, toAppend));
                } else if ("authSupplierUser".equals(function)) {
                    authSupplierUser(toHandle, responseFor(function, toAppend));
                } else if ("authUser".equals(function)) {
                    authUser(toHandle, responseFor(function, toAppend));
                } else if ("adminChangeCustomer".equals(function)) {
                    adminChangeCustomer(toHandle, responseFor(function, toAppend));
                } else if ("getProductDetail".equals(function)) {
                    getProductDetail(toHandle, responseFor(function, toAppend));
                } else if ("getSupplierUserDetail".equals(function)) {
                    getSupplierUserDetail(toHandle, responseFor(function, toAppend));
                } else if ("getBeverageDetail".equals(function)) {
                    getBeverageDetail(toHandle, responseFor(function, toAppend));
                } else if ("getRecentlyOrderedProducts".equals(function)) {
                    getRecentlyOrderedProducts(toHandle, responseFor(function, toAppend));
                } else if ("getProductRequests".equals(function)) {
                    getProductRequests(toHandle, responseFor(function, toAppend));
                } else if ("getProductRequestNotifications".equals(function)) {
                    getProductRequestNotifications(toHandle, responseFor(function, toAppend));
                } else if ("getLocationStatusNotifications".equals(function)) {
                    getLocationStatusNotifications(toHandle, responseFor(function, toAppend));
                } else if ("getPurchaseDetail".equals(function)) {
                    getPurchaseDetail(toHandle, responseFor(function, toAppend));
                } else if ("getPurchases".equals(function)) {
                    getPurchases(toHandle, responseFor(function, toAppend));
                } else if ("getSupplierRequests".equals(function)) {
                    getSupplierRequests(toHandle, responseFor(function, toAppend));
                } else if ("getSuppliers".equals(function)) {
                    getSuppliers(toHandle, responseFor(function, toAppend));
                } else if ("getLocationSuppliers".equals(function)) {
                    getLocationSuppliers(toHandle, responseFor(function, toAppend));
                } else if ("getSetupInfo".equals(function)) {
                    getSetupInfo(toHandle, responseFor(function, toAppend));
                } else if ("getNormalUsers".equals(function)) {
                    getNormalUsers(toHandle, responseFor(function, toAppend));
                } else if ("getAdminUsers".equals(function)) {
                    getAdminUsers(toHandle, responseFor(function, toAppend));
                } else if ("getDailySupplierReports".equals(function)) {
                    getDailySupplierReports(toHandle, responseFor(function, toAppend));
                } else if ("getWeeklySupplierReports".equals(function)) {
                    getWeeklySupplierReports(toHandle, responseFor(function, toAppend));
                } else if ("getUserDetail".equals(function)) {
                    getUserDetail(toHandle, responseFor(function, toAppend));
                } else if ("getUserEmailInfo".equals(function)) {
                    getUserEmailInfo(toHandle, responseFor(function, toAppend));
                } else if ("emailPurchase".equals(function)) {
                    emailPurchase(toHandle, responseFor(function, toAppend));
                } else if ("getBars".equals(function)) {
                    getBars(toHandle, responseFor(function, toAppend));
                } else if ("getLowStock".equals(function)) {
                    getLowStock(toHandle, responseFor(function, toAppend));
                } else if ("getLowStockAlerts".equals(function)) {
                    getLowStockAlerts(toHandle, responseFor(function, toAppend));
                } else if ("getLineCleaningHistory".equals(function)) {
                    getLineCleaningHistory(toHandle, responseFor(function, toAppend));
                } else if ("getClientKey".equals(function)) {
                    getClientKey(toHandle, responseFor(function, toAppend), ss);
                } else if ("getDbHealth".equals(function)) {
                    getDbHealth(toHandle, responseFor(function, toAppend));
                } else if ("getUsers".equals(function)) {
                    throw new HandlerException("the getUsers method is no longer supported");
                    // deprecated
                    //getUsers(toHandle, responseFor(function, toAppend));
                } else if ("lookupQuicksell".equals(function)) {
                    throw new HandlerException("the lookupQuicksell method is no longer supported");
                    // deprecated
                    //lookupQuicksell(toHandle, responseFor(function, toAppend));
                } else if ("getMiscProducts".equals(function)) {
                    getMiscProducts(toHandle, responseFor(function, toAppend));
                } else if ("getPurchaseSummary".equals(function)) {
                    getPurchaseSummary(toHandle, responseFor(function, toAppend));
                } else if ("getSystemTemperature".equals(function)) {
                    getSystemTemperature(toHandle, responseFor(function, toAppend));
                } else {
                    logger.generalWarning("Unknown function '" + function + "'.");
                }
            } else {
                // access violation
                addErrorDetail(toAppend, "Access violation: This method is not available with your client key");
                logger.portalAccessViolation("Tried to call '" + function + "' with key " + ss.toString());
            }
        } catch (Exception e) {
            if (e instanceof HandlerException) {
                throw (HandlerException) e;
            } else {
                logger.midwareError("Non-handler exception thrown in ReportHandler: " + e.toString());
                logger.midwareError("XML: " + toHandle.asXML());
                throw new HandlerException(e);
            }
        } finally {
            int queryCount = conn.getQueryCount();
            logger.dbAction("Executed " + queryCount + " quer" + (queryCount == 1 ? "y" : "ies"));
            conn.close();
        }

        logger.xml("response: " + toAppend.asXML());

    }

    private Element responseFor(String s, Element e) {
        String responseNamespace = (String) SOAPMessage.getURIMap().get("tkmsg");
        return e.addElement("m:" + s + "Response", responseNamespace);
    }

    private String nullToEmpty(String s) {
        return (null == s) ? "" : s;
    }

    private void close(Statement s) {
        if (s != null) {
            try {
                s.close();
            } catch (SQLException sqle) {
            }
        }
    }

    private void close(ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException sqle) {
            }
        }
    }

    private void close(Connection c) {
        if (c != null) {
            try {
                c.close();
            } catch (SQLException sqle) {
            }
        }
    }

    private void close(RegisteredConnection c) {
        c.close();
    }

    private void addErrorDetail(Element toAppend, String message) {
        toAppend.addElement("error").addElement("detail").addText(message);
    }

    private int getCallerId(Element toHandle) throws HandlerException {
        return HandlerUtils.getRequiredInteger(HandlerUtils.getRequiredElement(toHandle, "caller"), "callerId");
    }

    private boolean checkForeignKey(String table, int value) throws SQLException, HandlerException {
        return checkForeignKey(table, "id", value);
    }

    private boolean checkForeignKey(String table, String field, int value) throws SQLException, HandlerException {

        PreparedStatement stmt = null;
        ResultSet rs = null;
        boolean result = false;

        String select = "SELECT " + field + " FROM " + table +
                " WHERE " + field + " = ?";

        stmt = conn.prepareStatement(select);
        stmt.setInt(1, value);
        rs = stmt.executeQuery();
        result = rs.next();

        close(rs);
        close(stmt);
        return result;
    }

    private void getCustomerXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element customerEl = toAppend.addElement("customer");
            customerEl.addElement("customerId").addText(String.valueOf(rs.getInt(1)));
            customerEl.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            customerEl.addElement("acctNum").addText(String.valueOf(rs.getInt(3)));
            customerEl.addElement("cType").addText(String.valueOf(rs.getInt(4)));
        }

    }

    private void getCustomers(Element toHandle, Element toAppend)
            throws HandlerException {

        int customerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        String name = HandlerUtils.getOptionalString(toHandle, "customerName");
        int acctNum = HandlerUtils.getOptionalInteger(toHandle, "accountNumber");

        int paramsSet = 0;
        if (customerId >= 0) {
            paramsSet++;
        }
        if (null != name) {
            paramsSet++;
        }
        if (acctNum >= 0) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getCustomers.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (customerId >= 0) {
                String selectById = "SELECT id, name, acctNum, type FROM " +
                        "customer WHERE id=?";
                stmt = conn.prepareStatement(selectById);
                stmt.setInt(1, customerId);
                rs = stmt.executeQuery();
                getCustomerXML(toAppend, rs);
            } else if (null != name) {
                String selectByName = "SELECT id, name, acctNum, type FROM " +
                        "customer WHERE name LIKE = ?";
                stmt = conn.prepareStatement(selectByName);
                String subName = '%' + name + '%';
                stmt.setString(1, subName);
                rs = stmt.executeQuery();
                getCustomerXML(toAppend, rs);
            } else if (acctNum >= 0) {
                String selectByAcctNum = "SELECT id, name, acctNum, type " +
                        "FROM customer WHERE acctNum=?";
                stmt = conn.prepareStatement(selectByAcctNum);
                stmt.setInt(1, acctNum);
                rs = stmt.executeQuery();

                getCustomerXML(toAppend, rs);
            } else {
                String selectAll = "SELECT id, name, acctNum, type FROM customer";
                stmt = conn.prepareStatement(selectAll);
                rs = stmt.executeQuery();

                getCustomerXML(toAppend, rs);
            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getLocationXML(Element toAppend, ResultSet rs) throws SQLException {
        PreparedStatement stmt = null;
        ResultSet rs1 = null;

        String selectProductType = "SELECT DISTINCT p.pType FROM inventory i" +
                " LEFT JOIN location l ON l.id = i.location LEFT JOIN product p ON p.id = i.product" +
                " WHERE l.id = ? ORDER BY p.pType;";

        while (rs.next()) {
            int colCount = 1;

            Element locationEl = toAppend.addElement("location");
            locationEl.addElement("locationId").addText(String.valueOf(rs.getInt(colCount++)));
            locationEl.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("addressStreet").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("addressCity").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("addressZip").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("addressState").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("customerId").addText(String.valueOf(rs.getInt(colCount++)));
            locationEl.addElement("customerName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("brixMin").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("brixMax").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("lastPoured").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("lastSold").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("pouredAge").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("soldAge").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("picoPowerup").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("picoVersion").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("latitude").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("longitude").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("zoomLevel").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            //NischaySharma_11-Feb-2009_Start: Added new element to the response xml "varianceAlert"
            locationEl.addElement("varianceAlert").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            //NischaySharma_11-Feb-2009_End
            locationEl.addElement("draftLines").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("concept").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            locationEl.addElement("volImpact").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));

            stmt = conn.prepareStatement(selectProductType);
            stmt.setInt(1, rs.getInt(1));
            rs1 = stmt.executeQuery();
            Element pType = locationEl.addElement("pType");
            while (rs1.next()) {
                pType.addElement("type").addText(HandlerUtils.nullToEmpty(rs1.getString(1)));
            }

        }

    }

    private void getLocations(Element toHandle, Element toAppend) throws HandlerException {

        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        String name = HandlerUtils.getOptionalString(toHandle, "locationName");
        String addrStreet = HandlerUtils.getOptionalString(toHandle, "addressStreet");
        String addrCity = HandlerUtils.getOptionalString(toHandle, "addressCity");
        String addrState = HandlerUtils.getOptionalString(toHandle, "addressState");
        String addrZip = HandlerUtils.getOptionalString(toHandle, "addressZip");
        int refCustomerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int refSupplierId = HandlerUtils.getOptionalInteger(toHandle, "supplierId");
        int refUserId = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int countyId = HandlerUtils.getOptionalInteger(toHandle, "countyId");


        PreparedStatement stmt = null;
        ResultSet rs = null;

        boolean addrSearch = null != addrStreet || null != addrCity ||
                null != addrState || null != addrZip;
        int paramsSet = 0;
        if (locationId >= 0) {
            paramsSet++;
        }
        if (refCustomerId >= 0) {
            paramsSet++;
        }
        if (refSupplierId >= 0) {
            paramsSet++;
        }
        if (refUserId >= 0) {
            paramsSet++;
        }
        if (null != name) {
            paramsSet++;
        }
        if (addrSearch) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getLocations.");
        }

        try {
            //NischaySharma_11-Feb_2009_Start: The select query was changed to fetch varianceAlert also
            String select =
                    " SELECT l.id, l.name, " +
                    " l.addrStreet, l.addrCity, l.addrZip, l.addrState, " +
                    " l.customer, c.name, l.brixMin, l.brixMax, " +
                    " l.lastPoured, l.lastSold, " +
                    " TIME_TO_SEC(TIMEDIFF(NOW(),l.lastPoured)) AS pouredAge," +
                    " TIME_TO_SEC(TIMEDIFF(NOW(),l.lastSold)) AS soldAge," +
                    " l.picoPowerup, l.picoVersion, l.easternOffset, " +
                    " l.latitude, l.longitude, l.zoomLevel, l.varianceAlert, " +
                    " l.draftLines, l.concept, l.volImpact " +
                    " FROM customer c LEFT JOIN location l ON c.id=l.customer ";
            //NischaySharma_11-Feb-2009_End
            if (refSupplierId >= 0) {
                String selectBySupplierId = select +
                        " LEFT JOIN locationSupplier map ON map.location = l.id " +
                        " LEFT JOIN supplierAddress a ON map.address = a.id LEFT JOIN supplier s ON a.supplier=s.id " +
                        " WHERE s.id = ? " +
                        " ORDER BY l.id ASC";
                stmt = conn.prepareStatement(selectBySupplierId);
                stmt.setInt(1, refSupplierId);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (refUserId >= 0) {

                String selectUserExclusions = " SELECT e.value FROM exclusion e LEFT JOIN userExclusionMap uEM ON uEM.exclusion = e.id WHERE uEM.user = ? ";
                String userLocationExclusions = "0";
                stmt = conn.prepareStatement(selectUserExclusions);
                stmt.setInt(1, refUserId);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    userLocationExclusions = rs.getString(1);
                }

                int i = 1;
                String selectByUserRegionId = select +
                        " LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                        " LEFT JOIN userRegionMap uRM ON uRM.region = rCM.region " +
                        " WHERE l.isActive = 1 AND l.id NOT IN (" + userLocationExclusions + ") AND uRM.user = ? ";
                if (regionId > 0) {
                    selectByUserRegionId += " AND uRM.region = ? ";
                }
                if (countyId > 0) {
                    selectByUserRegionId += " AND rCM.county = ? ";
                }
                stmt = conn.prepareStatement(selectByUserRegionId);
                stmt.setInt(i++, refUserId);
                if (regionId > 0) {
                    stmt.setInt(i++, regionId);
                }
                if (countyId > 0) {
                    stmt.setInt(i++, countyId);
                }
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (refCustomerId >= 0) {
                if (!checkForeignKey("customer", "id", refCustomerId)) {
                    throw new HandlerException("Foreign Key Not found : customer " + refCustomerId);
                }
                String selectByCustomerId = select +
                        " WHERE l.customer = ?";
                stmt = conn.prepareStatement(selectByCustomerId);
                stmt.setInt(1, refCustomerId);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (locationId >= 0) {
                String selectById = select +
                        " WHERE l.id = ?";
                stmt = conn.prepareStatement(selectById);
                stmt.setInt(1, locationId);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (null != name) {
                String selectByName = select +
                        " WHERE l.name LIKE ?";
                stmt = conn.prepareStatement(selectByName);
                String likeName = "%" + name + "%";
                stmt.setString(1, likeName);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else if (addrSearch) {
                StringBuffer buf = new StringBuffer(select +
                        " WHERE ");

                // add the necessary address search LIKE expressions
                boolean appended = false;
                if (null != addrStreet) {
                    buf.append(" l.addrStreet LIKE ?");
                    appended = true;
                }
                if (null != addrCity) {
                    buf.append((appended ? " AND" : "") + " l.addrCity LIKE ?");
                    appended = true;
                }
                if (null != addrState) {
                    buf.append((appended ? " AND" : "") + " l.addrState LIKE ?");
                    appended = true;
                }
                if (null != addrZip) {
                    buf.append((appended ? " AND" : "") + " l.addrZip LIKE ?");
                    appended = true;
                }

                // use the setString method for correct database quoting
                stmt = conn.prepareStatement(buf.toString());
                stmt.setString(1, name);
                int index = 2;
                String like = null;
                if (null != addrStreet) {
                    like = "%" + addrStreet + "%";
                    stmt.setString(index++, like);
                }
                if (null != addrCity) {
                    like = "%" + addrCity + "%";
                    stmt.setString(index++, like);
                }
                if (null != addrState) {
                    like = "%" + addrState + "%";
                    stmt.setString(index++, like);
                }
                if (null != addrZip) {
                    like = "%" + addrZip + "%";
                    stmt.setString(index++, like);
                }

                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            } else {
                String selectAll = select + " WHERE c.id > 0 ";
                stmt = conn.prepareStatement(selectAll);
                rs = stmt.executeQuery();
                getLocationXML(toAppend, rs);
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getAfterHours(Element toHandle, Element toAppend) throws HandlerException {


        String selectAfterHours = "SELECT " +
                "DATE_SUB(If(x.close>'12:0:0',concat(left(subdate(now(),1),11),x.close),concat(left(now(),11),x.close)), INTERVAL eO HOUR) Close, " +
                "DATE_SUB(Concat(left(now(),11),x.Open), INTERVAL eO HOUR) Open FROM " +
                "(Select CASE DAYOFWEEK(NOW()-1000000) " +
                "WHEN 1 THEN Right(lH.closeSun,8) " +
                "WHEN 2 THEN Right(lH.closeMon,8) " +
                "WHEN 3 THEN Right(lH.closeTue,8) " +
                "WHEN 4 THEN Right(lH.closeWed,8) " +
                "WHEN 5 THEN Right(lH.closeThu,8) " +
                "WHEN 6 THEN Right(lH.closeFri,8) " +
                "WHEN 7 THEN Right(lH.closeSat,8) END close, " +
                "CASE DAYOFWEEK(NOW()) " +
                "WHEN 1 THEN Right(lH.preOpenSun,8) " +
                "WHEN 2 THEN Right(lH.preOpenMon,8) " +
                "WHEN 3 THEN Right(lH.preOpenTue,8) " +
                "WHEN 4 THEN Right(lH.preOpenWed,8) " +
                "WHEN 5 THEN Right(lH.preOpenThu,8) " +
                "WHEN 6 THEN Right(lH.preOpenFri,8) " +
                "WHEN 7 THEN Right(lH.preOpenSat,8) END open, " +
                "l.easternOffset eO " +
                "FROM locationHours lH JOIN location l ON lH.location=l.id " +
                "WHERE l.id=?) AS x;";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getAfterHours");

        try {

            int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");


            //Check that this product doesn't already exist in inventory at this location
            stmt = conn.prepareStatement(selectAfterHours);
            stmt.setInt(1, locationId);
            rs = stmt.executeQuery();

            if (rs.next()) {
                toAppend.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /**
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void getDailySupplierReports(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = " SELECT dailyInvReport, dailyBrandReport FROM emailReports WHERE user=? and supplier=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getDailySupplierReports");

        try {
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int supplierId = HandlerUtils.getRequiredInteger(toHandle, "supplierId");

            stmt = conn.prepareStatement(select);
            stmt.setInt(1, userId);
            stmt.setInt(2, supplierId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("dailyInventoryReport").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("dailyBrandReport").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /**
     * The folowing code is to update or insert the report requirements for each user for the email address
     * that they provide - SR
     */
    private void getWeeklySupplierReports(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        String select = " SELECT weeklyBrandReport, weeklyCategoryReport FROM emailReports WHERE user=? and supplier=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getWeeklySupplierReports");

        try {
            int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
            int supplierId = HandlerUtils.getRequiredInteger(toHandle, "supplierId");

            stmt = conn.prepareStatement(select);
            stmt.setInt(1, userId);
            stmt.setInt(2, supplierId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("weeklyBrandReport").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("weeklyCategoryReport").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    private void getCountyPoints(Element toHandle, Element toAppend) throws HandlerException {

        int countyId = HandlerUtils.getRequiredInteger(toHandle, "countyId");
        int stateId = HandlerUtils.getRequiredInteger(toHandle, "stateId");

        PreparedStatement stmt = null;
        ResultSet zipRS = null;
        ResultSet rs = null;

        try {
            Element countyEl = toAppend.addElement("countyPoints");

            String selectZipList = " SELECT z.id, z.zip, z.zipname, AsText(z.polpnt), AsText(z.swpoint), AsText(z.nepoint) FROM zipList z " +
                    " WHERE z.pointZip = 0 AND z.county = ? AND z.fipsst = ?";
            stmt = conn.prepareStatement(selectZipList);
            stmt.setInt(1, countyId);
            stmt.setInt(2, stateId);
            zipRS = stmt.executeQuery();
            while (zipRS.next()) {
                Element zipEl = countyEl.addElement("zip");
                zipEl.addElement("id").addText(String.valueOf(zipRS.getInt(1)));
                zipEl.addElement("zipId").addText(String.valueOf(zipRS.getInt(2)));
                zipEl.addElement("zipName").addText(HandlerUtils.nullToEmpty(zipRS.getString(3)));
                zipEl.addElement("zipCenterPoint").addText(HandlerUtils.nullToEmpty(zipRS.getString(4)));
                zipEl.addElement("zipSWPoint").addText(HandlerUtils.nullToEmpty(zipRS.getString(5)));
                zipEl.addElement("zipNEPoint").addText(HandlerUtils.nullToEmpty(zipRS.getString(6)));

                logger.debug("ZipCode Packaging for " + String.valueOf(zipRS.getInt(2)));

                String selectZipPoints = " SELECT zPoints.idgeoz, zPoints.extring, zPoints.hasintring, Replace(AsText(poly), 'POLYGON', '') FROM zipPoints zPoints " +
                        " WHERE zPoints.ZIP = ? AND zPoints.IDGEOZ IS NOT NULL ORDER BY zPoints.IDGEOZ ";
                stmt = conn.prepareStatement(selectZipPoints);
                stmt.setInt(1, zipRS.getInt(2));
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element zipPointsEL = zipEl.addElement("zipPoints");
                    zipPointsEL.addElement("id").addText(String.valueOf(rs.getInt(1)));
                    zipPointsEL.addElement("extring").addText(String.valueOf(rs.getInt(2)));
                    zipPointsEL.addElement("hasintring").addText(String.valueOf(rs.getInt(3)));
                    zipPointsEL.addElement("points").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getCounties(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int refStateId = HandlerUtils.getOptionalInteger(toHandle, "stateId");
        int refRegionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int refCountyId = HandlerUtils.getOptionalInteger(toHandle, "countyId");

        boolean getCoords = HandlerUtils.getOptionalBoolean(toHandle, "getCoords");
        boolean getLocations = HandlerUtils.getOptionalBoolean(toHandle, "getLocations");

        PreparedStatement stmt = null;
        ResultSet countyRS = null;
        ResultSet rs = null;

        String selectUserExclusions = " SELECT e.value FROM exclusion e LEFT JOIN userExclusionMap uEM ON uEM.exclusion = e.id WHERE uEM.user = ? ";
        String userLocationExclusions = "0";
        stmt = conn.prepareStatement(selectUserExclusions);
        stmt.setInt(1, 6);
        rs = stmt.executeQuery();
        if (rs.next()) {
            userLocationExclusions = rs.getString(1);
        }

        String selectCounty = " SELECT c.id, c.state, rCM.region, c.county, c.name, Replace(AsText(c.points), 'POLYGON', '') FROM county c " +
                " LEFT JOIN regionCountyMap rCM ON rCM.county = c.id ";

        String selectCountyLocations = " SELECT id FROM location WHERE id NOT IN ("+ userLocationExclusions +") AND countyIndex = ? ";

        int paramsSet = 0;

        if (refStateId >= 0) {
            selectCounty += " WHERE c.state = ? ";
            paramsSet++;
        } else if (refRegionId >= 0) {
            selectCounty += " WHERE rCM.region = ? ";
            paramsSet++;
        } else if (refCountyId >= 0) {
            selectCounty += " WHERE rCM.county = ? ";
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getCounties");
        }

        try {
            stmt = conn.prepareStatement(selectCounty);
            if (refStateId >= 0) {
                stmt.setInt(1, refStateId);
            } else if (refRegionId >= 0) {
                stmt.setInt(1, refRegionId);
            } else if (refCountyId >= 0) {
                stmt.setInt(1, refCountyId);
            }
            countyRS = stmt.executeQuery();
            while (countyRS.next()) {
                String locationString = "";

                Element countyEl = toAppend.addElement("county");
                countyEl.addElement("id").addText(String.valueOf(countyRS.getInt(1)));
                countyEl.addElement("state").addText(String.valueOf(countyRS.getInt(2)));
                countyEl.addElement("regionId").addText(String.valueOf(countyRS.getInt(3)));
                countyEl.addElement("countyId").addText(String.valueOf(countyRS.getInt(4)));
                countyEl.addElement("countyName").addText(HandlerUtils.nullToEmpty(countyRS.getString(5)));
                if (getCoords) {
                    countyEl.addElement("countyPoints").addText(HandlerUtils.nullToEmpty(countyRS.getString(6)));
                }
                if (getLocations) {
                    stmt = conn.prepareStatement(selectCountyLocations);
                    stmt.setInt(1, countyRS.getInt(1));
                    rs = stmt.executeQuery();
                    while (rs.next()) {
                        locationString = locationString + String.valueOf(rs.getInt(1));
                        if (!rs.isLast()) {
                            locationString = locationString + ", ";
                        }
                    }
                    countyEl.addElement("locations").addText(HandlerUtils.nullToEmpty(locationString));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getRegions(Element toHandle, Element toAppend) throws HandlerException {

        int refUserId = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int refRegionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");

        boolean getCoords = HandlerUtils.getOptionalBoolean(toHandle, "getCoords");
        boolean getProducts = HandlerUtils.getOptionalBoolean(toHandle, "getProducts");

        String selectRegion = " SELECT r.id, r.name, r.threshold, Replace(AsText(r.points), 'POLYGON', ''), r.products FROM region r " +
                " LEFT JOIN userRegionMap uRM ON uRM.region = r.id ";

        int paramsSet = 0;

        if (refUserId >= 0) {
            selectRegion += " WHERE uRM.user = ? ";
            paramsSet++;
        } else if (refRegionId >= 0) {
            selectRegion += " WHERE r.id = ? ";
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getRegions.");
        }

        PreparedStatement stmt = null;
        ResultSet regionRS = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(selectRegion);
            if (refUserId >= 0) {
                stmt.setInt(1, refUserId);
            } else if (refRegionId >= 0) {
                stmt.setInt(1, refRegionId);
            }
            regionRS = stmt.executeQuery();

            while (regionRS.next()) {
                Element regionEl = toAppend.addElement("region");
                regionEl.addElement("regionId").addText(String.valueOf(regionRS.getInt(1)));
                regionEl.addElement("regionName").addText(HandlerUtils.nullToEmpty(regionRS.getString(2)));
                regionEl.addElement("threshold").addText(String.valueOf(regionRS.getString(3)));
                if (getCoords) {
                    regionEl.addElement("regionPoints").addText(HandlerUtils.nullToEmpty(regionRS.getString(4)));
                }
                if (getProducts) {
                    regionEl.addElement("productList").addText(HandlerUtils.nullToEmpty(regionRS.getString(5)));
                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getSystemsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element SystemEl = toAppend.addElement("system");

            SystemEl.addElement("systemId").addText(String.valueOf(rs.getInt(1)));
            SystemEl.addElement("locationId").addText(String.valueOf(rs.getInt(2)));
            SystemEl.addElement("line").addText(String.valueOf(rs.getInt(3)));
        }
    }

    private void getSystems(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "systemId");
        int refLocationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");

        int paramsSet = 0;
        if (id >= 0) {
            paramsSet++;
        }
        if (refLocationId >= 0) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getSystems.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " +
                            refLocationId);
                }

                String selectByLocationId = "SELECT id, location, lines " +
                        "FROM system WHERE location = ?";
                stmt = conn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                rs = stmt.executeQuery();

                getSystemsXML(toAppend, rs);
            } else if (id >= 0) {
                String selectById = "SELECT id, location, lines FROM system " +
                        "WHERE id = ?";
                stmt = conn.prepareStatement(selectById);
                stmt.setInt(1, id);
                rs = stmt.executeQuery();

                getSystemsXML(toAppend, rs);
            } else {
                String selectAll = "SELECT id, location, lines FROM system";
                stmt = conn.prepareStatement(selectAll);
                rs = stmt.executeQuery();
                getSystemsXML(toAppend, rs);
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
//    private void getSuppliersXML(Element toAppend, ResultSet rs) throws SQLException {
//        while(rs.next()) {
//            Element sEl = toAppend.addElement("supplier");
//            
//            sEl.addElement("id").addText(String.valueOf(rs.getInt(1)));
//            sEl.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
//            sEl.addElement("addrStreet").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
//            sEl.addElement("addrCity").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
//            sEl.addElement("addrState").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
//            sEl.addElement("addrZip").addText(HandlerUtils.nullToEmpty(rs.getString(6)));
//        }
//        
//    }

    /**  Get a list of all suppliers and their associated addresses
     *  args:
     *  <supplierId> OPTIONAL return only addresses from this supplier
     *              If omitted, all suppliers will be returned
     *  <showInactive> OPTIONAL default 0.  If positive, inactive addresses will be included 
     *
     *  return structure:
     *  <supplier>
     *    <supplierId>0000
     *    <supplierName>Name
     *    <address>
     *      <addressId>000
     *      <street>String
     *      <city>String
     *      <state>XX
     *      <zip>10000
     *    </address>
     *    <address ... />
     *  </supplier>
     *  <supplier .. />
     */
    private void getSuppliers(Element toHandle, Element toAppend) throws HandlerException {

        int showInactive = HandlerUtils.getOptionalInteger(toHandle, "showInactive");
        int supplierFilter = HandlerUtils.getOptionalInteger(toHandle, "supplierId");

        String getSuppliers =
                " SELECT id,name FROM supplier " + (supplierFilter > 0 ? "WHERE id=?" : "");
        String getAddresses =
                " SELECT id,addrStreet,addrCity,addrState,addrZip,active " +
                " FROM supplierAddress WHERE supplier=? " + (showInactive <= 0 ? "AND active=1" : "");

        PreparedStatement stmt = null;
        PreparedStatement addrStmt = null;
        ResultSet sups = null;
        ResultSet addrs = null;

        try {
            addrStmt = conn.prepareStatement(getAddresses);
            stmt = conn.prepareStatement(getSuppliers);
            if (supplierFilter > 0) {
                stmt.setInt(1, supplierFilter);
            }
            sups = stmt.executeQuery();
            while (sups.next()) {
                Element supEl = toAppend.addElement("supplier");
                int supplierId = sups.getInt(1);
                String supplierName = sups.getString(2);
                supEl.addElement("supplierId").addText(String.valueOf(supplierId));
                supEl.addElement("supplierName").addText(String.valueOf(supplierName));
                addrStmt.setInt(1, supplierId);
                addrs = addrStmt.executeQuery();
                while (addrs.next()) {
                    Element addrEl = supEl.addElement("address");
                    addrEl.addElement("addressId").addText(String.valueOf(addrs.getInt(1)));
                    addrEl.addElement("street").addText(String.valueOf(addrs.getString(2)));
                    addrEl.addElement("city").addText(String.valueOf(addrs.getString(3)));
                    addrEl.addElement("state").addText(String.valueOf(addrs.getString(4)));
                    addrEl.addElement("zip").addText(String.valueOf(addrs.getString(5)));
                    addrEl.addElement("active").addText(String.valueOf(addrs.getString(6)));
                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(sups);
            close(addrs);
            close(stmt);
            close(addrStmt);
        }

    }

    /**  Return a list of all associated suppliers from this location
     */
    private void getLocationSuppliers(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        String select =
                " SELECT s.name, a.active, a.addrStreet, a.addrCity, a.addrState, a.addrZip, s.id, a.id, map.repEmail " +
                " FROM locationSupplier map LEFT JOIN supplierAddress a ON map.address = a.id" +
                " LEFT JOIN supplier s ON a.supplier=s.id WHERE map.location=? ";
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(select);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element sup = toAppend.addElement("supplier");
                sup.addElement("name").addText(String.valueOf(rs.getString(1)));
                sup.addElement("active").addText(String.valueOf(rs.getInt(2)));
                sup.addElement("addrStreet").addText(String.valueOf(rs.getString(3)));
                sup.addElement("addrCity").addText(String.valueOf(rs.getString(4)));
                sup.addElement("addrState").addText(String.valueOf(rs.getString(5)));
                sup.addElement("addrZip").addText(String.valueOf(rs.getString(6)));
                sup.addElement("supplierId").addText(String.valueOf(rs.getInt(7)));
                sup.addElement("addressId").addText(String.valueOf(rs.getInt(8)));
                sup.addElement("repEmail").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationSuppliers: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getBarsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element BarE1 = toAppend.addElement("bar");

            BarE1.addElement("barId").addText(String.valueOf(rs.getInt(1)));
            BarE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            BarE1.addElement("locationId").addText(String.valueOf(rs.getInt(3)));
            BarE1.addElement("zoneId").addText(String.valueOf(rs.getInt(4)));
            //NischaySharma_09-Feb-2009_Start: Added latitude & longitude to the response xml
            BarE1.addElement("latitude").addText(String.valueOf(rs.getDouble(5)));
            BarE1.addElement("longitude").addText(String.valueOf(rs.getDouble(6)));
            //NischaySharma_09-Feb-2009_End
        }

    }

    private void getBars(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int zoneId = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int refLocationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int refCustomerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");

        int paramsSet = 0;
        if (id >= 0) {
            paramsSet++;
        }
        if (zoneId >= 0) {
            paramsSet++;
        }
        if (refLocationId >= 0) {
            paramsSet++;
        }
        if (refCustomerId >= 0) {
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getBars.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " +
                            refLocationId);
                }
                //NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
                //select statement.
                String selectByLocationId = "SELECT id, name, location, zone, latitude, longitude " +
                        "FROM bar WHERE location = ?";
                //NischaySharma_09-Feb-2009_End
                stmt = conn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                rs = stmt.executeQuery();
                getBarsXML(toAppend, rs);
            } else if (refCustomerId >= 0) {
                if (!checkForeignKey("customer", "id", refCustomerId)) {
                    throw new HandlerException("Foreign Key Not found : customer " +
                            refCustomerId);
                }
                //NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
                //select statement.
                String selectByCustomerId = "SELECT bar.id, bar.name, bar.location, bar.zone, bar.latitude, bar.longitude " +
                        "FROM bar LEFT JOIN location ON location.id=bar.location " +
                        "LEFT JOIN customer ON location.customer = customer.id " +
                        "WHERE customer.id=?";
                //NischaySharma_09-Feb_2009_End
                stmt = conn.prepareStatement(selectByCustomerId);
                stmt.setInt(1, refCustomerId);
                rs = stmt.executeQuery();
                getBarsXML(toAppend, rs);

            } else if (zoneId >= 0) {
                if (!checkForeignKey("zone", "id", zoneId)) {
                    throw new HandlerException("Foreign Key Not found : zone " +
                            zoneId);
                }
                //NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
                //select statement.
                String selectByZoneId = "SELECT id, name, location, zone, latitude, longitude " +
                        "FROM bar WHERE zone = ?";
                //NischaySharma_09-Feb_2009_End
                stmt = conn.prepareStatement(selectByZoneId);
                stmt.setInt(1, zoneId);
                rs = stmt.executeQuery();
                getBarsXML(toAppend, rs);
            } else if (id >= 0) {
                //NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
                //select statement.
                String selectByBarId = "SELECT id, name, location, zone, latitude, longitude " +
                        "FROM bar WHERE id=?";
                //NischaySharma_09-Feb_2009_End
                stmt = conn.prepareStatement(selectByBarId);
                stmt.setInt(1, id);
                rs = stmt.executeQuery();

                getBarsXML(toAppend, rs);
            } else {
                //NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
                //select statement.
                String selectByLocationId = "SELECT id, name, location, zone, latitude, longitude " +
                        "FROM bar";
                //NischaySharma_09-Feb_2009_Start: Added laltitude and longitude to the
                //select statement.
                stmt = conn.prepareStatement(selectByLocationId);
                rs = stmt.executeQuery();

                getBarsXML(toAppend, rs);
            }


        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getProductsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element ProductE1 = toAppend.addElement("product");

            ProductE1.addElement("productId").addText(String.valueOf(rs.getInt(1)));
            ProductE1.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));

        }

    }

    private void getProducts(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getOptionalInteger(toHandle, "productId");
        String name = HandlerUtils.getOptionalString(toHandle, "name");

        int paramsSet = 0;
        if (id >= 0) {
            paramsSet++;
        }
        if (null != name) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getProducts.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {

            if (id >= 0) {
                String selectById = "SELECT id, name FROM product " +
                        "WHERE id = ?";
                stmt = conn.prepareStatement(selectById);
                stmt.setInt(1, id);
                rs = stmt.executeQuery();
                getProductsXML(toAppend, rs);
            } //NischaySharma_08-May-2009_Start: Added check if that if name is empty string then 
            //do not execue the query for name
            else if (null != name && !name.equals("")) {
                String selectByName = "SELECT id, name " +
                        "FROM product WHERE name LIKE ?";
                name = '%' + name + '%';
                stmt = conn.prepareStatement(selectByName);
                stmt.setString(1, name);
                rs = stmt.executeQuery();
                getProductsXML(toAppend, rs);
            } //NischaySharma_08-May-2009_End
            else {
                String selectAll = "SELECT id, name FROM product WHERE id>0";
                stmt = conn.prepareStatement(selectAll);
                rs = stmt.executeQuery();
                getProductsXML(toAppend, rs);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a total tap count for the requried drill down
     */
    private void getLocationCount(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int countyId = HandlerUtils.getOptionalInteger(toHandle, "countyId");

        String conditionString = " ";

        if (regionId > 0) {
            conditionString = " AND uRM.region = ? ";
        } else if (countyId > 0) {
            conditionString = " AND l.countyIndex = ? ";
        }

        String selectLocationCount = " SELECT count(l.id) FROM location l " +
                " LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                " LEFT JOIN userRegionMap uRM ON uRM.region = rCM.region " +
                " WHERE uRM.user = ?  " + conditionString;

        int paramsSet = 0;

        if (regionId >= 0) {
            paramsSet++;
        } else if (countyId >= 0) {
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getLocationCount.");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(selectLocationCount);
            stmt.setInt(1, userId);
            if (regionId >= 0) {
                stmt.setInt(2, regionId);
            } else if (countyId >= 0) {
                stmt.setInt(2, countyId);
            }
            rs = stmt.executeQuery();

            if (rs.next()) {
                Element tapCount = toAppend.addElement("locationCount");
                tapCount.addText(String.valueOf(rs.getInt(1)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    //SundarRavindran_28-Aug-2009_Start
    /**  Return a total tap share count for the requried drill down
     */
    private void getTapShare(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int countyId = HandlerUtils.getOptionalInteger(toHandle, "countyId");
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int parentLevel = 0;
        String conditionString = " ", selectedValues = " ";
        int parent = 0, child = 0;
        int tapCount = 0, childTapCount = 0, parentTapCount = 0;
        int totalTapCount = 0, totalChildTapCount = 0, totalParentTapCount = 0;

        Element parentTag = null, childTag = null;

        int paramsSet = 0;

        if (regionId > 0) {
            conditionString = " AND uRM.region = ? ";
            selectedValues = " l.countyIndex, l.id, ";
            parentLevel = 3;
            parentLevelMap = new ParentLevelMap(conn, parentLevel);
            childLevelMap = new ChildLevelMap(conn, parentLevel);
            paramsSet++;
        } else if (countyId > 0) {
            conditionString = " AND l.countyIndex = ? ";
            selectedValues = " l.id, b.id, ";
            parentLevel = 4;
            parentLevelMap = new ParentLevelMap(conn, parentLevel);
            childLevelMap = new ChildLevelMap(conn, 5);
            paramsSet++;
        } else if (locationId > 0) {
            conditionString = " AND l.id = ? ";
            selectedValues = " l.id, b.id, ";
            parentLevel = 4;
            parentLevelMap = new ParentLevelMap(conn, parentLevel);
            childLevelMap = new ChildLevelMap(conn, 5);
            paramsSet++;
        } else {
            conditionString = " ";
            selectedValues = " uRM.region, l.countyIndex, ";
            parentLevel = 2;
            parentLevelMap = new ParentLevelMap(conn, parentLevel);
            childLevelMap = new ChildLevelMap(conn, parentLevel);
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getTapShare.");
        }
        String selectTapCount = " SELECT " + selectedValues + " li.product, count(li.product) FROM line li " +
                " LEFT JOIN bar b ON b.id = li.bar " +
                " LEFT JOIN location l ON l.id = b.location " +
                " LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                " LEFT JOIN userRegionMap uRM ON uRM.region = rCM.region " +
                " WHERE uRM.user = ? AND li.status = 'RUNNING' " + conditionString +
                " GROUP BY " + selectedValues + " li.product " +
                " ORDER BY " + selectedValues + " li.product ";



        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(selectTapCount);
            stmt.setInt(1, userId);
            if (regionId >= 0) {
                stmt.setInt(2, regionId);
            } else if (countyId >= 0) {
                stmt.setInt(2, countyId);
            } else if (locationId >= 0) {
                stmt.setInt(2, locationId);
            }
            rs = stmt.executeQuery();

            while (rs.next()) {

                if (parent != rs.getInt(1)) {
                    regionExclusionMap = new RegionExclusionMap(conn, parentLevel - 1, rs.getInt(1));
                    if (tapCount > 0) {
                        childTag.addElement("tapCount").addText(String.valueOf(tapCount));
                        tapCount = 0;
                    }
                    if (childTapCount > 0) {
                        childTag.addElement("childTapCount").addText(String.valueOf(childTapCount));
                        childTapCount = 0;
                    }

                    if (totalChildTapCount > 0) {
                        parentTag.addElement("totalChildTapCount").addText(String.valueOf(totalChildTapCount));
                        totalChildTapCount = 0;
                    }
                    if (parentTapCount > 0) {
                        parentTag.addElement("parentTapCount").addText(String.valueOf(parentTapCount));
                        parentTapCount = 0;
                    }

                    parent = rs.getInt(1);
                    regionProductMap = new RegionProductMap(conn, parentLevel, rs.getInt(1));
                    //NischaySharma_24-Aug-2009_Start
                    parentTag = toAppend.addElement("parent");
                    //NischaySharma_24-Aug-2009_End
                    parentTag.addElement("parentLevelId").addText(String.valueOf(rs.getInt(1)));
                    parentTag.addElement("parentLevelName").addText(String.valueOf(parentLevelMap.getParentLevel(rs.getInt(1))));

                }

                if (child != rs.getInt(2)) {
                    if (tapCount > 0) {
                        childTag.addElement("tapCount").addText(String.valueOf(tapCount));
                        tapCount = 0;
                    }
                    if (childTapCount > 0) {
                        childTag.addElement("childTapCount").addText(String.valueOf(childTapCount));
                        childTapCount = 0;
                    }
                    child = rs.getInt(2);
                    childTag = parentTag.addElement("child");
                    childTag.addElement("childLevelId").addText(String.valueOf(rs.getInt(2)));
                    childTag.addElement("childLevelName").addText(String.valueOf(childLevelMap.getChildLevel(rs.getInt(2))));
                }

                if (!regionExclusionMap.hasValue(rs.getInt(3))) {

                    tapCount += rs.getInt(4);
                    totalChildTapCount += rs.getInt(4);
                    totalTapCount += rs.getInt(4);

                    if (regionProductMap.hasProduct(rs.getInt(3))) {
                        childTapCount += rs.getInt(4);
                        parentTapCount += rs.getInt(4);
                        totalParentTapCount += rs.getInt(4);
                    }

                }

            }

            if (tapCount > 0) {
                childTag.addElement("tapCount").addText(String.valueOf(tapCount));
                tapCount = 0;
            }
            if (childTapCount > 0) {
                childTag.addElement("childTapCount").addText(String.valueOf(childTapCount));
                childTapCount = 0;
            }

            if (totalChildTapCount > 0) {
                parentTag.addElement("totalChildTapCount").addText(String.valueOf(totalChildTapCount));
                totalChildTapCount = 0;
            }
            if (parentTapCount > 0) {
                parentTag.addElement("parentTapCount").addText(String.valueOf(parentTapCount));
                parentTapCount = 0;
            }

            toAppend.addElement("totalTapCount").addText(String.valueOf(totalTapCount));
            toAppend.addElement("totalParentTapCount").addText(String.valueOf(totalParentTapCount));

            parentLevelMap = null;
            childLevelMap = null;
            regionProductMap = null;
            regionExclusionMap = null;
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }
    //SundarRavindran_28-Aug-2009_End

    /**  Return a total tap count for the requried drill down
     */
    private void getTapCount(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
        int regionId = HandlerUtils.getOptionalInteger(toHandle, "regionId");
        int countyId = HandlerUtils.getOptionalInteger(toHandle, "countyId");
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String selectUserExclusions = " SELECT e.value FROM exclusion e LEFT JOIN userExclusionMap uEM ON uEM.exclusion = e.id WHERE uEM.user = ? ";
        String userLocationExclusions = "0";
        stmt = conn.prepareStatement(selectUserExclusions);
        stmt.setInt(1, userId);
        rs = stmt.executeQuery();
        if (rs.next()) {
            userLocationExclusions = rs.getString(1);
        }

        String conditionString = " ";

        if (regionId > 0) {
            conditionString = " AND uRM.region = ? ";
        } else if (countyId > 0) {
            conditionString = " AND l.countyIndex = ? ";
        } else if (locationId > 0) {
            conditionString = " AND l.id = ? ";
        }

        String selectTapCount = " SELECT li.product, count(li.product) FROM line li " +
                " LEFT JOIN bar b ON b.id = li.bar " +
                " LEFT JOIN location l ON l.id = b.location " +
                " LEFT JOIN regionCountyMap rCM ON rCM.county = l.countyIndex " +
                " LEFT JOIN userRegionMap uRM ON uRM.region = rCM.region " +
                " WHERE l.id NOT IN ("+ userLocationExclusions +") AND uRM.user = ? AND li.status = 'RUNNING' " + conditionString +
                " GROUP BY li.product " +
                " ORDER BY li.product ";

        int paramsSet = 0;

        if (regionId >= 0) {
            paramsSet++;
        } else if (countyId >= 0) {
            paramsSet++;
        } else if (locationId >= 0) {
            paramsSet++;
        }

        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getTapCount.");
        }

        try {
            stmt = conn.prepareStatement(selectTapCount);
            stmt.setInt(1, userId);

            if (regionId >= 0) {
                stmt.setInt(2, regionId);
            } else if (countyId >= 0) {
                stmt.setInt(2, countyId);
            } else if (locationId >= 0) {
                stmt.setInt(2, locationId);
            }
            rs = stmt.executeQuery();

            while (rs.next()) {
                Element tapCount = toAppend.addElement("tapCount");
                tapCount.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                tapCount.addElement("count").addText(String.valueOf(rs.getInt(2)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Return a list of all product categories
     */
    private void getCategory(Element toHandle, Element toAppend) throws HandlerException {

        int productId = HandlerUtils.getOptionalInteger(toHandle, "productId");

        String select = "SELECT c.id, c.name FROM category c ";

        if (productId > 0) {
            select += " LEFT JOIN product p ON p.category = c.id WHERE p.id=? ";
        }

        select += " ORDER BY name ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(select);
            if (productId > 0) {
                stmt.setInt(1, productId);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element cat = toAppend.addElement("category");
                cat.addElement("id").addText(String.valueOf(rs.getInt(1)));
                cat.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getCategory: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    private void getBeverageDetail(Element toHandle, Element toAppend) throws HandlerException {

        String beveragePlu = HandlerUtils.getRequiredString(toHandle, "beveragePlu");
        String beverageName = HandlerUtils.getRequiredString(toHandle, "beverageName");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int beverage = -1;
        double PartOunces = 0;
        double totalOunces = 0;
        String part;
        PreparedStatement stmt = null;
        ResultSet rs = null;

        String selectBeverageInfo = "SELECT id, name FROM beverage WHERE plu = ? AND location = ?";

        String selectIngredient = "SELECT i.id, i.ounces, i.product FROM ingredient i WHERE i.beverage = ?";

        String selectPartSize = "SELECT ROUND(SUM(i.ounces)/COUNT(i.id),2), MIN(i.ounces) FROM ingredient i WHERE i.beverage = ?";

        String selectBeverages = "SELECT b.id, SUM(i.ounces), b.plu FROM ingredient i left join beverage b on b.id = i.beverage where b.name = ? and b.location = ? group by b.id order by b.id ;";

        try {
            stmt = conn.prepareStatement(selectBeverageInfo);
            stmt.setString(1, beveragePlu);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                beverage = rs.getInt(1);
                toAppend.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }


            stmt = conn.prepareStatement(selectPartSize);
            stmt.setInt(1, beverage);
            rs = stmt.executeQuery();
            if (rs.next()) {
                PartOunces = rs.getDouble(1);
                totalOunces = rs.getDouble(2);
            }


            stmt = conn.prepareStatement(selectIngredient);
            stmt.setInt(1, beverage);
            rs = stmt.executeQuery();
            while (rs.next()) {
                part = String.valueOf(Double.parseDouble(rs.getString(2)) / totalOunces);
                Element line = toAppend.addElement("ingredient");
                line.addElement("id").addText(rs.getString(1));
                line.addElement("part").addText(part);
                line.addElement("product").addText(rs.getString(3));
            }

            stmt = conn.prepareStatement(selectBeverages);
            stmt.setString(1, beverageName);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element line = toAppend.addElement("beverage");
                line.addElement("id").addText(rs.getString(1));
                line.addElement("size").addText(rs.getString(2));
                line.addElement("plu").addText(rs.getString(3));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getProductDetail(Element toHandle, Element toAppend) throws HandlerException {

        int product = HandlerUtils.getRequiredInteger(toHandle, "productId");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String selectProductInfo = "SELECT name FROM product WHERE id=?";
        String selectLines = "SELECT bar.name, system.systemId, line.lineIndex FROM line " +
                "LEFT JOIN bar ON line.bar = bar.id " +
                "LEFT JOIN system on line.system = system.id " +
                "WHERE line.product=? AND bar.location=? AND line.status <> 'RETIRED' ";
        String selectBevs = "SELECT beverage.name, beverage.plu, ingredient.ounces " +
                "FROM beverage LEFT join ingredient " +
                "  ON ingredient.beverage = beverage.id " +
                "WHERE ingredient.product=? AND beverage.location=?";

        try {
            stmt = conn.prepareStatement(selectProductInfo);
            stmt.setInt(1, product);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }

            stmt = conn.prepareStatement(selectLines);
            stmt.setInt(1, product);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();

            while (rs.next()) {
                Element line = toAppend.addElement("line");
                line.addElement("bar").addText(rs.getString(1));
                line.addElement("system").addText(rs.getString(2));
                line.addElement("index").addText(rs.getString(3));
            }
            stmt = conn.prepareStatement(selectBevs);
            stmt.setInt(1, product);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();

            while (rs.next()) {
                Element bev = toAppend.addElement("beverage");
                bev.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                bev.addElement("plu").addText(rs.getString(2));
                bev.addElement("ounces").addText(rs.getString(3));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getProductRequestsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element ProductE1 = toAppend.addElement("request");
            int colCount = 1;

            ProductE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("comment").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("userName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("userId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("locationId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("requestId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
        }
    }

    /** Retrieve a list of Product Requests
     *  Takes optional paramters for user ID and location ID.  If they are both
     *    provided, the disjunction (OR) of the two will be returned.
     *  Also takes a boolean parameter "showAll" which default to false.
     *    When false, it will only return OPEN requests
     *    Otherwise, it will return all requests except DELETED requests. Deleted
     *    requests will never be returned by this method.
     */
    private void getProductRequests(Element toHandle, Element toAppend) throws HandlerException {
        int user = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        boolean showAll = HandlerUtils.getOptionalBoolean(toHandle, "showAll", false);

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String where = " WHERE ";
        if (user > 0 && location > 0) {
            where += " (pr.location=? OR pr.user=?) AND ";
        } else if (user > 0) {
            where += " user=? AND ";
        } else if (location > 0) {
            where += " location=? AND ";
        }
        where += " pr.status" + (showAll ? "<>'deleted' " : "='open' ");

        String select =
                " SELECT pr.productName, pr.comment, pr.date, user.name, user.id, " +
                "        location.name, location.id, pr.status, pr.id " +
                " FROM productRequest AS pr " +
                " LEFT JOIN user ON pr.user = user.id " +
                " LEFT JOIN location ON pr.location = location.id " +
                where +
                " ORDER BY pr.date ";
        logger.debug("getProductRequest query is {" + select + "}");
        try {
            stmt = conn.prepareStatement(select);
            if (user > 0 && location > 0) {
                stmt.setInt(1, location);
                stmt.setInt(2, user);
            } else if (user > 0) {
                stmt.setInt(1, user);
            } else if (location > 0) {
                stmt.setInt(1, location);
            }
            rs = stmt.executeQuery();
            getProductRequestsXML(toAppend, rs);

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getSupplierRequestsXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element ProductE1 = toAppend.addElement("request");
            int colCount = 1;

            // " SELECT sr.type, sr.supplierName, sr.supplierId, sup.name, " +
            // "   sr.addrStreet, sr.addrCity, sr.addrState, sr.addrZip, " +
            // "   sr.comment, sr.date, user.name, user.id, " +
            // "   location.name, location.id, sr.status, sr.id " +

            ProductE1.addElement("requestType").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("newSupplierName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("existingSupplierId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("existingSupplierName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("addrStreet").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("addrCity").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("addrState").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("addrZip").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("comment").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("userName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("userId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("locationId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
            ProductE1.addElement("requestId").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
        }
    }

    /** Retrieve a list of Supplier Requests
     *  Takes optional parameters for user ID and location ID.  If they are both
     *    provided, the disjunction (OR) of the two will be returned.
     *  Also takes a boolean parameter "showAll" which default to false.
     *    When false, it will only return OPEN requests
     *    Otherwise, it will return all requests except DELETED requests. Deleted
     *    requests will never be returned by this method.
     */
    private void getSupplierRequests(Element toHandle, Element toAppend) throws HandlerException {
        int user = HandlerUtils.getOptionalInteger(toHandle, "userId");
        int location = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        boolean showAll = HandlerUtils.getOptionalBoolean(toHandle, "showAll", false);

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String where = " WHERE ";
        if (user > 0 && location > 0) {
            where += " (sr.location=? OR sr.user=?) AND ";
        } else if (user > 0) {
            where += " user=? AND ";
        } else if (location > 0) {
            where += " location=? AND ";
        }
        where += " sr.status" + (showAll ? "<>'deleted' " : "='open' ");

        String select =
                " SELECT sr.type, sr.supplierName, sr.supplierId, sup.name, " +
                "   sr.addrStreet, sr.addrCity, sr.addrState, sr.addrZip, " +
                "   sr.comment, sr.date, user.name, user.id, " +
                "   location.name, location.id, sr.status, sr.id " +
                " FROM supplierRequest AS sr " +
                " LEFT JOIN user ON sr.user = user.id " +
                " LEFT JOIN location ON sr.location = location.id " +
                " LEFT JOIN supplier sup ON sr.supplierId = sup.id " +
                where +
                " ORDER BY sr.date ";
        logger.debug("getSupplierRequest query is {" + select + "}");
        try {
            stmt = conn.prepareStatement(select);
            if (user > 0 && location > 0) {
                stmt.setInt(1, location);
                stmt.setInt(2, user);
            } else if (user > 0) {
                stmt.setInt(1, user);
            } else if (location > 0) {
                stmt.setInt(1, location);
            }
            rs = stmt.executeQuery();
            getSupplierRequestsXML(toAppend, rs);

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /**  Get productRequestNotifications for all users or a specific user.
     *   These alerts are for users that want an email notification when there
     *   are new Product Requests - AND - Supplier Requests.
     *
     *   Optional argment: <userId>  If provided, "single user mode" otherwise "all user mode"
     *
     *   All user mode:
     *   returns a set of <email> addresses for all the users that have requested notifications
     *   
     *   Single user mode:
     *   <email> the email address of the user
     *   <notify> 1 or 0, if the user has requested notification
     */
    private void getProductRequestNotifications(Element toHandle, Element toAppend) throws HandlerException {

        int userId = HandlerUtils.getOptionalInteger(toHandle, "userId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String allUsers = "SELECT DISTINCT email FROM user where notifyOnProductRequest=1";
        String singleUser = "SELECT email,notifyOnProductRequest FROM user WHERE id=? LIMIT 1";

        try {
            if (userId > 0) {
                //single user mode
                stmt = conn.prepareStatement(singleUser);
                stmt.setInt(1, userId);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    toAppend.addElement("notify").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                } else {
                    // user id not found
                }
            } else {
                stmt = conn.prepareStatement(allUsers);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getProductRequestNotification: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /**  Get all users who have requested location status updates
     *   
     *   args: none
     *   result:
     *   <email>address1@domain.com</email>
     *   <email>address2@domain.com</email>
     *   <email>...</email>
     *
     */
    private void getLocationStatusNotifications(Element toHandle, Element toAppend) throws HandlerException {

        String allUsers = "SELECT DISTINCT email FROM user where notifyOnLocationStatus=1";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(allUsers);
            rs = stmt.executeQuery();
            while (rs.next()) {
                toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error in getLocationStatusNotifications: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /**  Get all products ordered after a cutoff date or within X days (date takes priority
     */
    private void getRecentlyOrderedProducts(Element toHandle, Element toAppend) throws HandlerException {
        String cutoffDate = HandlerUtils.getOptionalString(toHandle, "date");
        int cutoffDays = HandlerUtils.getOptionalInteger(toHandle, "daysOld");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String dateCondition = "";
        if (cutoffDate != null) {
            dateCondition = " AND p.date>?";
        } else if (cutoffDays > 0) {
            dateCondition = " AND TO_DAYS(NOW())-TO_DAYS(p.date) <= ? ";
        }
        String getRecent =
                " SELECT DISTINCT pr.id, pr.name " +
                " FROM purchaseDetail d LEFT JOIN purchase p ON d.purchase=p.id " +
                "   LEFT JOIN product pr ON d.product = pr.id " +
                " WHERE p.location=? " + dateCondition;
        String getOnOrder =
                " SELECT d.product,pr.name,SUM(d.quantity) " +
                " FROM purchase p LEFT JOIN purchaseDetail d ON d.purchase=p.id " +
                " LEFT JOIN product pr ON d.product=pr.id " +
                " WHERE p.location=? AND p.status='OPEN' AND d.product IS NOT NULL " +
                " GROUP BY pr.id ";

        HashMap<Integer, String> productNames = new HashMap<Integer, String>();
        //Set<Integer> recentProducts = new HashSet<Integer>();
        HashMap<Integer, Integer> onOrder = new HashMap<Integer, Integer>();

        try {
            // get recently ordered products
            stmt = conn.prepareStatement(getRecent);
            stmt.setInt(1, location);
            if (cutoffDate != null) {
                stmt.setString(2, cutoffDate);
            } else if (cutoffDays > 0) {
                stmt.setInt(2, cutoffDays);
            }
            rs = stmt.executeQuery();
            while (rs.next()) {
                Integer productId = new Integer(rs.getInt(1));
                String productName = rs.getString(2);
                productNames.put(productId, productName);
                //recentProducts.add(productId);
            }

            // get pending orders
            stmt = conn.prepareStatement(getOnOrder);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Integer productId = new Integer(rs.getInt(1));
                String productName = rs.getString(2);
                Integer quantity = new Integer(rs.getInt(3));
                productNames.put(productId, productName);
                onOrder.put(productId, quantity);
            }

            //build the output XML
            for (Integer pkey : productNames.keySet()) {
                Element prEl = toAppend.addElement("product");
                prEl.addElement("productId").addText(String.valueOf(pkey));
                prEl.addElement("name").addText(String.valueOf(productNames.get(pkey)));
                int orderQty = 0;
                Integer checkQty = onOrder.get(pkey);
                if (checkQty != null) {
                    orderQty = checkQty.intValue();
                }
                prEl.addElement("orderQuantity").addText(String.valueOf(orderQty));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    private void getPurchases(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "location");
        int supplier = HandlerUtils.getOptionalInteger(toHandle, "supplier");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String getPurchase =
                " SELECT purchase.id, purchase.date, purchase.total, purchase.status, supplier.name, supplier.id FROM purchase " +
                " LEFT JOIN supplier ON supplier.id = purchase.supplier " +
                " WHERE purchase.location=? AND purchase.status <> 'CANCELED' ";

        if (supplier > 0) {
            getPurchase +=
                    " AND supplier.id = ? ";
        }

        getPurchase +=
                " ORDER BY purchase.date";
        try {
            stmt = conn.prepareStatement(getPurchase);
            stmt.setInt(1, location);
            if (supplier > 0) {
                stmt.setInt(2, supplier);
            }

            rs = stmt.executeQuery();

            while (rs.next()) {
                Element pur = toAppend.addElement("purchase");
                pur.addElement("orderNumber").addText(String.valueOf(rs.getInt(1)));
                pur.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                pur.addElement("total").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                pur.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                pur.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                pur.addElement("supplierId").addText(String.valueOf(rs.getInt(6)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /** Send an email of a single purchase order to a single address
     */
    private void emailPurchase(Element toHandle, Element toAppend) throws HandlerException {
        String email = HandlerUtils.getRequiredString(toHandle, "email");
        int purchase = HandlerUtils.getRequiredInteger(toHandle, "orderNumber");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String getPurchase =
                " SELECT supplier,date,total,status FROM purchase WHERE id=? AND location=? ";
        String getLocationDetails =
                " SELECT l.addrStreet, l.addrCity, l.addrState, l.addrZip, l.name, c.name " +
                " FROM location l LEFT JOIN customer c ON l.customer=c.id" +
                " WHERE l.id=?";
        String getDetails =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu FROM " +
                " purchaseDetail pd LEFT JOIN product pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getDetailsMisc =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu FROM " +
                " purchaseDetailMisc pd LEFT JOIN miscProduct pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getAddress =
                " SELECT s.name, sa.addrStreet, sa.addrCity, sa.addrState, sa.addrZip " +
                " FROM location l LEFT JOIN locationSupplier map ON l.id=map.location " +
                " LEFT JOIN supplierAddress sa ON map.address=sa.id " +
                " LEFT JOIN supplier s ON sa.supplier = s.id " +
                " WHERE l.id=? AND s.id=?";
        String getSupplier =
                " SELECT name FROM supplier WHERE id=? ";

        String emailTemplatePath = HandlerUtils.getSetting("email.templatePath");
        if ((emailTemplatePath == null) || "".equals(emailTemplatePath)) {
            emailTemplatePath = ".";
        }
        logger.debug("Packaging Email");

        try {
            logger.debug("Loading Template");
            TemplatedMessage poEmail =
                    new TemplatedMessage("Purchase Order",
                    emailTemplatePath,
                    "orderPrint");

            //logger.debug("Setting Template Fields to "+email+" #"+String.valueOf(purchase));
            poEmail.setSender("mailer@usbeveragenet.com");
            //logger.debug("*");
            poEmail.setRecipient(email);
            //logger.debug("*");
            poEmail.setField("ORDER_NUMBER", String.valueOf(purchase));

            //logger.debug("Connecting to Database");
            stmt = conn.prepareStatement(getPurchase);
            stmt.setInt(1, purchase);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                int supplier = rs.getInt(1);
                poEmail.setField("DATE", HandlerUtils.nullToEmpty(rs.getString(2)));
                //toAppend.addElement("totalPrice").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                //toAppend.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                //toAppend.addElement("supplierId").addText(String.valueOf(supplier));
                // get the supplier address IF the location has this supplier in its current list, otherwise just grab its name
                stmt = conn.prepareStatement(getAddress);
                stmt.setInt(1, location);
                stmt.setInt(2, supplier);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    //logger.debug("Setting Full Supplier Address");
                    poEmail.setField("SUPPLIER_NAME", HandlerUtils.nullToEmpty(rs.getString(1)));
                    poEmail.setField("SUPPLIER_ADDRESS1", String.valueOf(rs.getString(2)));
                    StringBuilder addr2 = new StringBuilder();
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(3)));
                    addr2.append(", ");
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(4)));
                    addr2.append(" ");
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(5)));
                    poEmail.setField("SUPPLIER_ADDRESS2", addr2.toString());
                } else {
                    // No supplier address at this location, just grab the name        
                    //logger.debug("Setting Partial Supplier Address");
                    stmt = conn.prepareStatement(getSupplier);
                    stmt.setInt(1, supplier);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        poEmail.setField("SUPPLIER_NAME", HandlerUtils.nullToEmpty(rs.getString(1)));
                        poEmail.setField("SUPPLIER_ADDRESS1", "");
                        poEmail.setField("SUPPLIER_ADDRESS2", "");
                    }
                }

                stmt = conn.prepareStatement(getLocationDetails);
                stmt.setInt(1, location);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    poEmail.setField("SHIPPING_ADDRESS1", String.valueOf(rs.getString(1)));
                    poEmail.setField("BILLING_ADDRESS1", String.valueOf(rs.getString(1)));
                    StringBuilder addr2 = new StringBuilder();

                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(2)));
                    addr2.append(", ");
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(3)));
                    addr2.append(" ");
                    addr2.append(HandlerUtils.nullToEmpty(rs.getString(4)));
                    poEmail.setField("BILLING_ADDRESS2", addr2.toString());
                    poEmail.setField("SHIPPING_ADDRESS2", addr2.toString());
                    poEmail.setField("LOCATION", HandlerUtils.nullToEmpty(rs.getString(5)));
                    poEmail.setField("CUSTOMER", HandlerUtils.nullToEmpty(rs.getString(6)));
                } else {
                    poEmail.setField("BILLING_ADDRESS1", "");
                    poEmail.setField("SHIPPING_ADDRESS1", "");
                    poEmail.setField("BILLING_ADDRESS2", "");
                    poEmail.setField("SHIPPING_ADDRESS2", "");
                }
                stmt = conn.prepareStatement(getDetails);
                stmt.setInt(1, purchase);
                rs = stmt.executeQuery();
                StringBuilder products = new StringBuilder();
                while (rs.next()) {
                    // logger.debug("Adding Draft Row");
                    products.append("<tr><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(4))); // PLU
                    products.append("</td><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Name
                    products.append("</td><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Quantity
                    products.append("</td><td /><td /></tr>");
                }
                poEmail.setField("DRAFT", products.toString());
                stmt = conn.prepareStatement(getDetailsMisc);
                stmt.setInt(1, purchase);
                rs = stmt.executeQuery();
                products = new StringBuilder();
                while (rs.next()) {
                    // logger.debug("Addng Nondraft Row");
                    products.append("<tr><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(4))); // PLU
                    products.append("</td><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(2))); // Name
                    products.append("</td><td>");
                    products.append(HandlerUtils.nullToEmpty(rs.getString(3))); // Quantity
                    products.append("</td><td /><td /></tr>");
                }
                poEmail.setField("NONDRAFT", products.toString());
            }
            logger.debug("Sending...");
            poEmail.send();
            logger.debug("Email sent successfully");

        } catch (SQLException sqle) {
            logger.dbError("Database error in emailPurchase: " + sqle.toString());
            throw new HandlerException(sqle);
        } catch (MailException me) {
            logger.debug("Error sending purchase message to " + email + ": " + me.toString());
            addErrorDetail(toAppend, "Error sending mail: " + me.toString());
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /** This method will return all the users that have requested email notification of
     * low-stock items, along with all the items at their locations that are low.
     * Takes no parameters; will return all users.
     */
    private void getLowStock(Element toHandle, Element toAppend) throws HandlerException {
        // a map from location ids to product-quantity maps
        Map<Integer, Map<Integer, Double>> stockCache = new HashMap<Integer, Map<Integer, Double>>();

        // a map from location ID to location name
        Map<Integer, String> locationNames = new HashMap<Integer, String>();

        // a map from a notification email address to a set of locationIds
        Map<String, Set<Integer>> users = new HashMap<String, Set<Integer>>();

        String selectUsers = " SELECT user.email, low.location " +
                " FROM lowStockNotification AS low LEFT JOIN user ON low.user=user.id " +
                " WHERE user.email IS NOT NULL AND user.email <>''";
        String selectLowStock = "SELECT product, qtyOnHand FROM inventory " +
                " WHERE location=? AND qtyOnHand < minimumQty";
        String selectName = "SELECT name FROM location WHERE id=? ";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        ProductMap prodMap = new ProductMap(conn);
        try {
            // 1. for each user, determine which locations he is checking stock on
            stmt = conn.prepareStatement(selectUsers);
            rs = stmt.executeQuery();
            while (rs.next()) {
                String email = rs.getString(1);
                Integer locId = new Integer(rs.getInt(2));
                Set<Integer> locs = users.get(email);
                if (locs == null) {
                    locs = new HashSet<Integer>();
                    users.put(email, locs);
                    logger.debug("Creating new email: " + email);
                }
                if (!locs.contains(locId)) {
                    locs.add(locId);
                    logger.debug("Adding loc# " + locId + "  for email " + email);
                }
            }

            // 2. Create the notification element for each email address (user)
            Set<String> keys = users.keySet();
            for (String address : keys) {
                logger.debug("Creating notification for " + address);
                Set<Integer> locs = users.get(address);
                Element notification = null;
                //add the low-stock at each location
                for (Integer loc : locs) {
                    //lookup the low-stock for this location
                    Map<Integer, Double> lowStock = stockCache.get(loc);
                    if (lowStock == null) { //we need to go to the database
                        lowStock = new HashMap<Integer, Double>();
                        stmt = conn.prepareStatement(selectLowStock);
                        stmt.setInt(1, loc.intValue());
                        rs = stmt.executeQuery();
                        while (rs.next()) {
                            Integer product = new Integer(rs.getInt(1));
                            Double quantity = new Double(rs.getDouble(2));
                            lowStock.put(product, quantity);
                        }
                        stockCache.put(loc, lowStock);
                        logger.debug("Created new lowStock for loc#" + loc.toString() + ": " + lowStock.size() + " item(s)");
                    } else {
                        logger.debug("Retrieved cached lowStock for loc#" + loc.toString());
                    }
                    // now we have a non-null lowStock from db or cache
                    Element locationEl = null;
                    Set<Integer> prodKeys = lowStock.keySet();
                    for (Integer prod : prodKeys) {
                        //we may need to initialize the notification element
                        if (notification == null) {
                            notification = toAppend.addElement("notification");
                            notification.addElement("email").addText(address);
                        }
                        //we may need to initialize the location element
                        if (locationEl == null) {
                            locationEl = notification.addElement("location");
                            locationEl.addElement("locationId").addText(loc.toString());
                            String name = locationNames.get(loc);
                            if (name == null) {
                                stmt = conn.prepareStatement(selectName);
                                stmt.setInt(1, loc.intValue());
                                rs = stmt.executeQuery();
                                if (rs.next()) {
                                    name = rs.getString(1);
                                    locationNames.put(loc, name);
                                    logger.debug("Put " + name + " in cache");
                                } else {
                                    name = "Unknown Location";
                                    logger.generalWarning("Unknown location in getLowStock: " + loc.toString());
                                }
                            } else {
                                logger.debug("Retrieved " + name + " from cache");
                            }
                            locationEl.addElement("locationName").addText(name);
                        }
                        Element prodEl = locationEl.addElement("product");
                        prodEl.addElement("productId").addText(prod.toString());
                        prodEl.addElement("productName").addText(prodMap.getProduct(prod));
                        prodEl.addElement("quantity").addText(lowStock.get(prod).toString());
                    }
                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getLowStock: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /** Returns a list of the locations for which a user has requested low-stock notifications
     *  Will also return that users email address, and if he has location-status updates enabled
     */
    private void getLowStockAlerts(Element toHandle, Element toAppend) throws HandlerException {
        int user = HandlerUtils.getRequiredInteger(toHandle, "userId");
        String selectAlerts = "SELECT location FROM lowStockNotification WHERE user=?";
        String selectEmail = "SELECT email,notifyOnLocationStatus FROM user WHERE id=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(selectEmail);
            stmt.setInt(1, user);
            rs = stmt.executeQuery();
            String email = "";
            if (rs.next()) {
                email = rs.getString(1);
            }
            toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(email));
            toAppend.addElement("notifyStatus").addText(String.valueOf(rs.getInt(2)));
            stmt = conn.prepareStatement(selectAlerts);
            stmt.setInt(1, user);
            rs = stmt.executeQuery();
            while (rs.next()) {
                toAppend.addElement("location").addText(String.valueOf(rs.getInt(1)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /** Creates a list of all the lines cleaned at a particular location on a particular day
     *  This list will include the name of the user that did the cleaning, the line that was cleaned, 
     *  and the time.  
     *  <locationId>
     *  <reportDate>
     *
     *  returns
     *
     *  <cleaning>
     *    <user>Joe Smith
     *    <lineProduct>Bass Ale
     *    <timestamp>2007-03-01 12:54
     *    <systemId>1  (0 indexed)
     *    <lineNumber>1 (1 indexed)
     *      
     */
    private void getLineCleaningHistory(Element toHandle, Element toAppend) throws HandlerException {
        int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        DateParameter reportDate = new DateParameter(HandlerUtils.getRequiredString(toHandle, "reportDate"));

        String query =
                " SELECT u.name, pr.name, h.timestamp, s.systemId, l.lineIndex, rr.startDate, rr.endDate, rr.value " +
                " FROM task t LEFT JOIN userHistory h ON t.id=h.task " +
                " LEFT JOIN user u ON h.user=u.id " +
                " LEFT JOIN line l ON h.target=l.id " +
                " LEFT JOIN removedReading rr ON rr.line = l.id " +
                " LEFT JOIN product pr ON l.product=pr.id " +
                " LEFT JOIN system s ON l.system=s.id " +
                " WHERE t.id=43 AND h.location=? " +
                " AND HOUR(h.timestamp) = HOUR(rr.date) " +
                " AND h.timestamp BETWEEN ? AND ? AND rr.date BETWEEN ? AND ?";


        if (!reportDate.isValid()) {
            logger.debug("Aborted getLineCleaningHistory, invalid date '" + reportDate + "'");
            addErrorDetail(toAppend, "Invalid Date");
        } else {
            String startDate = reportDate.toString() + " 00:00";
            String endDate = reportDate.toString() + " 23:59";

            PreparedStatement stmt = null;
            ResultSet rs = null;

            try {
                stmt = conn.prepareStatement(query);
                stmt.setInt(1, locationId);
                stmt.setString(2, startDate);
                stmt.setString(3, endDate);
                stmt.setString(4, startDate);
                stmt.setString(5, endDate);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    int i = 1;
                    Element el = toAppend.addElement("cleaning");
                    el.addElement("user").addText(HandlerUtils.nullToString(rs.getString(i++), "Unknown User"));
                    el.addElement("lineProduct").addText(HandlerUtils.nullToString(rs.getString(i++), "Unknown Product"));
                    el.addElement("timestamp").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    el.addElement("systemId").addText(String.valueOf(rs.getInt(i++)));
                    el.addElement("lineNumber").addText(String.valueOf(1 + rs.getInt(i++)));
                    el.addElement("startDate").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    el.addElement("endDate").addText(HandlerUtils.nullToEmpty(rs.getString(i++)));
                    el.addElement("qty").addText(String.valueOf(rs.getDouble(i++)));

                }
            } catch (SQLException sqle) {
                logger.dbError("Database error in getLineCleaningHistory: " + sqle.toString());
                throw new HandlerException(sqle);
            } finally {
                close(stmt);
                close(rs);
            }
        }
    }

    /** By line id or location */
    private void getLastReading(Element toHandle, Element toAppend) throws HandlerException {
        int line = HandlerUtils.getOptionalInteger(toHandle, "lineId");
        int location = HandlerUtils.getOptionalInteger(toHandle, "location");
        int paramCount = 0;
        if (line > 0) {
            paramCount++;
        }
        if (location > 0) {
            paramCount++;
        }
        if (paramCount > 1) {
            throw new HandlerException("Passed too many parameters to getLastReading");
        } else if (paramCount == 0) {
            throw new HandlerException("Passed too few paramters to getLastReading");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String byLine = "SELECT date FROM reading WHERE line = ? ORDER BY date DESC LIMIT 1";
        String byLocation = "SELECT reading.date FROM system " +
                " LEFT JOIN line ON line.system = system.id " +
                " LEFT JOIN reading ON reading.line = line.id " +
                " WHERE system.location=? ORDER BY reading.date DESC LIMIT 1";

        String powerupByLine =
                " SELECT lo.picoPowerup FROM location lo " +
                " LEFT JOIN system s ON s.location=lo.id " +
                " LEFT JOIN line ln ON ln.system=s.id " +
                " WHERE ln.id=?";
        String locationQuick = "SELECT lastPoured,picoPowerup FROM location WHERE id=?";


        try {

            if (location > 0) {
                stmt = conn.prepareStatement(locationQuick);
                stmt.setInt(1, location);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    toAppend.addElement("powerup").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                }
            } else {
                stmt = conn.prepareStatement(byLine);
                stmt.setInt(1, line);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    toAppend.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                }

                stmt = conn.prepareStatement(powerupByLine);
                stmt.setInt(1, line);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    toAppend.addElement("powerup").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /** By location */
    private void getGatewayInfo(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "location");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String sql = "SELECT lastSold, processorName, processorVersion, gatewayVersion " +
                "FROM location WHERE id=?";

        try {
            stmt = conn.prepareStatement(sql);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("lastSold").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                toAppend.addElement("processorName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("processorVersion").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                toAppend.addElement("gatewayVersion").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /** Get the details of a purchase number, and lookup the supplier address that this location uses
     *  <orderNumber> 0000
     *  <locationId> 000
     *
     *  returns:
     *
     *  <date>
     *  <totalPrice>
     *  <status>
     *  <supplierId>
     *  <supplierName>
     *  <supplierAddress> 1|0   //if the suppler address is set up
     *  OPT<supplierStreet>
     *  OPT<supplierCity>
     *  OPT<supplierState>
     *  OPT<supplierZip>
     *  <product >
     *      <name>
     *      <productId>
     *      <quantity>
     *      <plu>
     *  </product>
     *  <product>...</>
     *  <product>...</>
     */
    private void getPurchaseDetail(Element toHandle, Element toAppend) throws HandlerException {
        int purchase = HandlerUtils.getRequiredInteger(toHandle, "orderNumber");
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        String getPurchase =
                " SELECT supplier,date,total,status FROM purchase WHERE id=? AND location=? ";
        String getDetails =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu FROM " +
                " purchaseDetail pd LEFT JOIN product pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getDetailsMisc =
                " SELECT pr.id, pr.name, pd.quantity, pd.productPlu FROM " +
                " purchaseDetailMisc pd LEFT JOIN miscProduct pr ON pd.product=pr.id " +
                " WHERE pd.purchase=?";
        String getAddress =
                " SELECT s.name, sa.addrStreet, sa.addrCity, sa.addrState, sa.addrZip " +
                " FROM location l LEFT JOIN locationSupplier map ON l.id=map.location " +
                " LEFT JOIN supplierAddress sa ON map.address=sa.id " +
                " LEFT JOIN supplier s ON sa.supplier = s.id " +
                " WHERE l.id=? AND s.id=?";
        String getSupplier =
                " SELECT name FROM supplier WHERE id=? ";

        try {
            stmt = conn.prepareStatement(getPurchase);
            stmt.setInt(1, purchase);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                int supplier = rs.getInt(1);
                toAppend.addElement("date").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                toAppend.addElement("totalPrice").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                toAppend.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                toAppend.addElement("supplierId").addText(String.valueOf(supplier));
                // get the supplier address IF the location has this supplier in its current list, otherwise just grab its name
                stmt = conn.prepareStatement(getAddress);
                stmt.setInt(1, location);
                stmt.setInt(2, supplier);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    toAppend.addElement("supplierAddress").addText(String.valueOf(1));
                    toAppend.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    toAppend.addElement("supplierStreet").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    toAppend.addElement("supplierCity").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    toAppend.addElement("supplierState").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                    toAppend.addElement("supplierZip").addText(HandlerUtils.nullToEmpty(rs.getString(5)));
                } else {
                    // No supplier address at this location, just grab the name
                    toAppend.addElement("supplierAddress").addText(String.valueOf(0));
                    stmt = conn.prepareStatement(getSupplier);
                    stmt.setInt(1, supplier);
                    rs = stmt.executeQuery();
                    if (rs.next()) {
                        toAppend.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    }
                }
                stmt = conn.prepareStatement(getDetails);
                stmt.setInt(1, purchase);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element product = toAppend.addElement("product");
                    product.addElement("productId").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    product.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    product.addElement("quantity").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    product.addElement("plu").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                }
                stmt = conn.prepareStatement(getDetailsMisc);
                stmt.setInt(1, purchase);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    Element product = toAppend.addElement("miscProduct");
                    product.addElement("productId").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                    product.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                    product.addElement("quantity").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
                    product.addElement("plu").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getPurchaseDetail: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    private void getInventoryXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element InventoryE1 = toAppend.addElement("inventoryItem");

            InventoryE1.addElement("inventoryId").addText(String.valueOf(rs.getInt(1)));
            InventoryE1.addElement("productId").addText(String.valueOf(rs.getInt(2)));
            InventoryE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            InventoryE1.addElement("locationId").addText(String.valueOf(rs.getInt(4)));
            InventoryE1.addElement("qtyOnHand").addText(String.valueOf(rs.getDouble(5)));
            InventoryE1.addElement("minimumQty").addText(String.valueOf(rs.getDouble(6)));
            InventoryE1.addElement("pluCode").addText(HandlerUtils.nullToEmpty(rs.getString(7)));
            InventoryE1.addElement("qtyToOrder").addText(String.valueOf(rs.getInt(8)));
            InventoryE1.addElement("supplierName").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
            InventoryE1.addElement("supplierId").addText(String.valueOf(rs.getInt(10)));
            InventoryE1.addElement("kegSize").addText(String.valueOf(rs.getInt(11)));
            InventoryE1.addElement("brixWater").addText(String.valueOf(rs.getInt(12)));
            InventoryE1.addElement("brixSyrup").addText(String.valueOf(rs.getInt(13)));
        }

    }

    private void getInventory(Element toHandle, Element toAppend) throws HandlerException {

        int refLocationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        PreparedStatement stmt = null;
        ResultSet rs = null;


        try {
            if (refLocationId >= 0) {
                if (!checkForeignKey("location", "id", refLocationId)) {
                    throw new HandlerException("Foreign Key Not found : location " + refLocationId);
                }
                String selectByLocationId = "SELECT i.id, i.product, p.name, " +
                        " i.location, i.qtyOnHand, i.minimumQty, i.plu, i.qtyToHave," +
                        " sup.name, sup.id, i.kegSize, i.brixWater, i.brixSyrup " +
                        " FROM product AS p LEFT JOIN inventory AS i ON p.id = i.product " +
                        " LEFT JOIN supplier AS sup ON i.supplier = sup.id " +
                        " WHERE i.location = ?";
                stmt = conn.prepareStatement(selectByLocationId);
                stmt.setInt(1, refLocationId);
                rs = stmt.executeQuery();
                getInventoryXML(toAppend, rs);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getLineXML(Element toAppend, ResultSet rs) throws SQLException {
        while (rs.next()) {
            Element lineE1 = toAppend.addElement("line");

            lineE1.addElement("lineId").addText(String.valueOf(rs.getInt(1)));
            lineE1.addElement("lineIndex").addText(String.valueOf(rs.getInt(2)));
            lineE1.addElement("productId").addText(String.valueOf(rs.getInt(3)));
            lineE1.addElement("productName").addText(HandlerUtils.nullToEmpty(rs.getString(4)));
            lineE1.addElement("systemId").addText(String.valueOf(rs.getInt(5)));
            lineE1.addElement("barId").addText(String.valueOf(rs.getInt(6)));
            lineE1.addElement("ouncesPoured").addText(String.valueOf(rs.getDouble(7)));
            lineE1.addElement("unit").addText(String.valueOf(rs.getDouble(8)));
            lineE1.addElement("status").addText(HandlerUtils.nullToEmpty(rs.getString(9)));
            lineE1.addElement("lastStatusChange").addText(HandlerUtils.nullToEmpty(rs.getString(10)));
            lineE1.addElement("systemIndex").addText(String.valueOf(rs.getInt(11)));
            lineE1.addElement("stationId").addText(String.valueOf(rs.getInt(12)));
            lineE1.addElement("kegLine").addText(String.valueOf(rs.getInt(13)));
        }

    }

    private void getLine(Element toHandle, Element toAppend) throws HandlerException {

        int id = HandlerUtils.getRequiredInteger(toHandle, "lineId");

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            String selectByLineId = "SELECT l.id, l.lineIndex, l.product, " +
                    "p.name, l.system, l.bar, l.ouncesPoured, l.unit, l.status, " +
                    "l.statusChange, -1 FROM line AS l LEFT JOIN product AS p " +
                    "ON p.id = l.product WHERE l.id = ?";
            stmt = conn.prepareStatement(selectByLineId);
            stmt.setInt(1, id);
            rs = stmt.executeQuery();
            getLineXML(toAppend, rs);
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    private void getCurrentLines(Element toHandle, Element toAppend)
            throws HandlerException {

        int lineId = HandlerUtils.getOptionalInteger(toHandle, "lineId");
        int systemId = HandlerUtils.getOptionalInteger(toHandle, "systemId");
        int zoneId = HandlerUtils.getOptionalInteger(toHandle, "zoneId");
        int barId = HandlerUtils.getOptionalInteger(toHandle, "barId");
        int stationId = HandlerUtils.getOptionalInteger(toHandle, "stationId");
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        String getRetiredStr = HandlerUtils.getOptionalString(toHandle, "getRetired");
        boolean getRetired = !("true".equalsIgnoreCase(getRetiredStr));

        int paramsSet = 0;
        if (lineId >= 0) {
            paramsSet++;
        }
        if (systemId >= 0) {
            paramsSet++;
        }
        if (zoneId >= 0) {
            paramsSet++;
        }
        if (barId >= 0) {
            paramsSet++;
        }
        if (stationId >= 0) {
            paramsSet++;
        }
        if (locationId >= 0) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one of the following parameters " +
                    "can be set for getCurrentLines: lineId systemId barId " +
                    "locationId");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {

            if (lineId >= 0) {
                if (!checkForeignKey("line", "id", lineId)) {
                    throw new HandlerException("Foreign Key Not found : " +
                            "line " + lineId);
                }
                String selectBySystemId = "SELECT l.id, l.lineIndex, l.product, " +
                        "p.name, l.system, l.bar, l.ouncesPoured, l.unit, l.status, " +
                        "l.statusChange, -1, l.station, l.kegLine FROM line as l LEFT JOIN product AS p " +
                        "ON p.id = l.product WHERE l.id = ?" +
                        (getRetired ? "" : " AND l.status <> ?");
                stmt = conn.prepareStatement(selectBySystemId);
                stmt.setInt(1, lineId);
                if (!getRetired) {
                    stmt.setString(2, "RETIRED");
                }
                rs = stmt.executeQuery();

                getLineXML(toAppend, rs);
            } else if (systemId >= 0) {
                if (!checkForeignKey("system", "id", systemId)) {
                    throw new HandlerException("Foreign Key Not found : " +
                            "system " + systemId);
                }
                String selectBySystemId = "SELECT l.id, l.lineIndex, l.product, " +
                        "p.name, l.system, l.bar, l.ouncesPoured, l.unit, l.status, " +
                        "l.statusChange, -1, l.station, l.kegLine FROM line as l LEFT JOIN product AS p " +
                        "ON p.id = l.product WHERE l.system = ?" +
                        (getRetired ? "" : " AND l.status <> ?");
                stmt = conn.prepareStatement(selectBySystemId);
                stmt.setInt(1, systemId);
                if (!getRetired) {
                    stmt.setString(2, "RETIRED");
                }
                rs = stmt.executeQuery();

                getLineXML(toAppend, rs);
            } else if (zoneId >= 0) {
                if (!checkForeignKey("zone", "id", zoneId)) {
                    throw new HandlerException("Foreign Key Not found : " +
                            "zone " + zoneId);
                }
                String selectByZoneId = " SELECT l.id, l.lineIndex, l.product, " +
                        " p.name, l.system, l.bar, l.ouncesPoured, l.unit, l.status, " +
                        " l.statusChange, s.systemId, l.station, l.kegLine FROM line AS l LEFT JOIN product AS p " +
                        " ON p.id = l.product LEFT JOIN bar b on b.id = l.bar LEFT JOIN zone z on z.id = b.zone " +
                        " LEFT JOIN system s ON s.id = l.system WHERE z.id = ?" +
                        (getRetired ? "" : " AND l.status <> ?");
                stmt = conn.prepareStatement(selectByZoneId);
                stmt.setInt(1, zoneId);
                if (!getRetired) {
                    stmt.setString(2, "RETIRED");
                }
                rs = stmt.executeQuery();

                getLineXML(toAppend, rs);
            } else if (barId >= 0) {
                if (!checkForeignKey("bar", "id", barId)) {
                    throw new HandlerException("Foreign Key Not found : " +
                            "bar " + barId);
                }
                String selectByBarId = "SELECT l.id, l.lineIndex, l.product, " +
                        "p.name, l.system, l.bar, l.ouncesPoured, l.unit, l.status, " +
                        "l.statusChange, s.systemId, l.station, l.kegLine FROM line AS l LEFT JOIN product AS p " +
                        "ON p.id = l.product LEFT JOIN system s ON s.id = l.system WHERE l.bar = ?" +
                        (getRetired ? "" : " AND l.status <> ?");
                stmt = conn.prepareStatement(selectByBarId);
                stmt.setInt(1, barId);
                if (!getRetired) {
                    stmt.setString(2, "RETIRED");
                }
                rs = stmt.executeQuery();

                getLineXML(toAppend, rs);
            } else if (stationId >= 0) {
                if (!checkForeignKey("station", "id", stationId)) {
                    throw new HandlerException("Foreign Key Not found : " +
                            "station " + stationId);
                }
                String selectByStationId = "SELECT l.id, l.lineIndex, l.product, " +
                        "p.name, l.system, l.bar, l.ouncesPoured, l.unit, l.status, " +
                        "l.statusChange, s.systemId, l.station, l.kegLine FROM line AS l LEFT JOIN product AS p " +
                        "ON p.id = l.product LEFT JOIN system s ON s.id = l.system WHERE l.station = ?" +
                        (getRetired ? "" : " AND l.status <> ?");
                stmt = conn.prepareStatement(selectByStationId);
                stmt.setInt(1, stationId);
                if (!getRetired) {
                    stmt.setString(2, "RETIRED");
                }
                rs = stmt.executeQuery();

                getLineXML(toAppend, rs);
            } else if (locationId >= 0) {
                if (!checkForeignKey("location", "id", locationId)) {
                    throw new HandlerException("Foreign Key Not found : " +
                            "location " + locationId);
                }
                String selectByLocationId = "SELECT l.id, l.lineIndex, l.product, " +
                        " p.name, l.system, l.bar, l.ouncesPoured, l.unit, l.status, " +
                        " l.statusChange, system.systemId, l.station, l.kegLine FROM line AS l " +
                        " LEFT JOIN product AS p ON p.id = l.product " +
                        " LEFT JOIN bar ON l.bar = bar.id " +
                        " LEFT JOIN system ON l.system = system.id " +
                        " WHERE system.location = ?" +
                        (getRetired ? "" : " AND l.status <> ?");
                stmt = conn.prepareStatement(selectByLocationId);
                stmt.setInt(1, locationId);
                if (!getRetired) {
                    stmt.setString(2, "RETIRED");
                }
                rs = stmt.executeQuery();

                getLineXML(toAppend, rs);
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** Takes a list of products, presumably for placing an order, and adds the quicksell id.
     * If the product does not have a quicksell id, it will not be returned.  Optionally,
     * quantities may be passed along and will be returned along with the quicksell result
     *
     * @deprecated Quicksell ID is no longer used
     */
    private void lookupQuicksell(Element toHandle, Element toAppend)
            throws HandlerException {
        String select = "SELECT qid FROM product WHERE id=?";
        PreparedStatement stmt = null;
        ResultSet rs = null;

        Iterator i = toHandle.elementIterator("product");
        try {
            while (i.hasNext()) {
                Element item = (Element) i.next();
                stmt = conn.prepareStatement(select);
                int usbnId = HandlerUtils.getRequiredInteger(item, "id");
                stmt.setInt(1, usbnId);
                rs = stmt.executeQuery();
                if (rs.next()) {
                    int quicksellId = rs.getInt(1);
                    if (quicksellId > 0) {
                        Element append = toAppend.addElement("product");
                        append.addElement("quicksellId").addText(String.valueOf(quicksellId));
                        append.addElement("usbnId").addText(String.valueOf(usbnId));
                        int qty = HandlerUtils.getOptionalInteger(item, "quantity");
                        if (qty > 0) {
                            append.addElement("quantity").addText(String.valueOf(qty));
                        }
                        String price = HandlerUtils.getOptionalString(item, "price");
                        if (price != null && !price.equals("")) {
                            append.addElement("price").addText(price);
                        }
                        String plu = HandlerUtils.getOptionalString(item, "plu");
                        if (plu != null && !plu.equals("")) {
                            append.addElement("plu").addText(plu);
                        }
                    }
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }

    /**  Obtain a list of the user-defined beverage sizes for a location
     *
     *  required arguments:
     *  <locationId>
     *
     *  returns:
     *  <size>
     *    <id>int</id>
     *    <name>String</name>
     *    <ounces>00.0</ounces>
     *  </size>
     *  <size>...</size>
     *
     */
    private void getBeverageSizes(Element toHandle, Element toAppend)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        String select = "SELECT id,name,ounces FROM beverageSize WHERE location=?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(select);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element size = toAppend.addElement("size");
                size.addElement("id").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                size.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
                size.addElement("ounces").addText(HandlerUtils.nullToEmpty(rs.getString(3)));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error in getBeverageSizes: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }

    }

    /**  Gets all beverages at a location
     *  This method now has an optional 'barId' param 
     *  If this is set, then only beverage matching this bar will be returned.  If this
     *  field is NOT set, then all beverages will be returned, regardless if they
     *  are associated with a specific bar or null
     *
     *  BarId 'b' supplied   =  Only beverages of bar 'b'
     *  BarId 'b' null       =  All beverages, including bar=null and bar='x'
     */
    private void getBeverages(Element toHandle, Element toAppend)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int barId = HandlerUtils.getOptionalInteger(toHandle, "barId");

        String selectBeverages = "SELECT name,plu,id,simple FROM beverage WHERE location=? " + (barId > 0 ? " AND bar=?" : "");
        String selectIngredients = "SELECT product.name, product.id, ingredient.ounces " +
                "FROM ingredient LEFT JOIN product on ingredient.product = product.id " +
                "WHERE ingredient.beverage=?";


        PreparedStatement stmt = null;
        ResultSet bev = null;
        ResultSet ing = null;

        try {
            stmt = conn.prepareStatement(selectBeverages);
            stmt.setInt(1, location);
            if (barId > 0) {
                stmt.setInt(2, barId);
            }
            bev = stmt.executeQuery();
            while (bev.next()) {
                Element beverage = toAppend.addElement("beverage");
                beverage.addElement("name").addText(HandlerUtils.nullToEmpty(bev.getString(1)));
                beverage.addElement("plu").addText(HandlerUtils.nullToEmpty(bev.getString(2)));
                beverage.addElement("simple").addText(HandlerUtils.nullToEmpty(bev.getString(4)));
                stmt = conn.prepareStatement(selectIngredients);
                stmt.setInt(1, bev.getInt(3));
                ing = stmt.executeQuery();
                while (ing.next()) {
                    Element ingredient = beverage.addElement("ingredient");
                    ingredient.addElement("name").addText(HandlerUtils.nullToEmpty(ing.getString(1)));
                    ingredient.addElement("id").addText(HandlerUtils.nullToEmpty(ing.getString(2)));
                    ingredient.addElement("ounces").addText(HandlerUtils.nullToEmpty(ing.getString(3)));

                }
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(ing);
            close(bev);
            close(stmt);
        }


    }

    /**  
     *   1. Suppliers:  How many suppliers are associated with this location
     *          warnings:   A. products in inventory that reference a supplier that doesn't exist
     *                      B. Addresses that have been deemed inactive
     *   2. Inventory:  How many products in inventory
     *          warnings:   A. Active lines that reference products not in inv
     *                      B. Beverages reference products not in inv
     *   3. Draft Lines: How many systems / lines
     *          warnings:   A. Lines that are pouring the same product
     *                      B. Products in inv that are not being poured
     *   4. Beverages: How many beverages
     *          warnings:   A. Products in inventory that aren't in beverages
     *
     *  Warning fall into three severity categories.
     *  Warning 1 - Mild, doesn't need to be corrected, could be correct anyways.
     *      Example:  Two lines are pouring the same product
     *  Warning 2 - Normal, indicates an inconsistency, should be corrected, but won't cause any problems.
     *      Example:  Beverages containing products not in inventory.
     *  Warning 3 - Severe, should be correct immediately.  May cause further problems if unchecked
     *      Example:  Draft line pouring a product not in inventory.
     */
    private void getSetupInfo(Element toHandle, Element toAppend)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        String supCheck = "SELECT COUNT(DISTINCT id) FROM locationSupplier WHERE location=?";
        String invCheck = "SELECT COUNT(DISTINCT id) FROM inventory WHERE location=?";
        String lineCheck = "SELECT COUNT(DISTINCT line.id), COUNT(DISTINCT system.id) FROM line " +
                " LEFT JOIN system ON line.system = system.id " +
                " WHERE system.location=? AND line.status='RUNNING'";
        String beverageCheck = "SELECT COUNT(DISTINCT id) FROM beverage WHERE location=?";
        String nondraftCheck = "SELECT COUNT(DISTINCT id) FROM miscProduct WHERE location=? AND active=1";

        // TODO:  Supplier Warnng Checks!
        // TODO:  Nondraft Warning Checks

        // Checks for BEVERAGES that contain products that AREN'T in INVENTORY (Sev 2)
        //    Recommended fix is to add this product to inventory OR delete the beverage
        String invBevWarning = //(location, location) returns (productId, beverageName)
                " SELECT ing.product, bev.name, bev.id " +
                " FROM ingredient AS ing LEFT JOIN beverage AS bev ON ing.beverage = bev.id" +
                " WHERE bev.location=? AND " +
                " ing.product NOT IN " +
                "   (SELECT inventory.product " +
                "    FROM inventory " +
                "    WHERE inventory.location=? " +
                "   ) ";

        // Checks for running LINES pouring products that AREN'T in INVENTORY (Sev 3)
        // recommended fix is to add the product to inventory
        String invLineWarning = //(location, location) returns (productId)
                " SELECT line.product " +
                " FROM line LEFT JOIN system ON line.system = system.id " +
                " WHERE system.location=? AND line.status='RUNNING' AND " +
                " line.product NOT IN " +
                "   (SELECT inventory.product " +
                "    FROM inventory " +
                "    WHERE inventory.location=? " +
                "   ) ";

        // Checks for draft lines that are pouring the same product (Sev 1)
        // recommended fix: none (S1)
        String lineDuplicateWarning = // (location) returns (productId, lineCount)
                " SELECT line.product, count(*) AS lineCount " +
                " FROM line LEFT JOIN system ON line.system = system.id " +
                " WHERE system.location=? AND line.product >0 AND line.status='RUNNING' " +
                " GROUP BY product HAVING lineCount > 1";

        // Checks for items in inventory that are not being poured.   (Sev 1)
        // recommended fix: none (S1)
        String lineInvWarning = // (location,location) returns (productId)
                " SELECT inv.product " +
                " FROM inventory AS inv " +
                " WHERE inv.location=? AND " +
                " inv.product NOT IN " +
                "   (SELECT line.product " +
                "    FROM line LEFT JOIN system ON line.system = system.id " +
                "    WHERE system.location=? AND line.status <> 'RETIRED' " +
                "   ) ";

        // Checks for INVENTORY items without any BEVERAGES (Sev 1)
        // recommended fix: none (S1)
        String bevInvWarning = // (location,location) returns (productId)
                " SELECT inv.product " +
                " FROM inventory AS inv " +
                " WHERE inv.location=? AND " +
                " inv.product NOT IN " +
                "   (SELECT distinct ing.product " +
                "    FROM ingredient AS ing " +
                "    LEFT JOIN beverage AS bev ON ing.beverage = bev.id " +
                "    WHERE bev.location=?" +
                "   ) ";

        /* Other check ideas:  Lines paused for over X days (3?)
         */


        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {

            //First do the basic counts:

            stmt = conn.prepareStatement(supCheck);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("suppliers").addText(String.valueOf(rs.getInt(1)));
            }

            stmt = conn.prepareStatement(invCheck);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("invProducts").addText(String.valueOf(rs.getInt(1)));
            }

            stmt = conn.prepareStatement(lineCheck);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("draftLines").addText(String.valueOf(rs.getInt(1)));
                toAppend.addElement("systems").addText(String.valueOf(rs.getInt(2)));
            }

            stmt = conn.prepareStatement(beverageCheck);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("beverages").addText(String.valueOf(rs.getInt(1)));
            }

            stmt = conn.prepareStatement(nondraftCheck);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            if (rs.next()) {
                toAppend.addElement("nondraft").addText(String.valueOf(rs.getInt(1)));
            }

            //Set up a product map
            ProductMap nameLookup = new ProductMap(conn);

            //Do warnings
            stmt = conn.prepareStatement(invBevWarning);
            stmt.setInt(1, location);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("2");
                warnEl.addElement("warningId").addText("10");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                warnEl.addElement("beverageId").addText(String.valueOf(rs.getInt(3)));
                String detail = nameLookup.getProduct(rs.getInt(1)) + " isn't in inventory, but is " +
                        " used in beverage " + rs.getString(2);
                warnEl.addElement("detail").addText(detail);
            }
            logger.debug("invBevWarning check complete");

            stmt = conn.prepareStatement(invLineWarning);
            stmt.setInt(1, location);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("3");
                warnEl.addElement("warningId").addText("11");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                String detail = nameLookup.getProduct(rs.getInt(1)) + " is on a draft line, but not in inventory";
                warnEl.addElement("detail").addText(detail);
            }
            logger.debug("invLineWarning check complete");

            stmt = conn.prepareStatement(lineDuplicateWarning);
            stmt.setInt(1, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("1");
                warnEl.addElement("warningId").addText("12");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                warnEl.addElement("lineCount").addText(String.valueOf(rs.getInt(2)));
                String detail = rs.getInt(2) + " draft lines are pouring " + nameLookup.getProduct(rs.getInt(1));
                warnEl.addElement("detail").addText(detail);
            }
            logger.debug("lineDuplicateWarning check complete");

            stmt = conn.prepareStatement(lineInvWarning);
            stmt.setInt(1, location);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("1");
                warnEl.addElement("warningId").addText("13");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                String detail = nameLookup.getProduct(rs.getInt(1)) + " is in inv but has no draft line.";
                warnEl.addElement("detail").addText(detail);
            }
            logger.debug("lineInvWarning check complete");

            stmt = conn.prepareStatement(bevInvWarning);
            stmt.setInt(1, location);
            stmt.setInt(2, location);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element warnEl = toAppend.addElement("warning");
                warnEl.addElement("severity").addText("1");
                warnEl.addElement("warningId").addText("14");
                warnEl.addElement("productId").addText(String.valueOf(rs.getInt(1)));
                String detail = nameLookup.getProduct(rs.getInt(1)) + " is in inv but has no associated beverages.";
                warnEl.addElement("detail").addText(detail);
            }
            logger.debug("bevInvWarning check complete");

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** Return all the normal users and their permission level for a specific location's customer.
     *    Only users who are NOT admins or supermanagers will be returned.
     *    For example, if Location 3 belongs to Customer 1, and Loc 3 is passed,
     *    the all the normal users for Customer 1 will be returned, along with their
     *    permission level for Loc 3, including users that have "no access" to Loc 3.
     */
    private void getNormalUsers(Element toHandle, Element toAppend)
            throws HandlerException {

        int locationId = HandlerUtils.getRequiredInteger(toHandle, "locationId");

        String getCustomer = "SELECT customer FROM location WHERE id=?";
        String getUsers =
                " SELECT u.id, u.name, m.securityLevel " +
                " FROM user u LEFT JOIN userMap m ON m.user=u.id " +
                " WHERE u.isManager=0 AND u.customer=? AND m.location=? " +
                " UNION " +
                " SELECT u2.id, u2.name, 10 " +
                " FROM user u2 " +
                " WHERE u2.isManager=0 AND u2.customer=? and u2.id not in " +
                "      (SELECT user FROM userMap WHERE location=?)";


        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            int customerId;
            stmt = conn.prepareStatement(getCustomer);
            stmt.setInt(1, locationId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                customerId = rs.getInt(1);
                stmt = conn.prepareStatement(getUsers);
                int index = 0;
                stmt.setInt(++index, customerId);
                stmt.setInt(++index, locationId);
                stmt.setInt(++index, customerId);
                stmt.setInt(++index, locationId);
                rs = stmt.executeQuery();
                while (rs.next()) {
                    index = 0;
                    int userId = rs.getInt(++index);
                    String fullName = rs.getString(++index);
                    int securityLevel = rs.getInt(++index);
                    if (securityLevel < 1) {
                        securityLevel = 10;
                    }

                    Element userEl = toAppend.addElement("user");
                    userEl.addElement("fullName").addText(HandlerUtils.nullToEmpty(fullName));
                    userEl.addElement("userId").addText(String.valueOf(userId));
                    userEl.addElement("permission").addText(String.valueOf(securityLevel));
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }


    }

    /** Return all customer-managers for a specific customer
     */
    private void getAdminUsers(Element toHandle, Element toAppend)
            throws HandlerException {

        int customerId = HandlerUtils.getRequiredInteger(toHandle, "customerId");

        String getCustomer = " SELECT id,name FROM user WHERE customer=? AND isManager=1 ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(getCustomer);
            stmt.setInt(1, customerId);
            rs = stmt.executeQuery();
            while (rs.next()) {
                Element userEl = toAppend.addElement("user");
                userEl.addElement("userId").addText(String.valueOf(rs.getInt(1)));
                userEl.addElement("fullName").addText(HandlerUtils.nullToEmpty(rs.getString(2)));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }


    }

    /** Returns information about a single user.  The caller must pass their own
     *  userid to verify that they belong to the same customer.
     *
     * This method will return the username, fullname, emailAddress, manager status,
     * and location permissions (if applicable).
     *
     */
    private void getUserDetail(Element toHandle, Element toAppend) throws HandlerException {
        int callerId = getCallerId(toHandle);
        int targetId = HandlerUtils.getRequiredInteger(toHandle, "targetId");

        String getUser =
                " SELECT name, username, email, customer, isManager, mobile, carrier, unit" +
                " FROM user WHERE id = ?";
        String getMap =
                " SELECT l.name, l.id, m.securityLevel FROM userMap m" +
                " LEFT JOIN location l ON m.location = l.id " +
                " WHERE m.user = ?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            int callerCust = -1;

            stmt = conn.prepareStatement(getUser);
            stmt.setInt(1, callerId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                callerCust = rs.getInt(4);
            }

            stmt = conn.prepareStatement(getUser);
            stmt.setInt(1, targetId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                String name = rs.getString(1);
                String username = rs.getString(2);
                String email = rs.getString(3);
                int customer = rs.getInt(4);
                int isManager = rs.getInt(5);
                String mobile = rs.getString(6);
                String carrier = rs.getString(7);
                int unit = rs.getInt(8);

                //check that the caller should be able to see this info
                if (callerCust == 0 || callerCust == customer) {
                    toAppend.addElement("fullName").addText(HandlerUtils.nullToEmpty(name));
                    toAppend.addElement("username").addText(HandlerUtils.nullToEmpty(username));
                    toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(email));
                    toAppend.addElement("mobile").addText(HandlerUtils.nullToEmpty(mobile));
                    toAppend.addElement("carrier").addText(HandlerUtils.nullToEmpty(carrier));
                    toAppend.addElement("isManager").addText(String.valueOf(isManager));
                    toAppend.addElement("unit").addText(String.valueOf(unit));
                    if (isManager == 0) {
                        stmt = conn.prepareStatement(getMap);
                        stmt.setInt(1, targetId);
                        rs = stmt.executeQuery();
                        while (rs.next()) {
                            Element permEl = toAppend.addElement("location");
                            permEl.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                            permEl.addElement("locationId").addText(String.valueOf(rs.getInt(2)));
                            permEl.addElement("permission").addText(String.valueOf(rs.getInt(3)));
                        }
                    }
                } else {
                    addErrorDetail(toAppend, "You don't have permission to view this user");
                    logger.portalAccessViolation("Permission problem: Tried to getUserDetail on " + targetId + " by " + callerId);
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**
     * The folowing code is to get user email info for sending email reports - SR
     */
    private void getUserEmailInfo(Element toHandle, Element toAppend) throws HandlerException {

        int callerId = getCallerId(toHandle);
        int customerId = HandlerUtils.getOptionalInteger(toHandle, "customerId");
        int locationId = HandlerUtils.getOptionalInteger(toHandle, "locationId");
        int userId = HandlerUtils.getOptionalInteger(toHandle, "userId");
        double easternOffset = HandlerUtils.getOptionalInteger(toHandle, "offset");
        int paramsSet = 0;

        //NischaySharma_30-Jul-2009_Start
        String select = " SELECT e.report, e.user, e.bar, e.location, e.customer, e.emailAddr, e.time, e.platform, e.reportFormat FROM emailReports e ";
        //NischaySharma_30-Jul-2009_End

        PreparedStatement stmt = null;
        ResultSet rs = null;

        logger.portalAction("getUserEmailInfo");

        if (customerId >= 0) {
            paramsSet++;
        }
        if (easternOffset > -1.00) {
            paramsSet++;
        }
        if (locationId >= 0) {
            paramsSet++;
        }
        if (userId >= 0) {
            paramsSet++;
        }
        if (paramsSet > 1) {
            throw new HandlerException("Only one parameter can be set for getUserEmailInfo.");
        }

        try {
            if (customerId > 0) {
                select += " WHERE e.customer = ? ORDER BY e.report, e.customer ";
                stmt = conn.prepareStatement(select);
                stmt.setInt(1, customerId);
            } else if (locationId > 0) {
                select += " WHERE e.location = ? ORDER BY e.report, e.customer ";
                stmt = conn.prepareStatement(select);
                stmt.setInt(1, locationId);
            } else if (userId > 0) {
                select += " WHERE e.user = ? ORDER BY e.report, e.customer ";
                stmt = conn.prepareStatement(select);
                stmt.setInt(1, userId);
            } else if (easternOffset > 0.00) {
                select += " LEFT JOIN location l ON l.id = e.location " +
                        " WHERE l.easternOffset = ? ORDER BY e.report, e.customer ";
                stmt = conn.prepareStatement(select);
                stmt.setDouble(1, easternOffset);
            } //NischaySharma_31-Jul-2009_Start
            else {
                stmt = conn.prepareStatement(select);
            }
            //NischaySharma_31-Jul-2009_End

            rs = stmt.executeQuery();
            while (rs.next()) {
                int colCount = 1;
                Element userReportEl = toAppend.addElement("userReportInfo");
                userReportEl.addElement("report").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("user").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("bar").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("location").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("customer").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("emailAddr").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                userReportEl.addElement("platform").addText(String.valueOf(rs.getInt(colCount++)));
                userReportEl.addElement("time").addText(String.valueOf(rs.getInt(colCount++)));
                //NischaySharma_30-Jul-2009_Start
                userReportEl.addElement("reportFormat").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                //NischaySharma_30-Jul-2009_End
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }

    /** Returns information about a single user.  The caller must pass their own
     *  userid to verify that they belong to the same customer.
     *
     * This method will return the username, fullname, emailAddress, manager status,
     * and location permissions (if applicable).
     *
     */
    private void getSupplierUserDetail(Element toHandle, Element toAppend) throws HandlerException {
        int callerId = getCallerId(toHandle);
        int targetId = HandlerUtils.getRequiredInteger(toHandle, "targetId");

        String getSupplierUser =
                " SELECT name, username, email, supplier, isCorporate, isRegional, mobile, carrier" +
                " FROM supplierUser WHERE id = ?";
        String getSupplierUserMap =
                " SELECT l.name, l.id, m.securityLevel FROM supplierUserMap m" +
                " LEFT JOIN location l ON m.location = l.id " +
                " WHERE m.user = ?";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            int callerSupplier = -1;

            stmt = conn.prepareStatement(getSupplierUser);
            stmt.setInt(1, callerId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                callerSupplier = rs.getInt(4);
            }

            stmt = conn.prepareStatement(getSupplierUser);
            stmt.setInt(1, targetId);
            rs = stmt.executeQuery();
            if (rs.next()) {
                String name = rs.getString(1);
                String username = rs.getString(2);
                String email = rs.getString(3);
                int supplier = rs.getInt(4);
                int isCorporate = rs.getInt(5);
                int isRegional = rs.getInt(6);
                String mobile = rs.getString(7);
                String carrier = rs.getString(8);

                //check that the caller should be able to see this info
                if (callerSupplier == 0 || callerSupplier == supplier) {
                    toAppend.addElement("fullName").addText(HandlerUtils.nullToEmpty(name));
                    toAppend.addElement("username").addText(HandlerUtils.nullToEmpty(username));
                    toAppend.addElement("email").addText(HandlerUtils.nullToEmpty(email));
                    toAppend.addElement("mobile").addText(HandlerUtils.nullToEmpty(mobile));
                    toAppend.addElement("carrier").addText(HandlerUtils.nullToEmpty(carrier));
                    toAppend.addElement("isCorporate").addText(String.valueOf(isCorporate));
                    if (isCorporate == 0) {
                        stmt = conn.prepareStatement(getSupplierUserMap);
                        stmt.setInt(1, targetId);
                        rs = stmt.executeQuery();
                        while (rs.next()) {
                            Element permEl = toAppend.addElement("location");
                            permEl.addElement("locationName").addText(HandlerUtils.nullToEmpty(rs.getString(1)));
                            permEl.addElement("locationId").addText(String.valueOf(rs.getInt(2)));
                            permEl.addElement("permission").addText(String.valueOf(rs.getInt(3)));
                        }
                    }
                } else {
                    addErrorDetail(toAppend, "You don't have permission to view this user");
                    logger.portalAccessViolation("Permission problem: Tried to getUserDetail on " + targetId + " by " + callerId);
                }
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** @deprecated use getNormalUsers or getAdminUsers instead
     */
    private void getUsers(Element toHandle, Element toAppend)
            throws HandlerException {

        String select = "SELECT user.name, user.username, userMap.customer, " +
                "   userMap.securityLevel, customer.name " +
                " FROM user left join userMap on userMap.user=user.id " +
                " LEFT JOIN customer ON customer.id = userMap.customer " +
                " ORDER BY user.username ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {

            stmt = conn.prepareStatement(select);
            rs = stmt.executeQuery();
            String currentUser = "";
            Element userEl = null;
            while (rs.next()) {
                String fullName = rs.getString(1);
                String username = rs.getString(2);
                int customerId = rs.getInt(3);
                int securityLevel = rs.getInt(4);
                String customerName = rs.getString(5);

                if (currentUser != username || userEl == null) {
                    userEl = toAppend.addElement("user");
                    userEl.addElement("username").addText(username);
                    userEl.addElement("fullName").addText(fullName);
                    currentUser = username;
                }
                Element custEl = userEl.addElement("customer");
                custEl.addElement("customerId").addText(String.valueOf(customerId));
                custEl.addElement("customerName").addText(HandlerUtils.nullToEmpty(customerName));
                custEl.addElement("securityLevel").addText(String.valueOf(securityLevel));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**     Web manager security levels:
     *  All users are associated with a customer
     *
     *  Each user has a Manager flag.
     *  A manager can access every location for that customer.  They can also set
     *  up subordinate accounts for their customer, and set other permissions.
     *
     * If a user is not a manager, his permissions are defined individually for
     * each location.  The possible location-level permissions are:
     *      No-access
     *      Read-only
     *      Supervisor
     *
     *  No-access:  This location isn't available at all to this user
     *  Read-only:  This user can view reports and inventory information, but can't make any changes
     *  Supervisor: This user can make changes, including inventory and draft lines.  He can
     *      also manage read-only accounts at the location.  He can see a list of all non-
     *      manager accounts across ALL locations for this customer, and give or remove
     *      read-only access to his location.
     *
     * As far as the web manager is concerned, it loads one location at a time, and needs to know
     * what permissions a user has at that location.  The web manager actually has a fourth permission,
     * called admin.  Admin is a special permission level for super users that are assoicated with
     * customer 0, the super-customer.    Admins can access all customers, and can set up new
     * customers and new locations.  So, this method needs to return a list of locations and permissions
     * that this user has.
     *
     * By convention, the usbn database uses the followng numbers for permissions:
     *    1 : admin
     *    3 : super-manager (customer level)
     *    5 : manager
     *    7 : read-only
     * See also: net.terakeet.usbn.WebPermssion
     */
    private void authUser(Element toHandle, Element toAppend)
            throws HandlerException {

        final int HQ_CUSTID = 10;
        final int ROOT_CUSTOMER = 0;
        //final String ADMIN_SECURITY_STRING = "1";
        //final String SUPERVISOR_SECURITY_STRING = "3";

        String username = HandlerUtils.getRequiredString(toHandle, "username");
        String password = HandlerUtils.getRequiredString(toHandle, "password");

        String checkRoot = "SELECT u.id, u.isManager, u.lastCustomer, u.customer FROM user u " +
                " WHERE u.username = ? AND u.password = ? ";

        String selectNormal = "SELECT l.id, l.name, c.id, c.name, l.easternOffset, m.securityLevel " +
                " FROM userMap m " +
                " LEFT JOIN location l ON m.location = l.id " +
                " LEFT JOIN customer c ON l.customer = c.id " +
                " WHERE m.user=? " +
                " ORDER BY m.securityLevel ASC, l.id ASC";

        String selectRoot = "SELECT l.id, l.name, c.id, c.name, l.easternOffset " +
                " FROM customer c " +
                " LEFT JOIN location l ON l.customer = c.id " +
                " WHERE c.id=? " +
                " ORDER BY l.id ASC ";


        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            // we need to know if the user has Admin access
            stmt = conn.prepareStatement(checkRoot);
            stmt.setString(1, username);
            stmt.setString(2, password);
            rs = stmt.executeQuery();

            int isManager = -1;
            int userId = -1;
            int customerToLoad = 0;
            int associatedCustomer = -1;
            boolean isSuperAdmin = false;
            if (rs != null && rs.next()) {
                int rsIndex = 1;
                userId = rs.getInt(rsIndex++);
                isManager = rs.getInt(rsIndex++);
                customerToLoad = rs.getInt(rsIndex++);
                associatedCustomer = rs.getInt(rsIndex++);
                if (associatedCustomer == ROOT_CUSTOMER) {
                    if (customerToLoad <= 0) {
                        customerToLoad = HQ_CUSTID;
                    }
                    isSuperAdmin = true;
                } else {
                    customerToLoad = associatedCustomer;
                    isSuperAdmin = false;
                }
                toAppend.addElement("userId").addText(String.valueOf(userId));
            }
            if (isManager > 0) {
                // the user is an Admin (root)
                String logMessage = "Granting " + (isSuperAdmin ? "Admin" : "Super-manager") + " access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, conn);
                stmt = conn.prepareStatement(selectRoot);
                stmt.setInt(1, customerToLoad);
                rs = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    WebPermission perm = isSuperAdmin ? WebPermission.instanceOfUsbnAdmin() : WebPermission.instanceOfCustomerAdmin();
                    locEl.addElement("securityLevel").addText(String.valueOf(perm.getLevel()));
                }
            } else if (userId >= 0) {
                // the user is not an Admin(root)
                String logMessage = "Granting map-level access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, conn);
                stmt = conn.prepareStatement(selectNormal);
                stmt.setInt(1, userId);
                rs = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("securityLevel").addText(String.valueOf(rs.getInt(rsIndex++)));
                }
            } else {
                logger.portalAction("Authentication failed for " + username);
                // authentication failed
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**     Web manager security levels:
     *  All users are associated with a customer
     *
     *  Each user has a Manager flag.
     *  A manager can access every location for that customer.  They can also set
     *  up subordinate accounts for their customer, and set other permissions.
     *
     * If a user is not a manager, his permissions are defined individually for
     * each location.  The possible location-level permissions are:
     *      No-access
     *      Read-only
     *      Supervisor
     *
     *  No-access:  This location isn't available at all to this user
     *  Read-only:  This user can view reports and inventory information, but can't make any changes
     *  Supervisor: This user can make changes, including inventory and draft lines.  He can
     *      also manage read-only accounts at the location.  He can see a list of all non-
     *      manager accounts across ALL locations for this customer, and give or remove
     *      read-only access to his location.
     *
     * As far as the web manager is concerned, it loads one location at a time, and needs to know
     * what permissions a user has at that location.  The web manager actually has a fourth permission,
     * called admin.  Admin is a special permission level for super users that are assoicated with
     * customer 0, the super-customer.    Admins can access all customers, and can set up new
     * customers and new locations.  So, this method needs to return a list of locations and permissions
     * that this user has.
     *
     * By convention, the usbn database uses the followng numbers for permissions:
     *    1 : admin
     *    3 : super-manager (customer level)
     *    5 : manager
     *    7 : read-only
     * See also: net.terakeet.usbn.WebPermssion
     */
    private void authSupplierUser(Element toHandle, Element toAppend)
            throws HandlerException {

        final int HQ_SUPPLIERID = 86;
        final int ROOT_SUPPLIER = 0;
        //final String ADMIN_SECURITY_STRING = "1";
        //final String SUPERVISOR_SECURITY_STRING = "3";

        String username = HandlerUtils.getRequiredString(toHandle, "username");
        String password = HandlerUtils.getRequiredString(toHandle, "password");

        String checkRoot = "SELECT su.id, su.isCorporate, su.isRegional, su.supplier, s.name FROM supplierUser su " +
                " LEFT JOIN supplier s ON s.id = su.supplier WHERE su.username = ? AND su.password = ? ";

        String selectNormal = "SELECT l.id, l.name, c.id, c.name, c.type, l.easternOffset, m.securityLevel" +
                " FROM SupplierUserMap m " +
                " LEFT JOIN location l ON m.location = l.id " +
                " LEFT JOIN customer c ON l.customer = c.id " +
                " WHERE m.user=? " +
                " ORDER BY m.securityLevel ASC, l.id ASC";

        String selectRoot = "SELECT l.id, l.name, c.id, c.name, c.type, l.easternOffset" +
                " FROM location l LEFT JOIN locationSupplier map ON map.location = l.id " +
                " LEFT JOIN supplierAddress a ON map.address = a.id LEFT JOIN supplier s ON a.supplier=s.id " +
                " LEFT JOIN customer c ON l.customer = c.id " +
                " WHERE s.id=? " +
                " ORDER BY l.id ASC ";


        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            // we need to know if the user has Admin access
            stmt = conn.prepareStatement(checkRoot);
            stmt.setString(1, username);
            stmt.setString(2, password);
            rs = stmt.executeQuery();

            int isCorporate = -1;
            int isRegional = -1;
            int userId = -1;
            int supplierToLoad = 0;
            String supplierName;
            boolean isSuperAdmin = false;
            if (rs != null && rs.next()) {
                int rsIndex = 1;
                userId = rs.getInt(rsIndex++);
                isCorporate = rs.getInt(rsIndex++);
                isRegional = rs.getInt(rsIndex++);
                supplierToLoad = rs.getInt(rsIndex++);
                supplierName = rs.getString(rsIndex++);
                if (supplierToLoad == ROOT_SUPPLIER) {
                    if (supplierToLoad <= 0) {
                        supplierToLoad = HQ_SUPPLIERID;
                    }
                    isSuperAdmin = true;
                } else {
                    isSuperAdmin = false;
                }
                toAppend.addElement("userId").addText(String.valueOf(userId));
                Element suppEl = toAppend.addElement("supplier");
                suppEl.addElement("supplierId").addText(String.valueOf(supplierToLoad));
                suppEl.addElement("supplierName").addText(HandlerUtils.nullToEmpty((supplierName)));
            }

            if (isSuperAdmin) {
                // the user is an Admin (root)
                String logMessage = "Granting USBN Super-Admin access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, conn);
                stmt = conn.prepareStatement(selectRoot);
                stmt.setInt(1, supplierToLoad);
                rs = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    WebPermission perm = isSuperAdmin ? WebPermission.instanceOfUsbnAdmin() : WebPermission.instanceOfCustomerAdmin();
                    locEl.addElement("securityLevel").addText(String.valueOf(perm.getLevel()));

                }
            } else if (isCorporate > 0) {
                // the user is an Admin (root)
                String logMessage = "Granting Supplier Admin access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, conn);
                stmt = conn.prepareStatement(selectRoot);
                stmt.setInt(1, supplierToLoad);
                rs = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    WebPermission perm = isSuperAdmin ? WebPermission.instanceOfUsbnAdmin() : WebPermission.instanceOfCustomerAdmin();
                    locEl.addElement("securityLevel").addText(String.valueOf(perm.getLevel()));

                }
            } else if (isRegional >= 0) {
                // the user is not an Admin(root)
                String logMessage = "Granting Supplier Regional Admin access for " + username;
                logger.portalDetail(userId, "login", 0, logMessage, conn);
                stmt = conn.prepareStatement(selectNormal);
                stmt.setInt(1, userId);
                rs = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("securityLevel").addText(String.valueOf(rs.getInt(rsIndex++)));

                }
            } else {
                logger.portalAction("Authentication failed for " + username);
                // authentication failed
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**     Web manager security levels:
     *  All users are associated with a customer
     *
     *  Each user has a Manager flag.
     *  A manager can access every location for that customer.  They can also set
     *  up subordinate accounts for their customer, and set other permissions.
     *
     * If a user is not a manager, his permissions are defined individually for
     * each location.  The possible location-level permissions are:
     *      No-access
     *      Read-only
     *      Supervisor
     *
     *  No-access:  This location isn't available at all to this user
     *  Read-only:  This user can view reports and inventory information, but can't make any changes
     *  Supervisor: This user can make changes, including inventory and draft lines.  He can
     *      also manage read-only accounts at the location.  He can see a list of all non-
     *      manager accounts across ALL locations for this customer, and give or remove
     *      read-only access to his location.
     *
     * As far as the web manager is concerned, it loads one location at a time, and needs to know
     * what permissions a user has at that location.  The web manager actually has a fourth permission,
     * called admin.  Admin is a special permission level for super users that are assoicated with
     * customer 0, the super-customer.    Admins can access all customers, and can set up new
     * customers and new locations.  So, this method needs to return a list of locations and permissions
     * that this user has.
     *
     * By convention, the usbn database uses the followng numbers for permissions:
     *    1 : admin
     *    3 : super-manager (customer level)
     *    5 : manager
     *    7 : read-only
     * See also: net.terakeet.usbn.WebPermssion
     */
    private void authBevSyncUser(Element toHandle, Element toAppend)
            throws HandlerException {

        String username = HandlerUtils.getRequiredString(toHandle, "username");
        String password = HandlerUtils.getRequiredString(toHandle, "password");

        String checkRoot = "SELECT su.id, su.isCorporate, su.isRegional, " +
                " uPM.easternOffset, uPM.threshold, uPM.emailType FROM supplierUser su " +
                " LEFT JOIN userPreferenceMap uPM ON uPM.user = su.id " +
                " WHERE su.username = ? AND su.password = ? ";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            // we need to know if the user has Admin access
            stmt = conn.prepareStatement(checkRoot);
            stmt.setString(1, username);
            stmt.setString(2, password);
            rs = stmt.executeQuery();

            int isCorporate = -1;
            int isRegional = -1;
            int userId = -1;
            boolean isSuperAdmin = false;
            if (rs != null && rs.next()) {
                int rsIndex = 1;
                userId = rs.getInt(rsIndex++);
                isCorporate = rs.getInt(rsIndex++);
                isRegional = rs.getInt(rsIndex++);
                toAppend.addElement("userId").addText(String.valueOf(userId));
                toAppend.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                toAppend.addElement("threshold").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                toAppend.addElement("emailType").addText(String.valueOf(rsIndex++));
                toAppend.addElement("securityLevel").addText("3");
                toAppend.addElement("productType").addText("1");
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /** Retrieves a location list for the specified customer.
     *  Requires an admin user.
     */
    private void adminChangeCustomer(Element toHandle, Element toAppend)
            throws HandlerException {

        final int ROOT_CUSTOMER = 0;
        final String ADMIN_SECURITY_STRING = "1";

        int userId = HandlerUtils.getRequiredInteger(toHandle, "userId");
        int custId = HandlerUtils.getRequiredInteger(toHandle, "customerId");

        String checkAdmin = "SELECT customer FROM user WHERE id = ?";

        String updateLastCustomer = "UPDATE user SET lastCustomer = ? " +
                " WHERE id = ?";

        String selectAdmin = "SELECT l.id, l.name, c.id, c.name, c.type, l.easternOffset, l.volAdjustment " +
                " FROM customer c " +
                " LEFT JOIN location l ON l.customer = c.id " +
                " WHERE c.id = ? " +
                " ORDER BY l.id ASC ";


        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            // we need to know if the user id has Admin access
            stmt = conn.prepareStatement(checkAdmin);
            stmt.setInt(1, userId);
            rs = stmt.executeQuery();

            int rootCust = -1;
            if (rs != null && rs.next()) {
                int rsIndex = 1;
                rootCust = rs.getInt(rsIndex++);
            }
            if (rootCust == ROOT_CUSTOMER) {
                // the user is an Admin
                logger.debug("Granting Admin access - switching to customer " + custId);
                logger.portalAction("Superuser #" + userId + " switching to customer " + custId);
                stmt = conn.prepareStatement(selectAdmin);
                stmt.setInt(1, custId);
                rs = stmt.executeQuery();
                while (rs != null && rs.next()) {
                    int rsIndex = 1;
                    Element locEl = toAppend.addElement("location");
                    locEl.addElement("locationId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("locationName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerId").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("customerName").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("customerType").addText(String.valueOf(rs.getInt(rsIndex++)));
                    locEl.addElement("easternOffset").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("volAdjustment").addText(HandlerUtils.nullToEmpty((rs.getString(rsIndex++))));
                    locEl.addElement("securityLevel").addText(ADMIN_SECURITY_STRING);
                }

                stmt = conn.prepareStatement(updateLastCustomer);
                stmt.setInt(1, custId);
                stmt.setInt(2, userId);
                stmt.executeUpdate();

            } else {
                logger.portalAccessViolation("User #" + userId + " tried to switch to C#" + custId + ", FAILED");
                // user is not an admin
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }

    }

    /**  Retrieves a client key for a location ID and a vendor ID.  This method may only be called by clients that
     * possess an admin key for for location 0.
     */
    private void getClientKey(Element toHandle, Element toAppend, SecureSession ss)
            throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int vendor = HandlerUtils.getRequiredInteger(toHandle, "vendorId");
        int user = HandlerUtils.getRequiredInteger(toHandle, "userId");
        logger.portalAction("Client Key request by user " + user + " for location " + location + ", vendor " + vendor);
        if (ss.getLocation() == 0 && ss.getSecurityLevel().canAdmin()) {
            String key = ClientKeyManager.createClientKey(location, vendor, 100);
            toAppend.addElement("clientKey").addText(HandlerUtils.nullToEmpty(key));
            logger.portalDetail(user, "clientKey", location, " Client Key generated and returned", conn);
        } else {
            logger.portalAccessViolation("Attempted to get a Client Key for L" + location + " V" + vendor + " with a " +
                    "key that authenticated for L:" + ss.getLocation() + " SL:" + ss.getSecurityLevel().toString());
        }

    }

    private void getDbHealth(Element toHandle, Element toAppend)
            throws HandlerException {
        logger.dbAction("DB Health Check");
        toAppend.addElement("publicUsers").addText(String.valueOf(conn.getUsers()));
        logger.dbAction("DB Health Check getting DCM Report: ");
        logger.dbAction("DB Health Check Report {" + DatabaseConnectionManager.report() + "}");
        logger.dbAction("DB Health Check Complete");
    }

    /**
     * Get all misc products from one location, or optionally from one supplier
     */
    private void getMiscProducts(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int supplier = HandlerUtils.getOptionalInteger(toHandle, "supplierId");
        boolean getInactive = HandlerUtils.getOptionalBoolean(toHandle, "getInactive");

        int callerId = getCallerId(toHandle);

        String sql = "SELECT id, name, plu, supplier, active FROM miscProduct WHERE location=? " +
                (!getInactive ? " AND active=1" : "");
        String sqlSupplier = "SELECT id, name, plu, supplier, active FROM miscProduct WHERE location=? AND supplier=? " +
                (!getInactive ? " AND active=1" : "");
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            if (-1 == supplier || -999 == supplier) {
                stmt = conn.prepareStatement(sql);
                stmt.setInt(1, location);
            } else {
                stmt = conn.prepareStatement(sqlSupplier);
                stmt.setInt(1, location);
                stmt.setInt(2, supplier);
            }

            rs = stmt.executeQuery();
            while (rs.next()) {
                Element mpEl = toAppend.addElement("product");
                int colCount = 1;

                mpEl.addElement("id").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                mpEl.addElement("name").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                mpEl.addElement("plu").addText(HandlerUtils.nullToEmpty(rs.getString(colCount++)));
                mpEl.addElement("supplier").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                mpEl.addElement("active").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));

                logger.portalDetail("Get misc products according to specific location and supplier (optional)");
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }
    }

    /**
     * The purchase summary method returns a list of all the products ordered 
     * and received over a certain period, and the quantity that they were ordered.
     */
    private void getPurchaseSummary(Element toHandle, Element toAppend) throws HandlerException {
        int locationId = HandlerUtils.getRequiredInteger(toHandle, "location");
        String startDate = HandlerUtils.getRequiredString(toHandle, "startDate");
        String endDate = HandlerUtils.getRequiredString(toHandle, "endDate");
        int supplierId = HandlerUtils.getOptionalInteger(toHandle, "supplier");

        String selectProduct = "SELECT pr.name, SUM(pd.quantity) FROM purchase pu LEFT JOIN purchaseDetail pd ON pu.id = pd.purchase" +
                " LEFT JOIN product pr ON pd.product = pr.id WHERE pu.location = ? AND pu.status = 'RECEIVED' AND " +
                (supplierId > 0 ? " pu.supplier=? AND " : "") + " (pu.receivedDate BETWEEN ? AND ?) GROUP BY pd.product";
        String selectMiscProduct = "SELECT pr.name, SUM(pd.quantity) FROM purchase pu LEFT JOIN purchaseDetailMisc pd ON pu.id = pd.purchase" +
                " LEFT JOIN miscProduct pr ON pd.product = pr.id WHERE pu.location = ? AND pu.status = 'RECEIVED' AND " +
                (supplierId > 0 ? " pu.supplier=? AND " : "") + " (pu.receivedDate BETWEEN ? AND ?) GROUP BY pd.product";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        ResultSet rsMisc = null;

        int paramIndex = 1;

        try {
            // get all products in the purchases;
            stmt = conn.prepareStatement(selectProduct);
            stmt.setInt(paramIndex++, locationId);
            if (supplierId > 0) {
                stmt.setInt(paramIndex++, supplierId);
            }
            stmt.setString(paramIndex++, startDate);
            stmt.setString(paramIndex++, endDate);
            rs = stmt.executeQuery();

            // get all miscProducts in the purchases;
            paramIndex = 1;
            stmt = conn.prepareStatement(selectMiscProduct);
            stmt.setInt(paramIndex++, locationId);
            if (supplierId > 0) {
                stmt.setInt(paramIndex++, supplierId);
            }
            stmt.setString(paramIndex++, startDate);
            stmt.setString(paramIndex++, endDate);
            rsMisc = stmt.executeQuery();

            while (rs.next()) {
                Element el = toAppend.addElement("product");
                int colCount = 1;

                el.addElement("name").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("quantity").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                el.addElement("misc").addText(HandlerUtils.nullToEmpty("0"));
            }

            while (rsMisc.next()) {
                Element el = toAppend.addElement("product");
                int colCount = 1;

                el.addElement("name").addText(HandlerUtils.nullToEmpty(String.valueOf(rsMisc.getString(colCount++))));
                el.addElement("quantity").addText(HandlerUtils.nullToEmpty(String.valueOf(rsMisc.getInt(colCount++))));
                el.addElement("misc").addText(HandlerUtils.nullToEmpty("1"));
            }
        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(rsMisc);
            close(stmt);
        }
    }

    ///NischaySharma_24-Mar-2009_Start: Defect #24: Added new handler to support the temperature report
    ///This handler will report the temperature system wise and not line wise
    private void getSystemTemperature(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String startDate = HandlerUtils.getRequiredTimestamp(toHandle, "startDate").toString();
        String endDate = HandlerUtils.getRequiredTimestamp(toHandle, "endDate").toString();
        int cooler = HandlerUtils.getOptionalInteger(toHandle, "coolerId");

        String selectSystemTemp = " SELECT l.name, c.id, c.name, cT.value, date_format(cT.date, '%l:%i %p') FROM coolerTemperature cT " +
                " LEFT JOIN cooler c ON c.id = cT.cooler " +
                " LEFT JOIN location l ON l.id = c.location " +
                " WHERE cT.date BETWEEN ? AND ? AND l.id = ? ";
        if (cooler > 0) {
            selectSystemTemp += " AND c.id = ?";
        }
        selectSystemTemp += " ORDER BY l.id, c.id, cT.date";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(selectSystemTemp);
            stmt.setString(1, startDate);
            stmt.setString(2, endDate);
            stmt.setInt(3, location);
            if (cooler > 0) {
                stmt.setInt(4, cooler);
            }
            rs = stmt.executeQuery();

            while (rs.next()) {
                int colCount = 1;

                Element el = toAppend.addElement("temperatureData");
                el.addElement("location").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("coolerId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                el.addElement("cooler").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("temp").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getDouble(colCount++))));
                el.addElement("time").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    ///SundarRavindran-02-Jun-2009_End
    ///SundarRavindran-02-Jun-2009_Start: 
    ///This handler will report the brix value of the location by dat

    private void getBrix(Element toHandle, Element toAppend) throws HandlerException {
        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        int prodType = HandlerUtils.getOptionalInteger(toHandle, "prodID");
        String startDate = HandlerUtils.getRequiredTimestamp(toHandle, "startDate").toString();
        String endDate = HandlerUtils.getRequiredTimestamp(toHandle, "endDate").toString();

        String selectBrixValues = " SELECT p.id, p.name, l.id, l.lineIndex, ROUND(bR.value,2), date_format(bR.date, '%l:%i %p') " +
                " FROM brixRatio bR LEFT JOIN line l ON l.id = bR.line " +
                " LEFT JOIN bar b ON b.id = l.bar " +
                " LEFT JOIN product p ON p.id = l.product " +
                " WHERE l.status = 'RUNNING' " +
                " AND bR.date BETWEEN ? AND ? AND b.location = ? ";
        if (prodType > 0) {
            selectBrixValues += " AND p.pType = ? ";
        }
        selectBrixValues += " ORDER BY bR.line, bR.date;";

        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            stmt = conn.prepareStatement(selectBrixValues);
            stmt.setString(1, startDate);
            stmt.setString(2, endDate);
            stmt.setInt(3, location);
            if (prodType > 0) {
                stmt.setInt(4, prodType);
            }
            rs = stmt.executeQuery();

            while (rs.next()) {
                int colCount = 1;
                Element el = toAppend.addElement("brixData");
                el.addElement("productId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("product").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("lineId").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getInt(colCount++))));
                el.addElement("lineIndex").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
                el.addElement("brix").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getDouble(colCount++))));
                el.addElement("time").addText(HandlerUtils.nullToEmpty(String.valueOf(rs.getString(colCount++))));
            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.getMessage());
            throw new HandlerException(sqle);
        } finally {
            close(rs);
            close(stmt);
        }
    }
    ///SundarRavindran_02-Jun-2009_End

    /**  Retrieves a client key for a location ID and a vendor ID.  This method may only be called by clients that
     * possess an admin key for for location 0.
     */
    private void checkEventTime(Element toHandle, Element toAppend) throws HandlerException {

        int location = HandlerUtils.getRequiredInteger(toHandle, "locationId");
        String today = HandlerUtils.getRequiredString(toHandle, "todayDate");

        String selectEventTime = "SELECT preOpen, eventEnd FROM eventHours WHERE location = ? AND date = ?";

        PreparedStatement stmt = null;
        ResultSet rs = null;
        java.util.Date currentTime = new Date(Calendar.getInstance().getTimeInMillis());
        java.util.Date preOpen = new Date(Calendar.getInstance().getTimeInMillis());
        java.util.Date eventEnd = new Date(Calendar.getInstance().getTimeInMillis());


        try {

            stmt = conn.prepareStatement(selectEventTime);
            stmt.setInt(1, location);
            stmt.setString(2, today);
            rs = stmt.executeQuery();

            if (rs.next()) {
                preOpen = rs.getTimestamp(1);
                eventEnd = rs.getTimestamp(2);

                if ((currentTime.after(preOpen)) && (currentTime.before(eventEnd))) {
                    toAppend.addElement("isGameTime").addText("1");
                } else {
                    toAppend.addElement("isGameTime").addText("0");
                }

            }

        } catch (SQLException sqle) {
            logger.dbError("Database error: " + sqle.toString());
            throw new HandlerException(sqle);
        } finally {
            close(stmt);
            close(rs);
        }


    }
}
